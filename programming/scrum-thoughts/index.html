<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Mine of Information - Thoughts on Scrum</title>
    <link rel="stylesheet" type="text/css" href="/assets/css/coderay.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/stylesheet.css">
    <link type="application/atom+xml" title="Mine of Information" rel="alternate" href="/atom.xml"> 

    <meta name="generator" content="nanoc 4.12.15"> 
    <meta name="author" content="Simon Kitching"> 
  </head>
  <body>
    <section id="header">
      <span class='title'>The Mine of Information</span> <span class='desc'>(Nuggets of Programming and Linux)</span>
    </section>
    <div id="main">
      <section id='navpane'>
        <section>
  <ul id="navicons">
      <li class="nav">
      <a href="/" title="Home"><img src="/assets/images/Home.png"></a>
      <a href="/archives/" title="Archives"><img src="/assets/images/Calendar.png"></a>
      <a href="/site/welcome" title="E-Mail"><img src="/assets/images/Envelope.png"></a>
      <a href="/atom.xml" title="Subscribe Feed"><img src="/assets/images/RSS.png"></a>
      </li>
  </ul>
</section>

<section>
  <h1>About</h1>
  <ul id="about">
    <li>
      <a href="/site/welcome">Welcome</a>
    </li>
  </ul>
</section>

<section>
<h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2023/12/monorepos/">Monorepos and Polyrepos</a>
      </li>
    
      <li class="post">
        <a href="/2023/12/httpapis/">HTTP APIs, REST APIs, and Others</a>
      </li>
    
      <li class="post">
        <a href="/2023/09/biden/">Biden on Democracy</a>
      </li>
    
      <li class="post">
        <a href="/2023/09/tech-breadth/">Maintaining Technical Depth</a>
      </li>
    
      <li class="post">
        <a href="/2023/08/vpns/">The Uselessness of Consumer VPNs</a>
      </li>
    
      <li class="post">
        <a href="/2023/06/microservices/">Some Aspects of Implementing Microservices..</a>
      </li>
    
      <li class="post">
        <a href="/2023/06/dtest-evolution-scrum-monad/">DDD, Architecture patterns, and More..</a>
      </li>
    
      <li class="post">
        <a href="/2023/05/testing/">Should Unit Tests Verify Requirements Only?</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Categories</h1>
  <ul id="categories">
    
      <li class="catlink">
        <a href='/category/Architecture/'>Architecture</a>
      </li>
    
      <li class="catlink">
        <a href='/category/BigData/'>BigData</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Cloud/'>Cloud</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Cryptography/'>Cryptography</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Git/'>Git</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Infrastructure/'>Infrastructure</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Java/'>Java</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Links/'>Links</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Linux/'>Linux</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Network/'>Network</a>
      </li>
    
      <li class="catlink">
        <a href='/category/OSGi/'>OSGi</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Off-topic/'>Off-topic</a>
      </li>
    
      <li class="catlink">
        <a href='/category/OpenWRT/'>OpenWRT</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Programming/'>Programming</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Security/'>Security</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Site/'>Site</a>
      </li>
    
  </ul>
</section>


      </section>
  
      <section id='content'>
        
  <div class='page'>
    <h1>Thoughts on Scrum</h1>
    <aside>First published on: June 9, 2023</aside>
    
    <article>
    <p>Categories: <a href='/category/Programming/'>Programming</a>, <a href='/category/Architecture/'>Architecture</a></p>
      
<h1 id="introduction">Introduction</h1>

<p>A few years ago I started working at a company that loosely uses <a href="https://en.wikipedia.org/wiki/Scrum_(software_development)">Scrum</a>-like team organisation for software development. I’ve worked on around half-a-dozen significant projects in the past (various employers or customers) that used Scrum-like processes (more or less), and was never particularly convinced, but thought I should look at it more closely again. In particular, I read the book <a href="https://www.mitchlacey.com/the-scrum-field-guide">The Scrum Field Guide</a> by Mitch Lacey. This article is a (rather late) review of the book, and my personal critical review of the concepts of Scrum in general.</p>

<p>The book is certainly well written, and interesting for those with basic-to-moderate knowledge of Scrum practices.</p>

<p>These notes are mostly for my own reference - I’m certainly not a recognised expert in this area (though I have been in the IT industry for over 25 years, and experienced a wide range of successful, not-so-successful, and completely failed projects). I am a fan of Agile development in general (having lived through many failed waterfall-based projects), though not any particular methodology. I also work regularly on open-source projects which are typically agile-ish (if they can be described as having a development process at all).</p>

<h1 id="a-summary">A Summary</h1>

<p>What I agree with about Scrum in general, and the book The Scrum Field Guide in particular:</p>

<ul>
  <li>do development in teams of 4-9 people, who together should have most (ideally all) of the skills necessary to create, test, and deliver the product.</li>
  <li>give reasonable autonomy to teams and even team members, ie have most decisions made by the people who are going to implement those decisions, rather than having decisions made externally and imposed on the people affected by them.</li>
  <li>record requirements as a priority-ordered list, where the higher the priority the earlier it gets developed, and the more detailed the documented requirements are (“project backlog”)</li>
  <li>include a domain expert in the team (“product owner”)</li>
  <li>regularly release production-quality code to customer (whether internal or external)</li>
  <li>regularly get feedback from customer (real end users)</li>
  <li>regularly review backlog and ensure there are enough implementation-ready items waiting to be done</li>
  <li>regularly review the development process (“retrospectives”)</li>
  <li>projects should never run longer than a year</li>
  <li>work items should be considered “done” only when tested, documented, and in all ways ready for production</li>
</ul>

<p>What I <em>partially</em> agree with:</p>

<ul>
  <li>daily standups</li>
  <li>sprints</li>
  <li>assigning “story points” to the items in the project backlog (ie the requirements)</li>
  <li>measuring team velocity</li>
  <li>having a dedicated team organiser (“Scrum Master” - previously known as a “Project Manager”)</li>
</ul>

<p>What I definitely do not agree with:</p>

<ul>
  <li>assigning features to “sprints” (“commitment”)</li>
  <li>burn-down charts and related concepts (not technically part of Scrum but commonly applied)</li>
</ul>

<p>Interesting that actually I agreed with far more of the book (and thus Scrum in general) than I had expected. Leave out the “assign tasks to the next sprint” step and I have very little problem with the methodology.</p>

<p>The Scrum Field Guide does repeatedly warn against “customising” Scrum - exactly what I am suggesting with the partially-agree/do-not-agree lists above. I make these suggestions therefore with caution - but IMO with good reason.</p>

<h1 id="believability-scepticism-and-caution">Believability, Scepticism and Caution</h1>

<p>First, a few note about putting trust in information sources such as a book or article about Scrum.</p>

<p>When anyone makes claims, and particularly when they try to convince me of something I like to consider their possible motives.</p>

<p>The <a href="https://agilemanifesto.org/">Agile Manifesto</a> is a simple document produced by a group of well-regarded software experts, and there is no obvious money being made directly from it. Ok, the people whose names are on the original version of the document do perhaps get a few more invitations to speak at conferences, and it certainly is a door-opener when offering consulting services to potential customers - but the effect does not seem to be large or direct. I therefore am inclined to think that the contents of the Manifesto truly reflect their beliefs about good software development principles after long careers in the industry.</p>

<p>Scrum, however, is something else. There is a whole industry of Scrum mentoring, conferences, books, and software products. The big names in this industry are making lots of money, and therefore I prefer to look at the proposed concepts of Scrum with care before accepting it as truth. I don’t mean that it is wrong - just that there are motivations for people to promote it regardless of its correctness.</p>

<p>Similarly, those who have invested in Scrum training, are Certified Scrum Coaches, and have built businesses around that knowledge have strong incentives to promote it. It would take a lot of personal integrity for someone with a career in “Scrum” to say “actually, I’ve come to realise that it doesn’t work; I’ll go do something else now”. Even deviating from the <em>Scrum doctrine</em> in just a few areas could be damaging to a career.</p>

<p>There is also a kind of <a href="https://en.wikipedia.org/wiki/Cognitive_bias">cognitive bias</a> where anyone who has invested money or time into learning something is less likely to view that knowledge critically (see flaws) than an outsider, as that would mean admitting their investment is (at least partially) worthless. It takes a relatively strong personality to step away from something that cost effort to obtain. As with any community, there is also the influence of <a href="https://en.wikipedia.org/wiki/Groupthink">groupthink</a>.</p>

<p>I certainly don’t mean to insult any professional Scrum authors or practitioners with any of the above. I just mean that if you go into an Adidas store looking for running shoes, you are not likely to be offered a balanced and impartial comparison of the options.  That doesn’t mean that Scrum in general, and the author of this book in particular, are not 100% correct. They may well be, and certainly have more experience trying to apply Scrum than I have. Nevertheless, I wanted to evaluate the principles of Scrum against my own experience.</p>

<h1 id="fully-convinced">Fully Convinced</h1>

<p>Things about Scrum in general, and the Scrum Field Guide in particular, that I completely agree with..</p>

<h2 id="team-size">Team Size</h2>

<p>It just seems to be a part of human nature that we work best in teams of less than 10. Any attempt to form larger groups just ends up with subgroups naturally forming. And it really is important for morale and communication that the team members understand how others in the team think and work. In addition, it is important to include all members of a team in discussions and decision-making - which is simply impractical with more than 10 people.</p>

<p>When more people are needed on a project, then there need to be multiple teams, with communication and collaboration within each team being informal and efficient while inter-team communication is more formal and therefore less efficient. The work to be done then needs to be distributed across teams so that intra-team communication is more common than inter-team.</p>

<h2 id="individual-and-team-autonomy">Individual and Team Autonomy</h2>

<p>Very few people like following orders. People in the IT industry are generally required to be informed, self-motivated, creative, and to have pride in their work - the kind of people who like following orders even less than the average.</p>

<p>People “in the trenches” often also have information that others do not - and therefore are in a better position to make decisions optimal for their cirumstances.</p>

<p>The implication is that decision-making about <em>how</em> to implement something (rather than what to implement) should be largely done within a team.</p>

<p>On the other hand, software developers focused on day-to-day work often do not have the time to look at “the big picture”, or follow the latest technologies. There therefore needs to be some decision-making at a more abstract cross-team level to produce company-wide consistency and long-term improvements. Such decisions can however be made collaboratively; the existence of this level of decision-making does not necessarily imply the traditional hierarchical “architecture board” that lays down rules for all.</p>

<p>As far as I know, Scrum in general, and the Field Guide in particular, do not have a lot to say about this topic. However this approach at least does not conflict with the Scrum principles, and is IMO generally accepted as “best practice” in modern IT organisations.</p>

<h2 id="requirements-as-a-priority-ordered-list-with-rough-estimates">Requirements as a priority-ordered list with rough estimates</h2>

<p>The waterfall approach starts development with a full requirements document, complete to the point that developers should not need to ask the customer any questions at all; the delivered software just needs to match the documented requirements. This was always nonsense.</p>

<p>Instead, break requirements down to coarse-grained items. Ensure that any “technical features” which are pre-requisites of the business features are also present (eg the need for an authentication system). Then roughly estimate the size of the items (see “story points”). The product owner should have an idea how much money that feature will bring (new dollars earned, or existing expenses saved); the items with the greatest profit:development-effort ratio should be delivered first ie be assigned highest priority - though many other factors can also affect the ordering.</p>

<p>Then the requirements at the top of the list need to be defined in sufficient detail that a developer can work on them, and QA (if it exists) can test them. Requirements that are likely to be worked on within the next month need more detail, and requirements that are low on the priority list can be quite vague. The customer should be free to add new items to the list, or reorder the list, while the project is running. Of course that will affect the delivery dates for items later on the list, and the cost to “deliver all items” but that is obvious to all.</p>

<p>In order to assign reasonable priorities, it is necessary to have a feel for relative development-times - even for features that currently are only vaguely specified. However of course actual “days until delivery” is not possible; the “story points” approach seems to be the best solution to this at the moment - figuring out whether some feature is “as complex as” or “5 times more complex than” another feature is not too unreasonable. The trick is to then resist pressure from management to convert this into “delivery dates”; see later for more thoughts on estimations.</p>

<p>This view is pretty much consistent with Scrum’s concept of a <em>backlog</em>.</p>

<h2 id="domain-expertproduct-owner">Domain Expert/Product Owner</h2>

<p>Developers sometimes need to talk to someone who knows the requirements; even the best “requirements documents” are not complete.</p>

<p>There needs to be a first phase before development starts in which the domain expert gathers the requirements at a rough level and forms the first prioritised requirements list; there is no need to involve developers in this. Involving an architect might be worthwhile though. And the proposed architecture should then be discussed with the development team, reviewed for plausibility, and alternatives discussed. Remember that developers should have a fair bit of autonomy and input into the software they are developing.</p>

<p>The existence of this first analysis/architecture phase does <em>not</em> make a project “waterfall”, as long as there is no expectation that these requirements are <em>complete and immutable</em>. Agility is about the ability to react to changes in a plan, not about having no plan at all. The ability to change also means these initial requirements don’t need to be complete; it is expected that details will be filled out later - and in fact, significant changes in scope or direction may occur as a result of feedback.</p>

<p>Before implementation of a requirement starts, it then needs to be refined to a level at which code can be written; this should be done as a collaboration between a domain expert, the people writing the actual code, and the people defining automated tests (if they are different). There needs to be trust and good communication between the domain expert and the developers, and the domain expert needs to be available for follow-up questions. This means that the domain-expert for a project should be part of the team, not external.</p>

<p>In the case of “bespoke software development” where the development team works for a different company than the end customer, can a customer employee act as the team domain expert? I think not; firstly the level of trust needed is hard to obtain cross-company. Each side needs to be able to express their true concerns here without worrying about their words being escalated to senior management and becoming part of an inter-company disagreement. In addition, the domain expert needs to sit with the team much of the time during the project - the kind of “off-site” work that experienced people generally have no interest in doing.</p>

<p>IMO, this “Scrum product owner” is simply what used to be known as a “business requirements analyst”. The primary difference from the old role is that development starts before all requirements have been completely documented; a “product owner” works in a “just in time” model, aiming to stay just a few steps ahead of the development team. This approach:</p>

<ul>
  <li>brings the ability to change requirements without discarding lots of existing work</li>
  <li>solves arguments about “is this requirement in-scope for this project?”; any requirement can be added to the list. The argument then 
simply becomes “what is the priority relative to other items” which is easier to solve. And low-priority items don’t need
to be specified in detail until they near the top of the list ie it becomes clear that they really are going to be implemented.</li>
  <li>solves the problem of the customer domain experts running and hiding from the development team in order to avoid “being responsible” for
any incorrectly-documented requirements. In particular, “getting signoff on the requirements” in a waterfall model was always
very difficult, as nobody wants to be the fall-guy for mistakes. Having requirements defined just-in-time, in a somewhat less
formal manner, and without big “signoffs”, reduces this pressure.</li>
  <li>allows requirements to be defined relative to the current functionality of the new project (as visible in the current
release). It is far easier to picture the “next step” for software than to picture “step N” of something that does not
yet exist.</li>
</ul>

<h2 id="regularly-release-production-quality-code">Regularly release production-quality code</h2>

<p>I’ve worked on a couple of projects that used the “big bang delivery style” and they did not end well. When a developer can get away with marking an item as “done” when it is really only 60% there, then at some time there is going to be a nasty surprise; instead “done” really does need to mean tested, documented, and releasable.</p>

<p>Providing regular packages of software to the customer that they could install into production (whether they actually do or not) builds a very strong feeling of trust.</p>

<p>And having code in a test-environment that can be accessed by domain experts (including ideally people who would use the new system in production) is a pre-requisite for iterative requirements analysis (see above) and quality feedback (see next).</p>

<h2 id="regularly-get-feedback-from-customer">Regularly get feedback from customer</h2>

<p>This is almost a no-brainer. It’s a core principle of <em>agile development</em> in general, and Scrum in particular.</p>

<p>Quite <em>when and how</em> to get feedback is the question; Scrum couples this to the <em>length of the sprint</em> which IMO is not absolutely necessary, but also not unreasonable.</p>

<p>The Scrum Field Guide makes an excellent point that in a 6-month project using Scrum with 4-week “sprints”, that are just 5 opportunities for the customer to give feedback about whether what is being built is actually what they need. That is probably “just enough” - but even more often would be better, eg delivering every two weeks or every week. Best of all is to have a customer-accessible environment which is updated immediately after each feature is marked as done.</p>

<p>Abstractly imagining how software will work before it exists is a hard task; software architects are supposedly specialists in this but often make mistakes too. Expecting domain experts to do this is unreasonable. Instead, give them a system that works and you’ll get a far better idea of whether what is being created is actually what is needed.</p>

<p>Waterfall often delivered “what was specified but not what was wanted”. And businesses and the environment in which they operate do change rapidly. Feedback during the project, based upon concrete deliveries of “the current state” is truly critical.</p>

<p>Of course, the customer’s staff have other work to do than looking at the software-in-progress every day, and the team need to <em>ensure</em> that they are getting feedback. It therefore seems reasonable to deliver new code on a calendar basis (eg every N weeks) and to ask the customer for feedback on the new release on the same schedule. Scrum delivers “at the start of each sprint” and requests feedback at the same time which is not the only solution, but a reasonable one.</p>

<h2 id="regularly-review-backlog">Regularly review backlog</h2>

<p>As noted earlier, requirements are best represented as a priority list where the high-priority items (next to be implemented) are documented in detail (as partnership of domain expert and developers) while lower-priority items are left vaguer.</p>

<p>The product owner then needs to “keep one step ahead” of the developers, ensuring there are always items available to work on.</p>

<p>While theoretically the maintenance of this list could be “trigger-based”, eg done only when the customer requests a change or the number of implementable items drops below N, it is probably best to instead check the backlog on a regular calendar schedule - particularly as developers need to interrupt their regular work to participate in design and prioritisation, possibly together with external assistants such as architectural experts.</p>

<p>Scrum always performs this task “at the start of each sprint” which is not the only solution but a reasonable one.</p>

<h2 id="regularly-review-the-development-process">Regularly review the development process</h2>

<p>Much of the stuff that Scrum describes has been done for decades by competent teams, and I’d certainly experienced it before Scrum was a thing. However the concept of regular “retrospectives” dedicated to thinking about how the team’s processes could be improved was for me something that was a revelation - so obvious, but not something that I’d seen before.</p>

<p>And it should just be done. On a regular calendar basis. Scrum performs this “at the end of each sprint” which for me feels a bit too often (particularly with short sprints), but regularly scheduled retrospectives are truly great.</p>

<h2 id="projects-should-never-run-longer-than-1-year">Projects should never run longer than 1 year</h2>

<p>Well, the Scrum Field Guide does not explicitly rule this out, but does recommend strongly against it. I would also agree; if something is not truly in production within a year then the chances it will be relevant when complete are very low.</p>

<p>My personal feeling is that two-person-years of development is about the maximum, ie two developers for a year, four for 6 months, etc. Get the stuff released, and start a new project to continue the work.</p>

<p>It’s also just a morale-boost to “finish something” and have a party. It’s also a good time for developers to consider moving on to new roles, new teams, etc. Or to consider new architectures and technologies for the next phase. Projects that just run and run can lead to a feeling of boredom, lack of motivation, and stale thoughts.</p>

<h2 id="done-only-when-done">Done only when Done</h2>

<p>The “definition of done” process in Scrum seems somewhat over-complicated to me, but the idea is generally good.</p>

<p>I remember working on one project that had awards for “the most productive developer of the week”. Management kept giving it to the same developer every week, because he closed more tickets than anyone else. The rest of us were too busy fixing up his poor code.</p>

<p>If marking a ticket as “done” does not mean it is production-quality, then how can the progress to production-quality code be tracked?</p>

<p>A ticket can potentially be handed-off from one team member to another (eg dev to testing) but:</p>

<ul>
  <li>that can potentially lead to disagreements and disrespect within the team (“testing this is your problem, not mine”)</li>
  <li>it can lead to bottlenecks/backlogs where lots of tickets are “partially complete”</li>
</ul>

<p>This is a good reason to combine the roles of development, testing, and release-management. Or at least to have extended “handover periods” where the person handing the work on works together with the next person in the chain as a pair.</p>

<h1 id="partially-convinced">Partially Convinced</h1>

<p>Things about Scrum in general, and the Field Guide in particular, that I find are at least partially justifiable and would apply in some conditions, or with some modification.</p>

<h2 id="daily-standups">Daily Standups</h2>

<p>Like a lot of people I’ve talked to, I’ve experienced a lot of poorly-structured “daily standups”. It could be claimed that this is not a flaw of Scrum, but instead a failing of the users of it. Nevertheless, any process which tempts people to use it wrong is a bad idea; Communism is a great concept in theory which fails in practice because it just runs against human nature. It seems to me that many people’s nature is not compatible with effective standups, with communication being either too brief or <em>far</em> too verbose…</p>

<p>Standups are a major interruption to the “flow” of coding; I seldom get any significant technical work done in the 15 minutes before a meeting, or the 15 minutes after one. When the meeting itself is 15 minutes that makes 45 minutes per day away from technical tasks (per team member)!</p>

<p>Quite often the content of these meetings is pretty boring too.</p>

<p>On the other hand, it is a great opportunity to inform the whole team of relevant info. Rituals are also simply part of human nature, and are very effective in binding groups together.</p>

<p>An alternative to standups is some kind of IRC-like (shared chat channel) system, where everybody posts their status at regular intervals (email is not really good for this, nor are wikis). IMO this approach has some real benefits, including ensuring that the daily meetings do not revert to the common “we are all reporting to the Project Manager/Scrum Master” pattern . However some people just aren’t good communicators; having a physical meeting with verbal reporting is more effective with such team members. And online status reports just do not produce the same feeling of “we are in this together”.</p>

<p>Personally, for any “agile” team (whether Scrum or not) I would seriously consider proposing two physical standups per week (tue/thu), and “mandatory online status updates” on the other days. When combined with the other standard meetings (“backlog grooming”, retrospectives, etc.), I feel this suffices. It also works well when some team members are remote, ie the “physical standup” includes a video-call (always more time-intensive). It may also work better when some team-members are only part-time, ie are members of more than one team concurrently.</p>

<p>If this suggestion is implemented, but the two standups per week regularly run too long, and due to content that really does belong in a standup (the three questions<sup id="fnref:3qns" role="doc-noteref"><a href="#fn:3qns" class="footnote" rel="footnote">1</a></sup>), then that is evidence that for this team and this project daily standups (5 per week) would be appropriate.</p>

<p>As a final note, if standups are implemented then I strongly support keeping them short (as Scrum makes clear). In particular:</p>

<ul>
  <li>
<em>do</em> stand up, never sit down</li>
  <li>address only the “three questions”; postpone all else until later</li>
  <li>don’t have the meetings in a room far from the work areas</li>
  <li>don’t use a computer as part of the standup (eg to display a JIRA board); that just leads to everyone watching while the projector is set up and items are dragged around on a screen. The point is to increase communication, not do paperwork.</li>
</ul>

<h2 id="sprints">Sprints</h2>

<p>As mentioned above, there are many admin tasks that are commonly done on a calendar schedule:</p>

<ul>
  <li>packaging software for installation (if this is not automated and done continuously per-commit)</li>
  <li>installing software into a customer-visible environment (if this is not automated and done continuously per-commit)</li>
  <li>asking customers to review the latest software state and provide feedback</li>
  <li>checking the requirements backlog and ensuring enough items are detailed enough for development</li>
  <li>doing retrospectives</li>
  <li>reporting progress to management/customer (duty of “Scrum Master” and “Product Owner”)</li>
</ul>

<p>These processes do not necessarily have to be done at the same frequency, but it does get harder to track them if they are not. Scrum simply chooses a single “sprint length” and then ensures each of these is done once per sprint. That’s a little clumsy in some respects but also simple to remember. In general, therefore, having “sprints” in which each of these is done makes sense to me.</p>

<p>IMO, what does not make sense is “assigning tickets to a sprint”, ie linking the concept of “work done” to the scheduled tasks above. Or in other words, the concept of <em>planning</em> what tasks are going to be done for an upcoming time period.  I lean towards the “Kanban continuous flow” approach, where team members just pick work off the “requirements backlog” without a “sprint backlog” (see later). Note that skipping this does not prevent calculating “team velocity”; see later.</p>

<p>Where software is being developed for a customer, and deployment into an environment in which the customer can evaluate changes is something that cannot be integrated into a “continuous delivery” system, then sprints make sense; they are the “release unit” and “feedback granularity unit”. Scrum was first published in 1995, when this situation was presumably very common.</p>

<p>On the other hand, if continuous delivery is being practiced and customer feedback is being continuously gathered, then it may be sensible to simply do away with sprints and do the other tasks “on demand” - eg reviewing/refining/restocking the backlog when it drops below a specific size, or when new ideas are raised, rather than at specific times.</p>

<p>I have noticed that the “start of sprint” and “end of sprint” tasks often seem to be heavily centered around “reporting to management”. If this is the case for a particular team, it might be worth looking at whether the ideas of <em>agile development</em> are truly being applied - ie whether the team is perhaps being “over-managed”.</p>

<p>One other possible purpose for a sprint is to package some useful “business value” which is larger than an individual task. However it seems easier to me to do this more directly, simply delivering software as soon as the set of tasks associated with it are done. This avoids delays in delivering the feature (waiting until end of sprint), or unnecessary pressure when the end-of-sprint is approaching and the set of tasks isn’t quite complete. Only when “software delivery” is hard to do does the sprint-oriented approach make sense as a solution, but there it might be more useful to work on better delivery processes than to introduce inefficiencies in the development process.</p>

<h2 id="assigning-story-points">Assigning Story Points</h2>

<p>Estimating software implementation times is hard. Very hard.</p>

<p>Where possible, I prefer to keep estimates as private as possible. If a project is internal then a team might get away with using time-boxed development, ie saying “we’ll deliver as fast as we can until time or budget runs out”. Task prioritisation is then important, but precise time estimates are not. Software development for a long-term customer where a strong trust relationship exists might also be possible to run in this way.</p>

<p>However even when this approach is used, feature size estimates are needed to properly set the priority; the customer (internal or external) usually has an idea of the financial benefit of a specific feature, but they need an estimate of the implementation cost in order to decide whether it should be implemented, and if so where it sits in the order. Developers also need a feel for how many subtasks the feature should be broken into before it is appropriate to be taken by a developer for implementation; each developer-level task should only last a few days so that:</p>

<ul>
  <li>code reviews are sensible</li>
  <li>partially-implemented features can be handed over from developer to developer (eg in case of illness)</li>
  <li>customer review can be gathered and the planned feature adapted if necessary</li>
  <li>everybody feels a sense of progress</li>
</ul>

<p>The concept of “story points” is not good, but is the best solution I am aware of; estimating tasks in comparison to other tasks is probably the best we can do. It is certainly better than producing estimates in “person days”.</p>

<p>If the project’s customer demands a “completion date” for a fixed set of features, then there isn’t much that can be done other than fall back to experience and instinct, multiply the result by 4, and then get ready to argue about requirement-changes, code quality, and missed delivery dates as the project approaches whatever date was finally chosen.</p>

<h2 id="team-velocity">Team Velocity</h2>

<p>Skipping the assignment of tasks (backlog items) to sprints (as I suggest) doesn’t prevent the calculation of “team velocity”; there is still a set of tasks which have been marked as done during this “sprint time period” and these tasks had “story points” associated with them.</p>

<p>Given the velocity over a recent time-period (eg the last 4 weeks), a general feel can be obtained about when a specific point in the project backlog (requirements list) will be reached. Of course this estimate has some pretty wide error-margins, and these will be ignored by those that the information is reported to.</p>

<p>The question is: are errors in the estimates random or do they have a specific bias (eg usually too high or usually too low)? When no significant bias is present, the number of remaining features is relatively large, and the project is relatively long, then the “time to completion” might be halfway accurate. IMO, none of these conditions is likely to be true (bias is likely, the number of features small due to coarse-grained features, and projects should always be much less than one year) so such time estimates are unlikely to be helpful. On the other hand, the author of the Field Guide claims they are useful, and he certainly does have in-field experience. It is perhaps plausible that over time the mapping from “what this team calls a story point” to “real-world person days of work” might stabilise in some rough sense. I might have to mark myself here as “skeptical but willing to try it”.</p>

<p>Interestingly, the concept of “stories”, “story points” and “team velocity” are not defined at all <a href="https://scrumguides.org/">in Scrum itself</a>; all the original guide mentions is that “various practices exist to forecast progress”. I have more to say on the topic of “forecasting and burn-down” later in the “do not agree” section.</p>

<h2 id="a-dedicated-scrum-master">A Dedicated Scrum Master</h2>

<p>In most of the projects I’ve been associated with in the past, for every 5-10 developers there has been a <em>project manager</em> who:</p>

<ul>
  <li>does administration tasks for the team</li>
  <li>organises contact with the customer</li>
  <li>negotiates delivery schedules, requirement changes, etc (at the non-technical level)</li>
</ul>

<p>In other words, this person has been a little “project owner” and a lot “Scrum master”.</p>

<p>I do like the idea of a strict separation of these roles.</p>

<p>Of the project managers I have worked with, their style falls into one of two categories:</p>

<ul>
  <li>hierarchical: “I’m here to tell you what to work on”, or</li>
  <li>supportive: “I’m here to help you work faster; tell me what you need”</li>
</ul>

<p>The second was always my favourite; Scrum makes it clear that the Scrum Master should act in the second manner. This is great, but not new.</p>

<p>The Field Guide does strongly recommend having the Scrum Master do nothing else but be Scrum Master. I’m not sure how practical that is in real life; is there really enough work in the role to fill 40 hours per week? The Field Guide does suggest that a person might be Scrum Master in two or three teams concurrently, which I agree is a reasonable solution if the company is large enough. Being a project-manager in my experience requires a distinct skill-set and personality-type, and I can see that a dedicated Scrum Master career (or at least that role for the length of a project) is a good idea if it is administratively possible.</p>

<h1 id="do-not-agree">Do Not Agree</h1>

<p>Things about Scrum in general, and the Field Guide in particular, that I just don’t like and would try to avoid when possible..</p>

<h2 id="assigning-tasks-to-sprints">Assigning Tasks to Sprints</h2>

<p>IMO, what does not make sense is “assigning tasks to a sprint” in advance, ie <em>planning</em> what tasks are going to be done. This just leads to unnecessary stress and arguments; as long as all team members are doing an honest day’s work then it seems simpler to just use the approach of “take items from the project backlog”.</p>

<p>Interestingly, older versions of <a href="https://scrumguides.org/">the offical Scrum guide</a> mentioned “sprint commitment”, but <a href="https://www.scrum.org/resources/commitment-vs-forecast">this concept was removed in 2011</a>. Instead, Scrum now talks about “forecasting” the set of tasks that will be completed in a sprint - better, but I’m still unclear about why even this is helpful. And sadly, task-tracking tools (particularly JIRA) don’t seem to support the concept of “forecasting” well, instead still suggesting “assignment”.</p>

<p>As noted earlier, the Field Guide strongly recommends against changing Scrum conventions. I’m certainly open to reasons why assigning tasks to sprints is a good idea, but I can only see one: being able to report at the start of each sprint what will be delivered at the end of it. Except that this is misleading, because <em>software development is unpredictable</em>. The damage this convention causes to team morale, on the other hand, is clear and obvious.</p>

<h2 id="forecasting-and-burn-down-charts">Forecasting and Burn-down Charts</h2>

<p>The topic of <a href="https://en.wikipedia.org/wiki/Burndown_chart">burndown charts</a> isn’t addressed in either the official Scrum guide, or in the Scrum Field Guide, but I have seen them used.</p>

<p>If (as suggested above) tasks are not assigned to a sprint, ie a sprint does not consist of “a fixed set of tasks in a fixed time”, but just “as much as possible in a fixed time”, then “per-sprint burndown charts” are irrelevant. And IMO they should die. In a fire. Attempting to put pressure on team members because an arbitrary graph isn’t going to reach zero at an arbitrarily-chosen date is pointless and demoralizing.</p>

<p>Per-project burndown charts might have some slight relevance, showing how long (at current performance, and in the knowledge that feature estimates are only very rough) it will take to reach any arbitrary point in the requirements-priority-list. However it is important to note that only the top items in a backlog will have been fully “refined”, with items further down in the priority list becoming progressively fuzzier and more poorly estimated. Team velocity is also very approximate. And in any agile project, the set of items in the backlog is expected to change. Therefore the utility of such charts is low. If a fixed delivery date for a fixed set of features is required, then it should be accepted that the waterfall method must be used - with the corresponding up-front design phase and appropriate formal requirement-change processes in place.</p>

<p>And of course any forecast will be misinterpreted by management (internal and customer), but there is no known remedy for that.</p>

<h2 id="strictly-following-a-predefined-scrum-process">Strictly Following a Predefined Scrum Process</h2>

<p>Agile development is about “people over processes”, self-empowerment, and feedback loops for processes as well as software. Forcing a process onto a team seems contradictory to the Agile principles.</p>

<p>Interestingly, the original Scrum guide simply states that if you adapt the documented process then you shouldn’t call it “Scrum”, which is fair enough. However some sources warn against deviating from “the approved path” at all - something that I would recommend doing wherever it suits.</p>

<h1 id="references-and-further-reading">References and Further Reading</h1>

<ul>
  <li>
<a href="https://scrumguides.org/">The official Scrum guide</a> - a remarkably short document; recommended reading!</li>
  <li>
<a href="https://www.youtube.com/watch?v=F42A3R28WMU">[video] Allan Holub: How we can correct the mistakes made with Agile (2020)</a> - some strong opinions about what Agile really is, and about the “agile industrial complex” which pushes pseudo-agile processes (including Scrum and SAFE).</li>
  <li><a href="https://holub.com/reading">Allan Holub’s Agile Essential Reading List</a></li>
  <li>
<a href="https://www.youtube.com/watch?v=fjeVFxL9MQA">[video] Dave Farley/Continuous delivery: Is AGILE Better Than KANBAN?</a> - an excellent guide to the purpose of agile development</li>
</ul>

<h1 id="footnotes">Footnotes</h1>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:3qns" role="doc-endnote">
      <p>What did you do yesterday? What will you do today? Are there any impediments in your way? <a href="#fnref:3qns" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

    </article>
  </div>
    
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'mineofinformation'; // mineofinformation (disqus site id)
      var disqus_pageid = '/programming/scrum-thoughts/'; // /relative/path/to/article/dir

      var disqus_config = function () {
        this.page.identifier = disqus_pageid;
        this.page.url = 'https://moi.vonos.net' + disqus_pageid;
      };
      (function() {
        var d = document, s = d.createElement('script');
        s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  



      </section>
    </div>
    <section id="footer">
      <p>Copyright &copy; 2025 - Simon Kitching</p>
    </section>
  </body>
</html>

