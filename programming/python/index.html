<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Mine of Information - Python Notes</title>
    <link rel="stylesheet" type="text/css" href="/assets/css/coderay.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/stylesheet.css">
    <link type="application/atom+xml" title="Mine of Information" rel="alternate" href="/atom.xml"> 

    <meta name="generator" content="nanoc 4.12.15"> 
    <meta name="author" content="Simon Kitching"> 
  </head>
  <body>
    <section id="header">
      <span class='title'>The Mine of Information</span> <span class='desc'>(Nuggets of Programming and Linux)</span>
    </section>
    <div id="main">
      <section id='navpane'>
        <section>
  <ul id="navicons">
      <li class="nav">
      <a href="/" title="Home"><img src="/assets/images/Home.png"></a>
      <a href="/archives/" title="Archives"><img src="/assets/images/Calendar.png"></a>
      <a href="/site/welcome" title="E-Mail"><img src="/assets/images/Envelope.png"></a>
      <a href="/atom.xml" title="Subscribe Feed"><img src="/assets/images/RSS.png"></a>
      </li>
  </ul>
</section>

<section>
  <h1>About</h1>
  <ul id="about">
    <li>
      <a href="/site/welcome">Welcome</a>
    </li>
  </ul>
</section>

<section>
<h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2023/12/monorepos/">Monorepos and Polyrepos</a>
      </li>
    
      <li class="post">
        <a href="/2023/12/httpapis/">HTTP APIs, REST APIs, and Others</a>
      </li>
    
      <li class="post">
        <a href="/2023/09/biden/">Biden on Democracy</a>
      </li>
    
      <li class="post">
        <a href="/2023/09/tech-breadth/">Maintaining Technical Depth</a>
      </li>
    
      <li class="post">
        <a href="/2023/08/vpns/">The Uselessness of Consumer VPNs</a>
      </li>
    
      <li class="post">
        <a href="/2023/06/microservices/">Some Aspects of Implementing Microservices..</a>
      </li>
    
      <li class="post">
        <a href="/2023/06/dtest-evolution-scrum-monad/">DDD, Architecture patterns, and More..</a>
      </li>
    
      <li class="post">
        <a href="/2023/05/testing/">Should Unit Tests Verify Requirements Only?</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Categories</h1>
  <ul id="categories">
    
      <li class="catlink">
        <a href='/category/Architecture/'>Architecture</a>
      </li>
    
      <li class="catlink">
        <a href='/category/BigData/'>BigData</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Cloud/'>Cloud</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Cryptography/'>Cryptography</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Git/'>Git</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Infrastructure/'>Infrastructure</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Java/'>Java</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Links/'>Links</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Linux/'>Linux</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Network/'>Network</a>
      </li>
    
      <li class="catlink">
        <a href='/category/OSGi/'>OSGi</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Off-topic/'>Off-topic</a>
      </li>
    
      <li class="catlink">
        <a href='/category/OpenWRT/'>OpenWRT</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Programming/'>Programming</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Security/'>Security</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Site/'>Site</a>
      </li>
    
  </ul>
</section>


      </section>
  
      <section id='content'>
        
  <div class='page'>
    <h1>Python Notes</h1>
    <aside>First published on: December 26, 2018</aside>
    
    <article>
    <p>Categories: <a href='/category/Programming/'>Programming</a></p>
      
<h1 id="overview">Overview</h1>

<p>Here are some notes I made while learning Python. It is a reasonably easy language to learn (at least the basics), but:</p>

<ul>
  <li>many books for novice programmers fail to cover the interesting cases, and</li>
  <li>as a Java/C/C++/Perl/Javascript/other programmer, I initially leapt to some incorrect assumptions and had to unlearn/relearn a few things.</li>
</ul>

<p>Without doubt, the best starting point for experienced developers is the official <a href="https://docs.python.org/3/tutorial/">Python Tutorial</a>. This gives a readable but rapid introduction to the core features of the language - not great for novice developers but perfect for those coming from other languages.</p>

<p>The official <a href="https://docs.python.org/3/reference/">Python Language Reference</a> comes in two parts - the core language, and the libraries. The core language part is reasonably readable (certainly compared to specifications for other languages), and the library reference is excellent. I recommend reading these too - yes, really. As an experienced developer, I got more out of these than the “Introduction to Python” books I tried.</p>

<p>The <a href="https://docs.python-guide.org/">Python Guide</a> is a site that is similar to this article in spirit - although I found some advice there out-of-date (or they are trying to also cater to users with older versions of Python).</p>

<p>Despite the quality of the official documentation:</p>

<ul>
  <li>There were a few things I felt could have been summarized more briefly;</li>
  <li>there were some things that were not clear to me at first, and</li>
  <li>there were things that I misunderstood (often due to assumptions based on other languages)</li>
</ul>

<p>This article addresses these three issues.</p>

<p>Interestingly, much of the tricky stuff appears to be related to Python’s object-oriented programming support (Python also supports procedural and functional programming).</p>

<p>This article discusses Python3 only; Python2 is now fairly close to dead (at last). It also assumes you are using some kind of Unix.</p>

<p>IMO, the best thing about Python is not the language, but its large standard library and the huge collection of third-party libraries available for it. This article does not look at any third-party libraries - although it does look at how such libraries are installed and found at runtime.</p>

<p>Note that object-oriented features are at the base of most Python, including such things as <em>modules</em> which are addressed before looking at Python classes and objects. It is just impossible to present things without forward references to concepts not yet explained. On the other hand, I expect you have read at least the official Python tutorial first, and so know roughly how Python classes work anyway.</p>

<p>I have written two additional articles on Python, covering features that are too complex to describe in this already-long article:</p>

<ul>
  <li><a href="/programming/python-pack">Packaging Python Code</a></li>
  <li>
<a href="/programming/python-async">Async Programming</a> (ie using keywords async/await and module asyncio)</li>
</ul>

<h1 id="why-python">Why Python?</h1>

<p>Here are some reasons why Python might be a good choice for a project:</p>

<ul>
  <li>is cross-platform</li>
  <li>can replace awk or shellscripts with a “real programming language” that is more readable and has more features (eg exceptions)</li>
  <li>includes a good standard library (maps, lists, etc) which things like shell does not</li>
  <li>has GUI libraries (unlike shell, etc)</li>
  <li>no compile cycle (C, C++, Java etc)</li>
  <li>has relatively dense code (ie is not verbose) while being very readable</li>
  <li>is a relatively small language (fewer built-in features to learn than some others)</li>
  <li>has a vast range of third-party libraries, and a good package-manager (pip) to install them with</li>
  <li>has a good and active community</li>
  <li>cpython has relatively easy bindings to native code (unlike shell etc)</li>
  <li>cpython can be embedded into applications</li>
  <li>cpython provides a REPL environment (interactive mode) for interactive code development</li>
  <li>and is completely open-source</li>
</ul>

<p>Here are some personal opinions on why Python might not be a good choice:</p>

<ul>
  <li>performance in single-threaded mode is not good (Python is slower than many other comparable languages)</li>
  <li>performance in multi-threaded mode is poor - in general, efficient use of multiple cores is obtained by starting multiple processes instead</li>
  <li>lack of static typing for developer support, documentation, and IDE autocomplete</li>
  <li>relatively easily decompiled (ie keeping an implementation secret is not effective)</li>
</ul>

<h1 id="basic-stuff">Basic Stuff</h1>

<p>Python has several implementations:</p>

<ul>
  <li>the standard interpreter CPython (so named because it is implemented in C)</li>
  <li>
<a href="https://en.wikipedia.org/wiki/PyPy">pypy</a> which is an interpreter combined with a <em>just-in-time tracing compiler</em> (so named because it is implemented in Python). Do not confuse pypy with <a href="https://pypi.org/">pypi</a> the Python package index!</li>
  <li>IronPython - Python 2.x for dot-net runtime (support for Python 3.x is in progress, not yet released)</li>
  <li>Jython - Python 2.x for the JVM runtime</li>
</ul>

<p>Python has a reasonably large standard library, and a large catalogue of third-party libraries available at <a href="https://pypi.org/">pypi.org</a>.</p>

<p>The <code>pip</code> package manager tool can download and install packages from the pypi.org catalog. Pip can download into specific <em>environments</em> (eg an environment per application) to avoid version-conflicts between applications on the same host. See later for more on <code>pip</code> and <code>venv</code>.</p>

<p>Some Python libraries are wrappers around native libraries. Such libraries might need to be installed manually (either with a native-code package manager such as apt, or from source-code) before the installed Python module actually works. Recently, <code>pip</code> and its file-format have been enhanced to support <em>wheel</em> bundles, which include precompiled binaries for multiple operating systems along with the Python code - if the publisher of the library has made the effort to build the libraries. Various library packaging techniques are examined <a href="/programming/python-pack">in a separate article</a>.</p>

<h1 id="peps">PEPs</h1>

<p>The Python Enhancement Process is how the language evolves - people write PEP documents suggesting changes/enhancements to the language which are then accepted or rejected. Many of the features in the Python language core, and in the standard libraries are officially defined in PEP documents rather than in a single central “official language specification”.</p>

<p>It is useful to know this, as searching for common Python problems on the internet often returns the advice “see PEP xyz”.</p>

<h1 id="naming-conventions">Naming Conventions</h1>

<p>The Python standard library is, for historical reasons, not completely consistent. The recommended practice for new code is:</p>

<ul>
  <li>mostly, use <code>lowercase_with_underscores</code>
</li>
  <li>constants should be <code>UPPERCASE_WITH_UNDERSCORES</code>
</li>
  <li>however classnames should use CamelCase (even though many classes in the standard library do not)</li>
  <li>and exceptions (which are classes) should use form <code>{SomeClassName}Error</code> (assuming they do represent errors) <sup id="fnref:exceptions" role="doc-noteref"><a href="#fn:exceptions" class="footnote" rel="footnote">1</a></sup>
</li>
</ul>

<h1 id="underscores">Underscores</h1>

<p>When a name has two leading underscores, and does not end with two underscores, then Python <em>mangles</em> the name into form <code>_{classname}__{originalname}</code> This ensures that there is never a “name collision” with an attribute defined in a subclass. Such names should obviously not be used for attributes which are intended to be part of the classes public behaviour - ie should only be applied to attributes used for internal purposes by methods on that class. As a side-effect, it makes access to such attributes slightly more complicated for external code - but the goal of mangling is <em>not</em> to provide “access control for attributes” like some object-oriented languages support.</p>

<p>Names that have two leading and two trailing underscores are treated specially by the Python environment; these are sometimes called “dunder names”. User code is not supposed to define new names of this form; user code may <em>override</em> methods with such names (when such support is documented). Sometimes it is acceptable to read or write such names (see documentation) - although in most cases, Python provides a wrapper function to access attributes with such names (eg instead of accessing <code>obj.__dict__</code>, use <code>vars(obj)</code>).</p>

<p>A name with one leading underscore is an indication that the name is intended to be <em>private to the module</em>; a “<code>from module import *</code>” will not import such names. However it is accessible via explicit use of the module name (“weak privacy”).</p>

<h1 id="programming-styles">Programming Styles</h1>

<p>Python supports:</p>

<ul>
  <li>procedural programming</li>
  <li>functional programming</li>
  <li>object-oriented programming</li>
</ul>

<p>In my opinion, there are strengths and weaknesses in Pythons support for each of these styles.</p>

<p>Procedural programming requires support for functions that take and return data-structures, and a library with mutable collections of various types. All the basics are supported in Python. However IMO the procedural programming support is tricky without proper data-structure types; Python really only offers <code>dict</code> (a key/value map) or “named tuples”.</p>

<p>Functional programming requires support for closures and functions as first-class entities. Both of these are present. The standard library modules ‘functools’, ‘itertools’ and ‘operator’ also provide some functional-related helpers. However functional programming also benefits from libraries with immutable collections, monads, and various other helpers; Python’s standard library offers little support here. The Python community is also largely object-oriented rather than functional, so searching for help on functional programming in Python is likely to be difficult.</p>

<p>Object-oriented programming is well supported in Python - multiple inheritance is there, and “interfaces” via the <code>abstract base class</code> standard library module. I’m still struggling with the idea of non-typed object oriented programming - to the point where a class cannot declare the members that its instances have, and although interfaces exist, no user of an object ever tests the type of a parameter. And this dynamic behaviour means that performance of object-oriented code is extremely poor compared to typed languages.</p>

<p>The dynamic-typed nature of Python just doesn’t feel right to me, coming from a typed programming language background. For small hundred-line scripts, ok. But my interest is in large-scale projects (multiple developers over multiple months to dozens of developers over years) and I fail to see how such applications can be successfully created without the support of a type-system. On the other hand, there <em>are</em> successful Python projects of this scale. The Python tutorial itself states that the primary reasons to use Python include being able to do what shell-scripts, awk, etc. can do - but with the power of a full programming language when needed.</p>

<h1 id="parsing-source-code-files">Parsing Source Code Files</h1>

<p>When a Python file is first loaded, it is parsed and converted to bytecode format. This is a relatively simple process in which keywords, operators and literals are recognised and an abstract-syntax-tree (or similar) is built for the source. A SyntaxError is reported if the code is clearly not valid (syntax tree cannot be built). However functions, classes, etc are not registered in any namespace in this phase.</p>

<p>Once the file has been converted to bytecode, that bytecode is immediately executed from start to finish. A Python source-code file should thus be seen as a sequence of executable statements. This is quite different from compiled languages, where source-code is “passive input to the compiler”.</p>

<p>One effect of this approach is that Python can be used similarly to shell-scripts.</p>

<p>Another effect in more complex applications is that Python code can affect what in other languages is the “compilation” phase. As examples:</p>

<ul>
  <li>Python code within a file can generate Python classes at runtime, which can then be referenced later in the file.</li>
  <li>A Python module can dynamically determine, during loading, which other modules to import.</li>
</ul>

<p>However in most cases, the executable statements in a Python file simply create variables, functions (function-objects), and types (class-objects), and register them with the enclosing module’s namespace.</p>

<p>For <code>class</code> statements at top-level within a module, the body of the class is executed when the module is loaded (though in a temporary namespace; see classes later). Usually, the code in the class body simply creates function objects (which are later attached to the class as methods), or objects of other kinds (which are later attached to the class as class members).</p>

<p>For <code>def</code> statements at top-level within a module (or top-level within a class-body), the body of the function is (obviously) not executed; instead a function object is created which points at the block of associated bytecode. That bytecode is only evaluated when the function is called. Importantly (and not so obviously), class and function definitions (and even import statements) are allowed within the body of a function, but have no effect (are not evaluated at all) until the containing function is executed.</p>

<h1 id="bytecode-cacheing">Bytecode Cacheing</h1>

<p>By default, the CPython interpreter saves the bytecode for each Python file in a file named <code>{basefilename}.pyc</code> (normal) or <code>{basefilename}.pyo</code> (optimised). When a Python file is loaded as a module (see later), and the cached bytecode file is newer than the corresponding source, then the bytcode is simply loaded from the cache-file for performance.</p>

<p>These bytecode files are usually stored in a directory named <code>__pycache__</code> in a subdir of the file that was “compiled”. Python 3.8 has a new feature which allows an environment-file to specify the location of the cache-directory. The bytecode of the “main file” specified on the Python interpreter commandline is never cached - only modules that such a file loads.</p>

<p>Files in the Python standard library are also compiled to bytecode and cached. However this compilation process is normally triggered during install of the Python environment, rather than “on demand”, because normal users usually do not have write access to the <code>__pycache__</code> directories within the Python installation directory.</p>

<p>Cacheing of bytecode can be suppressed if desired.</p>

<p>Python code can actually be distributed as <em>just</em> bytecode files, without the source-code, and the CPython interpreter will happily run it. However this is not particularly useful, as bytecode:</p>

<ul>
  <li>is not guaranteed to be portable between different Python interpreters, and</li>
  <li>is not guaranteed to be backwards-compatible between releases</li>
</ul>

<h1 id="modules">Modules</h1>

<p>The contents of each source-code file is represented in memory as a separate <em>module</em> object.  The Python interpreter keeps a global map of all modules that have been loaded (in variable <code>sys.modules</code>), ie a table of <code>module-name -&gt; module-object</code>.</p>

<p>One of the standard attributes of a module object is <code>__name__</code>. When the file has been executed directly from the commandline (eg via <code>python3 foo.py</code>) then a new module object is created with module-name of <code>__main__</code> (regardless of what the filename is). When the file has been indirectly loaded via an “import” statement in some other file, then the module object created for that file has property <code>__name__</code> set to the filename (without suffix).</p>

<p>All declarations (variables, functions, and classes) within a file are stored in the associated module object. Or in other words, each assignment-statement, function-definition, or class-definition which was executed as the module’s contents were processed caused entries to be added to the module object.</p>

<p>An import-statement at the global level within a module is also an executable statement, and is executed when the module is loaded. First the interpreter-global map is checked; the file is parsed if (and only if) the module is not already present. New entries in the namespace of the importing-module are then created which point to the specified (imported) objects from the specified module.</p>

<p>The local filesystems which are searched to find the sourcecode for a module is held in variable <code>sys.path</code> - and any module can change this, thus affecting where later imports are looked for. It initially includes the directory in which the “main” Python file is stored, the <code>PYTHONPATH</code> environment variable, and a constant path built in to the Python interpreter.</p>

<p>A string occurring immediately after the start of a file becomes the “docstring” for the module (and is stored in attribute <code>__doc__</code>).</p>

<p>Statement “import X” loads X if not already loaded, and adds a reference to module X to the local namespace. Statement “import X as Y” does the same, but the reference name in the local namespace is “Y”. Statement “from X import A, B” loads X if not already loaded, then adds references <code>A -&gt; X.A</code> and <code>B -&gt; X.B</code> into the local namespace - but does not add X itself.</p>

<p>Each module object has several attributes:</p>

<ul>
  <li>
<code>__name__</code>: string (mentioned above)</li>
  <li>
<code>__all__</code> : list(str) (controls imports)</li>
  <li>
<code>__author__</code> and <code>__version__</code>: strings - for documentation</li>
</ul>

<p>These can be read (and sometimes assigned-to) from within the module.</p>

<p>When “<code>from X import *</code>” is executed, then all names in the module’s <code>__all__</code> variable are added (or all names if that list is empty). As wildcard-imports are not recommended in production code, that isn’t very significant - but some IDEs may prefer to recommend (autocomplete etc) names from <code>__all__</code> if it is defined.</p>

<p>An import-statement can occur in places other than at the top of a file. When it occurs within a function-definition (def-statement), then the import and namespace-updates occur when (and each time) the function is <em>invoked</em>. As modules are cached globally, that means that the actual import (reading of referenced source) will occur on the first call to the function (assuming nothing has loaded it earlier). Thereafter, just the importing of names into the local namespace (the function-namespace in this case) is done each time.</p>

<p>The <code>importlib</code> standard library module can be used for more control over module-loading (eg dynamically choosing the module name).</p>

<p>The function <code>dir()</code> effectively lists the attributes of the current module.</p>

<p>Because modules add names to the namespace of the importing module, there is the possibility of naming-conflicts. The <code>import</code> feature therefore provides various ways of renaming things as they are imported (ie the name under which something is registered in the importing namespace might be different to the default name).</p>

<p>Modules do not really form a hierarchy; a module may contain references to other modules in its namespace but the modules themselves are really independent entities (“peers”).</p>

<p>Standard library module <a href="https://docs.python.org/3/library/sysconfig.html">sysconfig</a> holds various interesting host-specific settings, including the location of the standard library.</p>

<p>There are <a href="https://www.python.org/dev/peps/pep-0302/">some hooks</a> for customising how “import” actually works - although the need to do so is presumably extremely rare.</p>

<h1 id="packages">Packages</h1>

<p>A package is a group of modules (ie group of source-code files) that “belong together”, all stored in a filesystem directory.</p>

<p>A package can include a file named <code>__init__.py</code><sup id="fnref:initopt" role="doc-noteref"><a href="#fn:initopt" class="footnote" rel="footnote">2</a></sup>. This file is executed when:</p>

<ul>
  <li>code imports the package, or</li>
  <li>code imports any module in the package</li>
</ul>

<p>The init-file can contain any arbitrary code; it is in effect a standard module, except that it is “auto-loaded” when any module in the package is loaded.</p>

<p>One special case does exist: when <code>__init__.py</code> defines variable <code>__all__</code> then this is not interpreted as a list of importable names in the local namespace (as for normal modules) but instead a list of importable modules in the package. Thus <code>from package import *</code> will cause all modules referenced by the all-list to be loaded.</p>

<p>A package can also include a file named <code>__main__.py</code> in which case the package can be “run” in the same way as a module (<code>python -m {packagename}</code>); see later.</p>

<p>Note that the word “package” is sometimes used in another sense: a bundle of software that can be downloaded and installed.</p>

<h1 id="running-python-code">Running Python Code</h1>

<p>Python code can be executed in several ways:</p>

<ul>
  <li><code>python {filename.py} ...</code></li>
  <li><code>python -m {modulename} ...</code></li>
  <li><code>python -m {packagename} ...</code></li>
  <li><code>python {zipfile} ...</code></li>
  <li>or as an executable script</li>
</ul>

<p>The first option (explicitly specifying the filename) simply loads that file, and passes it to the Python interpreter. The directory from which the specified file was loaded is added to the module-search-path, ie any “import” statements executed during the program will look for modules relative to that directory first, before looking in the standard locations.</p>

<p>The second option looks for a file named <code>modulename.py</code> in the current module search-path - usually current-dir, site-packages, std-library.</p>

<p>When Python finds that the name used with the “-m” option is a <em>Python package</em> rather than a <em>Python module</em>, then it executes the file <code>__main__.py</code> from that package (see section named Packages).</p>

<p>When a zipfile is passed to the Python interpreter, Python treats it as a package, ie looks for a file named <code>__main__.py</code> in the root directory of that zipfile.</p>

<p>As usual in Unix, a file which starts with <code>#!/path/to/interpreter</code> and is marked as “executable” can be run just like a binary application. As the path to the Python interpreter can differ between operating systems, it may be better to set the first line instead to <code>#!/bin/env python3</code> which will find the command using <code>$PATH</code>.</p>

<p>Rather oddly, it is also possible to create a file which is a zipfile appended to an executable script.</p>

<p>Files named <code>{packagename}.pth</code> can be added in any of the “site-package” directories in the Python module search path; the file contents are then added to <code>sys.path</code>. Similarly, a file <code>sitecustomize.py</code> can be added to any directory in the searchpath, and it will be evaluated before any other imports (and so can modify <code>sys.path</code>). See <a href="https://docs.python.org/3.7/library/site.html">the docs for site.py</a> for more details.</p>

<h1 id="calling-native-code">Calling Native Code</h1>

<p>Python code can call into native (non-Python) code in two ways:</p>

<ul>
  <li>A Python module can be completely implemented in C (or any language with a C-compatible binary API) and compiled into an object-file. The module can then be “imported” by using code just like pure Python modules can be imported.</li>
  <li>Pure Python code can dynamically load an (unmodified) native shared library, and then call into it.</li>
</ul>

<p>A module implemented in C (or other language) must use Python-specific calls internally to be able to correctly accept Python input parameters, and correctly deal with them. A number of standard libraries are implemented this way.</p>

<p>Python code which calls into a normal native shared library must instead map variables into forms that the called code can understand before invoking the underlying code. For example, when a function expects an int and a c struct, then Python code must map a Python int object into the equivalent form, and build the expected C struct as a byte-array before invoking the target function. The necessary code is verbose and ugly but this approach is often used.</p>

<p>The <a href="http://www.swig.org">SWIG project</a> provides tools to generate Python wrappers for arbitrary C libraries, as an alternative to hand-writing such logic.</p>

<p>It is common for Python to be used as “high level glue” between logic implemented in C libraries which do heavy numerical processing. The <code>NumPy</code> mathematical library is a very widely-used example; mathematical computation is done in native code and Python is used to “orchestrate” the calls. This gives a combination of performance at low-level and readability at high-level.</p>

<h1 id="namespaces">Namespaces</h1>

<p>Whenever code is executed, there is always an implicit “current namespace” (a mapping of variable-names to variable-values).</p>

<p>When Python starts loading a module for the first time, it creates a namespace. All code at the “top level” within the file for a module uses the module-level namespace to find variables or add new ones. A module-namespace is also called a “global” namespace - though it is not global-for-all-modules, just per-module.</p>

<p>When Python invokes a function, it creates a new namespace with the current namespace as its “parent” and makes the new namespace the default. Any function parameters are then added to the new namespace before the code associated with the function is executed. On return from the function, that newly-created namespace is discarded.  Functions therefore effectively have <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)">dynamic scoping</a>, ie the name-lookup-chain depends on the application’s call-flow rather than the lexical structure of the program. Most programming languages use lexical scoping rather than dynamic scoping; however given that nested functions cannot be directly invoked (they don’t actually exist except as raw bytecode until the nested function is invoked), the difference is hard to observe in practice.</p>

<p>The root namespace of any chain of namespaces is the <code>builtins</code> namespace that holds various core functions and variables, and references to auto-loaded modules from the standard library. Functions like <code>print</code> and types like <code>int</code> are defined as entries (varname-to-value mappings) in the <code>builtins</code> namespace.</p>

<h1 id="globals-and-nonlocals">Globals and Nonlocals</h1>

<p>Variables are just entries in a namespace (varname mapping to value).  Python uses a consistent pattern for looking up namespaces, and modifying them:</p>

<ul>
  <li>a read looks first in the local (current) namespace; if not found then look in the parent of that namespace, and so on.</li>
  <li>a write always writes directly to the local namespace (creates a binding of that name in the local namespace, ie add a mapping from varname to value)</li>
</ul>

<p>This means that constants (including method-names) can be effectively defined at module-level; from there they are readable by all code that needs them.</p>

<p>However if code using a child namespace tries to assign to that name, a “shadowing entry” is created in that child (local) namespace. In particular, this means that when a variable is declared at module scope, and code in a function tries to assign to it, then the assignment creates a value only in the function scope (namespace) - and no change occurs in the module.</p>

<p>Within any scope (eg within a function), the keyword <code>global</code> can be used to modify this behaviour; the line of code “<code>global foo</code>” ensures that any assignment to <code>foo</code> in the local scope actually modifies the namespace of the enclosing module (effectively updating <code>self.__module__[foo]</code>). This occurs regardless of how many layers of namespaces lie between the current namespace and the module namespace.</p>

<p>WARNING: if a global variable is of a <em>mutable</em> type, then its state can be changed via read-and-call-a-mutable-method, without needing to <em>rebind</em> the variable itself. A <code>global</code> declaration is thus not needed for such changes to be visible outside of the namespace in which the change was made.</p>

<p>The keyword <code>nonlocal</code> does something similar; it causes whatever existing “parent namespace” holds the variable of that name to be updated. Or, as the original PEP states: “<code>nonlocal</code> prevents the name from becoming local” (even when being assigned to).</p>

<h1 id="nested-functions">Nested Functions</h1>

<p>Python supports functions defined within functions, eg:</p>

<pre><code>def outer(lname, fname):
  print("lname=", lname)
  def inner(fname):
    print("full name: {}, {}".format(lname, fname))

  inner(fname)

outer("smith", "joe")
</code></pre>

<p>When a module with this content is loaded:</p>

<ul>
  <li>executing the “def” line causes an entry named “outer” to be created in the module namespace which points to a function-object that has a block of bytecode.</li>
  <li>executing the last line of the above example actually invokes the function-object bound to name “outer” (ie calls function outer).</li>
</ul>

<p>Executing outer first causes a new namespace to be created, with two initial entries: <code>lname</code> and <code>fname</code>. The parent of this namespace is the module namespace.</p>

<p>Then the bytecode associated with function outer is executed:</p>

<ul>
  <li>An object named <code>print</code> is looked up in the current namespace (not found), its parent namespace (the module, not found), and finally the <code>builtins</code> namespace (found). The resulting function-object is then invoked.</li>
  <li>A new function object is created which points to a block of bytecode, and this object is registered in the current namespace under name <code>inner</code>.</li>
  <li>The object named <code>inner</code> is looked up in the current namespace (found) and invoked. This causes a new namespace to be created, with an initial entry <code>fname</code>, etc.</li>
</ul>

<p>Note that the function <code>inner</code> only exists <em>temporarily</em>. Each time outer’s bytecode is executed, the “def” bytecode causes a new function-object to be created whose <code>code</code> attribute points to the bytecode for function <code>inner</code>. That new function-object contains a reference to the “enclosing namespace” (and is thus a closure). That namespace will be a different object on each call to <code>outer</code>.  This process is moderately fast - the ascii source-code does not need to be parsed, only the bytecode needs to be executed.</p>

<h1 id="protocols-and-duck-typing">Protocols and Duck Typing</h1>

<p>In a language like Java, we might define <code>interface Foo {..some methods}</code>, and then define a method <code>doSomething</code> which accepts an instance of type <code>Foo</code>.</p>

<p>However this has the disadvantage that we might well have an object that has the necessary methods, but does not have type <code>Foo</code> as an ancestor - and so cannot be passed to that target method.</p>

<p>Python supports something called “duck typing” - if a function expects a specific parameter to provide a method with a specific signature, then it should just invoke that method without caring about what type the object is. When the object has such a method, fine. When not, an error is reported. Simple.</p>

<p>However this raises the question: how does the caller of a function know what methods are expected on the parameters?</p>

<p>Python uses the word “Protocol” to describe the situation where interfaces meet duck-typing. A protocol is effectively an informal text document that provides exactly the same information that the Java interface above does - what methods need to exist, what parameters they should take, and (perhaps) what logical behaviour is expected. Any Python object that is consistent with this informal text document is said to <em>implement the protocol</em>. A function then just declares what <em>protocols</em> specific parameters are expected to support.</p>

<p>In short, protocols are documentation-based interfaces that are not enforced by the compiler by way of types. This gives flexibility and removes “boilerplate” code - at the price of less compile-time support for developers.</p>

<p>See also the section on Abstract Base Classes below.</p>

<h1 id="annotations">Annotations</h1>

<p>Annotations can be added to function params and return-values:</p>

<pre><code>def f(x: 'my x', y: 'my y') -&gt; 'my return'
</code></pre>

<p>The value following the colon or <code>-&gt;</code> is an object of any type - including a callable-object. In the above example, the objects used are just strings.</p>

<p>Annotations on function parameters and return-values were added in Python 3.5. Python 3.6 added support for annotations on variable-declarations.</p>

<p>Python itself does nothing with these values except store them in the function-object, for use by other code (in an object attribute called <code>__annotations__</code>).</p>

<p>This feature can be used for many different purposes, including aspect-oriented programming, or quality-assurance, or documentation.  However the standard use for these annotations is <em>type-hinting</em>; when this is not the case then the file (module) should explicitly mark itself with a comment of form “<code># type: ignore</code>” or use one of the other approved mechanisms (see PEP 484).</p>

<p>Type hinting is when the object following the colon represents a type (ie is a reference to a class). Standard-library classes such as <code>int</code> and <code>str</code> are obvious candidates. The <code>Mypy</code> tool is a static-typechecker that scans Python programs and displays apparently inconsistent code. Other tools also exist which take advantage of type-hints. The <code>@dataclass</code> annotation added to the Python 3.7 standard library (see later) depends on <em>type hinting</em>.</p>

<p>Because <code>def</code> statements are actually <em>code that is executed</em>, the annotation can be an <em>expression</em> (including a function-call) that returns the annotation value. The expression is evaluated when the function-object representing the function is built, not each time the resulting function-object is invoked.</p>

<p>The Python standard library includes a module <code>typing</code> which allows syntax like <code>Sequence[int]</code> - which is actually just an alias for <code>Sequence</code> as Python itself is not typed. The typing module supports using the more expressive declaration in source-code - in fact, it also supports “generics”, ie can define collections of other types - with covariant/contravariant constraints. None of this is validated at runtime.</p>

<p>Note that Java annotations use an “<code>@Name</code>” syntax and thus look superficially like Python decorators (see later); however they are really more similar to Python annotations - passive data that the compiler attaches to code, for use by other code (static external tools or runtime internal code-transformers).</p>

<h1 id="descriptors">Descriptors</h1>

<p>When looking up an attribute on an object, the Python base class <code>object</code> (the ancestor of every Python object) has some <a href="https://docs.python.org/3/howto/descriptor.html">special code</a> to support <em>descriptors</em>.</p>

<p>A descriptor is any object that supports the <em>descriptor protocol</em> by <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors">implementing</a> one or more of the following methods:</p>

<ul>
  <li>“<code>__get__(self, obj)</code>”</li>
  <li>“<code>__set__(self, obj, value)</code>”</li>
  <li>“<code>__delete__(self, obj)</code>”</li>
</ul>

<p>Storing an object that supports the descriptor protocol as a class attribute allows user code to write “obj.attr” as if it were accessing a simple data value, while Python internally invokes the associated getter or setter function. This feature can also be seen as allowing “virtual attributes” on a class, backed by functions.</p>

<p>When code invokes <code>x = someobj.someattr</code> then that read-operation ends up within the base object class. The object class searches for the attribute, then (assuming it is found) it is checked to see if it has a get-method from the <em>descriptor protocol</em>; if so then the getter method is invoked, otherwise the attribute is returned directly.</p>

<p>Similarly, when code invokes <code>someobj.someattr=val</code> then the base object class searches for an existing attribute (as if a read was being done), and (assuming it is found) checks whether the target of the assignment (someattr) has a set-method from the <em>descriptor protocol</em>; if so then the setter method is invoked otherwise the local namespace is updated to map someattr to the new value.</p>

<p>Note that it was described earlier how <em>reads</em> can reference mappings from ancestor namespaces, but <em>writes</em>  are always done in the local namespace. Writing an attribute that is a Descriptor is subtly different; the write will be done <em>via</em> the setter on the descriptor instance even when it was found in an ancestor namespace. However in practice, descriptor setters will almost always actually store the data in the “self” object (ie the local namespace) anyway - after validation or whatever else the setter needs to do.</p>

<p>When a decorator provides <code>set</code> and <code>delete</code> methods, and is stored as an attribute on a class, then it is impossible to later replace that decorator - any attempt to delete or override the attribute will instead be delegated to the decorator itself!</p>

<p>A decorator is particularly useful when the class is already in use, and what used to be a plain attribute now needs associated logic on get or set; the approach means that such logic can be added without needing to change existing code.</p>

<p>Because decorators look like simple attribute-access, it is recommended that the functions also behave similarly to attribute-access (to not surprise callers), ie:</p>

<ul>
  <li>be side-effect-free (ie not change application state)</li>
  <li>be relatively fast</li>
</ul>

<p>IMO, descriptors are somewhat of a hack - they just don’t feel very elegant. However in practice they work, and are widely used - in user code most commonly via the <code>@property</code> decorator (see below).</p>

<p>Interestingly, <em>all</em> methods on a class are actually descriptors; when <code>someobj.somemethod()</code> is invoked, “somemethod” is usually an attribute on a parent class which implements the descriptor protocol.  The get-method returns an object which is the underlying function with the first “self” parameter appropriately bound (in functional language, partial application has been performed). Thus <code>obj.method(1)</code> is actually:</p>

<ul>
  <li>find attribute method - which will be a descriptor object</li>
  <li>invoke <code>descriptor.__get__</code> - which returns a function-object where the first parameter is bound to <code>obj</code>
</li>
  <li>invoke <code>fnobj(1)</code> - which delegates to the original function with two args: <code>(obj, 1)</code>.</li>
</ul>

<p>See later for more information on classes and the process that constructs them.</p>

<p>See also:</p>

<ul>
  <li><a href="https://docs.python.org/3/howto/descriptor.html">https://docs.python.org/3/howto/descriptor.html</a></li>
  <li><a href="https://www.smallsurething.com/python-descriptors-made-simple/">https://www.smallsurething.com/python-descriptors-made-simple/</a></li>
</ul>

<h1 id="decorators">Decorators</h1>

<p>The syntax <code>@somecallable</code> can be applied to any declaration (method or class). After the referenced object has been created, the Python interpreter then passes the created object to the specified function, and stores the returned value (in the class or module namespace) rather than the original one.</p>

<p>This very generic tool is called a <a href="https://realpython.com/primer-on-python-decorators/">decorator</a> and can be used for a wide range of code-transformations.</p>

<p>Decorator <code>@property</code> is probably the most common decorator from the standard library; it is applied to a getter function on a class and replaces the function-object with an object that implements the <em>decorator protocol</em> (see above) and delegates <em>get</em> operations to the original function.  A somewhat odd syntax can be used to similarly delegate set (or delete) operations. The result is that all instances of the class appear to have a specific data attribute (“obj.attr”) but this is in fact implemented via functions. This is also sometimes called “virtual attributes”, because what looks like a simple data-value stored on a class is actually produced by a function when read, and processed by a function when written.</p>

<p>Decorators <code>@classmethod</code> and <code>@staticmethod</code> are also available for use on functions declared within classes.  As noted earlier, functions declared within a class body are usually transformed into descriptor objects during class initialization; the classmethod/staticmethod decorators immediately wrap functions in descriptors, providing their own logic and blocking the default transformation at the same time.</p>

<ul>
  <li>
<code>@staticmethod</code> wraps the target method in a descriptor that basically does nothing (except return the function from its get method); the primary point is to prevent creation of the usual descriptor which binds “self”.</li>
  <li>
<code>@classmethod</code> wraps the target method in a descriptor whose get-method returns the target function with the first parameter bound to <code>self.__class__</code>.</li>
</ul>

<p>A static method is effectively the same as invoking a module-level function, ie <code>Foo.staticmethod(args)</code> is equivalent to <code>staticmethod(args)</code>. So why would you want one? Well, primarily so that the method is easily available/accessible when you have imported type Foo, but potentially nothing else. It can also be invoked via an instance, ie <code>foo.staticmethod(args)</code> and is therefore available even if you just have an object without an explicit type.</p>

<p>Decorators <code>property</code>, <code>staticmethod</code> and <code>classmethod</code> are also available as plain functions. A class body is executed at module load-time, so calling these functions is just as easy as applying a decorator (though perhaps not quite as readable - depending on your tastes).</p>

<p>Decorator <a href="https://realpython.com/python-data-classes/">@dataclass</a> was added in Python 3.7. It is applied to <em>classes</em> not to <em>methods</em>, and provides:</p>

<ul>
  <li>an implicit <code>@property</code> annotation with backing hidden attribute for each typehint-annotation on the class (ie dataclasses rely on the variable-annotation support introduced in Python 3.6)</li>
  <li>a bunch of standard methods (equals, lessthan, etc) that use the above properties</li>
</ul>

<p>An example dataclass (from the <a href="https://docs.python.org/3/library/dataclasses.html">official docs</a>):</p>

<pre><code>@dataclass
class InventoryItem:
    '''Class for keeping track of an item in inventory.'''
    name: str
    unit_price: float
    quantity_on_hand: int = 0

    def total_cost(self) -&gt; float:
        return self.unit_price * self.quantity_on_hand
</code></pre>

<h1 id="callables">Callables</h1>

<p>Any object with method <code>__call__</code> can be invoked via syntax <code>obj(params)</code>.</p>

<p>Python represents all standard callable objects (functions, lambas) as objects of type <code>collections.abc.Callable</code>, but that type is not absolutely required to <em>invoke</em> an object.</p>

<p>The two standard ways of producing a callable object are:</p>

<ul>
  <li>via <code>def fn(..)</code>
</li>
  <li>via <code>lamba x:..</code>
</li>
</ul>

<p>A <code>def</code> creates an object:</p>

<ul>
  <li>whose <code>__name__</code> attribute is the function-name used in the declaration</li>
  <li>whose <code>__module__</code> attribute is also set appropriately</li>
  <li>which has a docstring in attribute <code>__doc__</code> if one is defined</li>
</ul>

<p>A lambda-expression also produces a callable object, but the above attributes are not set - and the body of a lambda is limited to a single expression.</p>

<h1 id="closures">Closures</h1>

<p>Python supports closures; when a callable object is created at runtime from a lambda or a “nested def”, then the object “captures” variables from the enclosing scope.</p>

<p>Example:</p>

<pre><code>class destructable:
    """A class that creates objects which print a message when their refcount drops to zero"""

    def __init__(self, name):
        self.name = name

    def __del__(self):
        print("destroying {}".format(self.name))

def mkclosure(d):
    def closure(x): 
	"""A callable object that captures a reference to object d"""
        print("x={}, d={}".format(x, d.name))

    return closure

# create some objects that report when their refcount drops to zero
d1 = destructable("d1")
d2 = destructable("d2")

# create an object which holds a reference to d2
fn = mkclosure(d2)

# show that the closure works
fn(12);

# remove references to the following objects from the current (module) namespace
print("removing d1 and d2 from module namespace..")
del d1  # refcount drops to zero, so destructor is called
del d2  # refcount does not drop to zero because closure "fn" holds a reference to it

# show that the closure still works, even though d2 is no longer accessible from this scope
fn(13)

# delete the closure, at which point the refcount for d2 drops to zero and its destructor is called..
print("deleting closure..")
del fn

print("done")
</code></pre>

<p>and the output is:</p>

<pre><code>x=12, d=d2
removing d1 and d2 from module namespace..
destroying d1
x=13, d=d2
deleting closure..
destroying d2
done
</code></pre>

<p>The above example assumes CPython is being used, which uses refcounting rather than mark-and-sweep garbage collection, and thus destructors are called immediately. The concept of closures also works in other Python implementations, but the output might not show so clearly how things work, due to delayed invocation of the destructor (method <code>__del__</code>).</p>

<h1 id="exceptions">Exceptions</h1>

<p>Python’s support for exceptions is pretty standard - very much like other languages. Exceptions should be objects, and catch-expressions select specific exception-types using the type hierarchy.</p>

<p>Exception handling is also similar to other languages; Python’s try/except/finally is equivalent to Java’s try/catch/finally.</p>

<p>Somewhat unusually, Python’s standard libraries often use exceptions to implement flow-control, eg an iterator object indicates “no more data available” by throwing an exception.</p>

<p>It is considered <em>good Python programming style</em> to follow the EAFP principle - “easier to ask forgiveness than permission”. This means that it is preferable to perform an action that <em>should succeed</em> and catch a resulting exception if a problem occurred, than to <em>check in advance</em> whether the operation would succeed (LBYL - “look before you leap”).</p>

<h1 id="tuples">Tuples</h1>

<p>Python tuples are identical to those found in many other languages - a fixed-length immutable sequence of references to other objects. Elements are accessed by index-number, or by using 
“tuple unpacking” (aka “destructuring assignment”) like <code>(a, b, c) = (1, 2, 3)</code> which assigns the different components of the tuple <code>(1, 2, 3)</code> to different variables.</p>

<p>They are only mentioned here briefly as the primary alternative to classes, which are discussed below.</p>

<p>Python also provides “named tuples” - basically a mix of tuples and classes; these are discussed later.</p>

<h1 id="the-dict-type">The Dict Type</h1>

<p>A dict provides a mapping of key to value. Python refers to any such class as a “Mapping type”, and dict is the standard implementation.</p>

<p>Objects used as keys of a dict must be “hashable” and immutable; the dict class verifies these properties. A dict is therefore a constrained kind of mapping.</p>

<p>This is implemented as a class (naturally), where an attribute in the class dict is the “user dict” in which data is stored via syntax like <code>mydict["foo"] = bar</code>.</p>

<p>Because the dict is so widely used in Python, its implementation is actually in native C code.</p>

<p>Python classes often use a dict-like structure to store custom (non-builtin) attributes - and even uses the special attribute name <code>__dict__</code> for this. However IMO it is better to think of the class implementaton as something separate from general dicts.</p>

<h1 id="classes-and-instances">Classes and Instances</h1>

<h2 id="all-objects">All Objects</h2>

<p>Every value in Python is an <em>object</em>. In CPython, every object is represented by a native (non-Python) in-memory structure that contains:</p>

<ul>
  <li>a reference count</li>
  <li>a native field <code>__class__</code> which holds a reference to the object which represents the type of the object</li>
  <li>zero or more additional native fields that depend upon the object type</li>
</ul>

<p>These “native fields” are simply entries in a C “struct” declaration (for CPython at least). Class objects have different “native fields” in the in-memory representation than instances of that class, function objects have their own set of custom fields, etc. At the Python level, some native fields can be accessed from Python - in which case they have names with two leading and trailing underscores. See <a href="https://docs.python.org/3/reference/datamodel.html">here</a> for the full set of such fields.</p>

<p>Complex objects often have a native field named <code>__dict__</code> which is a (key, value) mapping, used to store non-builtin (ie non-native) methods and attributes.</p>

<h2 id="class-objects">Class Objects</h2>

<p>A class is an object which is “a factory for instances”. A class can also be used as a kind of mini-module, ie a namespace.</p>

<p>Python documentation often uses the term “type object” for what I call “class object”; it is the same thing - an in-memory structure that doesn’t itself represent user data, but instead represents a <em>type</em> associated with objects that do store such data.</p>

<p>It may be helpful to think of a class-object as having multiple separate roles:</p>

<ul>
  <li>holding a reference to a “shared parent namespace” (mapping of <code>name -&gt; value</code> where the values might be constants, variables, or method-descriptors)</li>
  <li>holding a reference to a set of <em>base classes</em> that provide additional “shared parent namespaces”</li>
  <li>being a factory that creates new objects which use that shared parent namespace - and applies common “init logic” to each object</li>
  <li>being a “type tag” that can be used in “isinstance” calls at runtime to identify all objects created via the class</li>
</ul>

<p>When a declaration “<code>class SomeClass(SomeAncestor, metaclass=SomeMetaClass)</code>” is executed in a source-code file, then logically:</p>

<ul>
  <li>a new (temporary) namespace is created, and made the default namespace</li>
  <li>the body of the class is executed (as a sequence of statements), adding various objects to the temporary namespace</li>
  <li>method <code>__new__(...)</code> is invoked on the metaclass, passing the temporary namespace as one of the parameters</li>
</ul>

<p>The metaclass then allocates a suitable in-memory structure for the kind of object being created (ie with the appropriate “native fields”). It then initialises those native fields from the data in the (temporary) namespace, and if field <code>__dict__</code> is part of this type, then copies data into it from the namespace.</p>

<p>For class objects, the native fields include:</p>

<ul>
  <li>
<code>__name__</code> - set to the class name</li>
  <li>
<code>__class__</code> - points to the metaclass name</li>
  <li>
<code>__bases__</code> - list of parent classes (one for single inheritance; more than one means multiple inheritance)</li>
  <li>
<code>__call__</code> - points to method <code>__new__</code> on the class (if it exists), or in an ancestor type (base type <code>object</code> provides a default implementation which is usually good enough)</li>
  <li>
<code>__doc__</code> - points to the “docstring” for the class (if present); see later</li>
  <li>
<code>__annotations__</code> - holds any annotations (eg typehints) declared in the class body</li>
  <li>
<code>__dict__</code> - holds a mapping that can store arbitrary (name, val) pairs - eg methods or class-level variables.</li>
</ul>

<p>As part of the copying of data from the temporary namespace into the class dict, any objects of type <em>function</em> are wrapped in a <em>descriptor</em> which ensures that anyone trying to read the attribute does not actually get the original function (with self parameter) but instead a wrapper function where the first parameter is bound to the object on which the lookup was done. This ensures that <code>obj.methodname</code> returns a function-object that is implicitly bound to the correct self-instance.</p>

<p>When the class object has been completely processed, it is then passed as a parameter to any class-decorators that may be attached to it. Finally, the resulting object is placed into the module’s namespace using the declared name.</p>

<p>Note that we have created an <em>object</em> which represents a <em>class</em>, with a set of attributes which are appropriate for a <em>class type</em>. The actual creation/initialisation of such an object is performed by the metaclass - ie it is the metaclass that decides what native fields exist. However in practice, metaclass <code>type</code> is almost always the one responsible.</p>

<p>The actual CPython datastructure used to represent a class object (objects created by object <code>type</code>) is <a href="https://docs.python.org/3.7/c-api/typeobj.html#PyTypeObject.tp_dict">documented here</a>. The in-memory representation of a class object is somewhat “denormalized” - ie the memory structure allocates lots of fields which might not be poulated. However given that a program creates relatively few class objects at runtime, this is not an issue; instance objects are less “denormalized” in memory.</p>

<p>If no metaclass is explicitly specified (and no <code>__metaclass__</code> attribute is defined) then the metaclass from the first base class is used. If no base class is explicitly specified, then class <code>object</code> is used. Class <code>object</code> has as metaclass class <code>type</code> - and thus almost all classes have <code>type</code> as their metaclass. See later for more discussion on metaclasses.</p>

<p>Instance objects can have a “constructor” defined on the factory-object that creates them, ie their class. Similarly, a class object can have “constructor logic” defined on the factory-object that creates them, ie their metaclass (methods <code>__new__</code> and <code>__init__</code>). However there are a couple of other ways to implement per-class-initialization-logic that are not available for instance objects:</p>

<ul>
  <li>code in the body of the class</li>
  <li>an <code>__init_subclass__</code> method on a parent class</li>
</ul>

<p>Remember that Python files are executed from top to bottom the first time a module is loaded. The “body” of a class is therefore actually executable code; what in other languages are “static member initialisation expressions” are simply code that is executed.  Similarly, method-declarations (<code>def</code>) are actually being executed, returning function objects, which are also then stored into the current namespace.</p>

<p>If the first item in the class declaration is a string, this becomes the “docstring” for the class (and is stored in member <code>__doc__</code>).</p>

<p>Some object-oriented languages support the concept of “destructor methods” which are called when the object is “destroyed”. Python has something similar: method <code>__del__(self)</code> on a class is called when refcount on an instance reaches zero.</p>

<p>Note that it is possible to be a good Python programmer without actually understanding metaclasses; it is seldom necessary to write a custom metaclass.</p>

<h2 id="instance-objects">Instance Objects</h2>

<p>To create an instance of the class, a class object (SomeClass in our example above) is used like a callable object.</p>

<p>Python invokes the <code>__call__</code> method on the class, which usually maps to method <code>__new__</code> on the class - which is usually simply inherited from base class <code>object</code>. The default new method delegates to <code>__new__</code> on the metaclass associated with the original class. The implementation of that method on class <code>type</code> (the default metaclass) creates an in-memory structure to hold the new instance, and then calls method <code>__init__</code> on the class (if such a method exists).</p>

<p>A class seldom overrides method <code>__new__</code>. Method <code>__init__</code> is very commonly overridden and is the equivalent of a “constructor” in other object-oriented programming languages - it initialises each instance as it is created.</p>

<p>Each instance has an in-memory structure containing some “native fields”, including at least <code>__class__</code>, and usually <code>__dict__</code><sup id="fnref:nodict" role="doc-noteref"><a href="#fn:nodict" class="footnote" rel="footnote">3</a></sup>. Note that:</p>

<ul>
  <li>an <em>instance object</em> has a single associated class (its type, ie the factory that created it, and the holder of its “inherited attributes”)</li>
  <li>a <em>class object</em> has a single associated class (its metaclass, ie the factory that created it) and a list of base classes. It is the base classes which provide inherited properties for instances of that class, not the metaclass.</li>
</ul>

<p>Note that objects which are instances of a class are created by calling their class like a function, and have a constructor method (<code>__init__</code>) which is defined on their class. Classes, although they are also objects, are usually created via the <code>class</code> keyword, and their constructor is defined on their metaclass (or a few other options; see above).</p>

<p>Interestingly, while native attributes on classes are generally (always?) immutable, some native attributes on instance objects can be modified after the object has been created - including <code>__class__</code>!</p>

<h2 id="reading-and-writing-object-attributes">Reading and Writing Object Attributes</h2>

<p>Whenever an attribute on an object is <em>read</em> (“someobj.someattr”), Python first checks whether the name refers to one of the “native fields” of the object - ie those that are directly embeded in the in-memory structure that represents that object. If the attribute being read is not one of the “native fields”, and the object has a <code>__dict__</code> native field, then the attribute is searched for as an entry in that dict. If not found in the dict associated with the instance, then it searches in the object referenced by native attribute <code>__class__</code>.</p>

<p>The class in turn searches recursively for the attribute in each base-class (native attribute <code>__bases__</code>).  Thus, a new instance of a class implicitly has all methods of the associated class (and its ancestors) even when it has a nearly-empty dict (or no dict at all); just the <code>__classes__</code> native attribute is sufficient to find those inherited methods (and attributes).</p>

<p>A method-call on an object is simply an attribute-lookup (as above) followed by an invocation operation on the returned object - ie the attribute lookup is expected to return a <em>callable</em> object.</p>

<p>However when an attribute on an object is written, it is always stored directly in the dict associated with the instance. If it has the same name (“key”) as an inherited method or attribute then the inherited value will be masked (though it can be accessed indirectly via <code>obj.__class__.attrname</code>).</p>

<p>In summary, when a read operation is performed using dot-notation <code>obj.attr</code> then Python looks:</p>

<ul>
  <li>in the “hard-wired” attributes associated with the instance (<code>__class__</code>, etc).</li>
  <li>in the <code>__dict__</code> of the local instance</li>
  <li>in the object referenced by <code>__class__</code>
</li>
  <li>in the baseclasses of the ancestor class</li>
</ul>

<p>Due to this chained-lookup, constants can be effectively defined at class-level, and used at instance-level (they are only read).  The difference between read and write also means that primitive types can effectively be defined on a class to provide “defaults” to instances; when they are read then they get the inherited value but as soon as they are written, the instance gets its own copy. However <em>mutable</em> types defined at the class level are dangerous - all instances of the class will share the same state because reading returns the object (eg a map) and modifications of this object then change the shared instance.</p>

<p>For programmers used to Java and similar languages, it is particularly tempting to use “type-hinting” in a class declaration like declaration of instance variables:</p>

<pre><code>class Foo:
  name: str = "default"
  age: int
  mydata: dict = dict()
</code></pre>

<p>However these are effectively equivalent to Java “static” members, ie are class-level attributes (stored in the <code>__dict__</code> associated with the class). There is no way to declare the members that an instance of a class has; these are only defined implicitly via assignment-statements executed in the constructor (init-method) and other methods of the class. Well, unless the <code>__slots__</code> mechanism is used (see later).</p>

<p>There is an official syntax that allows a class to <a href="https://www.python.org/dev/peps/pep-0526/#class-and-instance-variable-annotations">define which attributes the init-method should initialise</a>, but this is just info for external validators - it has no effect at runtime (all declared fields with initial values are added to the class, not the instance, and all declared fields without values are just ignored).</p>

<p>Note however that the <a href="https://realpython.com/python-data-classes/">@dataclass decorator</a> (since Python 3.7) does use typehints on the decorated class to define fields for instances. In other words, it uses the information stored in <code>__annotations__</code> by the Python interpreter during initial code processing to guide itself when generating the init-method, getter/setter methods, etc.</p>

<p>Because methods and variables both live in the <code>__dict__</code>, it is not possible to have a variable and a method with the same name.</p>

<h2 id="invoking-the-superclass">Invoking the Superclass</h2>

<p>Unlike some languages, a constuctor function (<code>__init__(self)</code>) does not automatically invoke the constructor on the parent class; it is considered good style for every constructor function to start with:</p>

<ul>
  <li><code>super().__init__(self, ...)</code></li>
</ul>

<p>When a class has multiple base classes, then the super calls need to be explicit:</p>

<pre><code>Base1.__init__(self, ...)
Base2.__init__(self, ...)
</code></pre>

<h2 id="classes-with-slots">Classes With Slots</h2>

<p>Previously, we have described the default implementation of instance objects: that instance-level attributes are stored in a dictionary (map) structure named <code>__dict__</code>.</p>

<p>However a class may define an attribute <a href="https://docs.python.org/3/reference/datamodel.html#slots"><code>__slots__</code></a> which is a list of attribute names (somewhat like namedtuple). When <em>instances</em> of this class are created, then the “<code>__new__</code>” method that allocates memory for each instance of the class ensures space is allocated directly in the core in-memory structure, next to the “native fields”. <em>Descriptors</em> are automatically added to the class (by its metaclass) so that code like <code>obj.myattr</code> retrieves the value from the core in-memory structure rather than using the inherited behaviour of looking in the <code>__dict__</code>.</p>

<p>When the slots list includes <code>__dict__</code> then the instances also have a dict as usual. When the slots list does not include <code>__dict__</code> then that object simply does not have a dict - and thus cannot have any “dynamically added” attributes or methods. However it still inherits methods and attributes from the type referenced via native field <code>__class__</code>.</p>

<p>Note that at the class-level, <code>__slots__</code> is just a list of strings. It is the <em>instances</em> of that type that have their in-memory layout significantly modified, not the class that creates the instances.</p>

<p>Class inheritance does still mostly work when the base class uses slots, but there are some quirks. See the Python reference manual for more details.</p>

<h2 id="classes-and-method-objects">Classes and Method Objects</h2>

<p>Declaring a function within a module produces a <em>function object</em> - an object with attributes (in dict) like name and doc.</p>

<p>Declaring a function within a class also produces a <em>function object</em> which is added to the class dict. However by default, the code that initialises the class object wraps the function in a <em>descriptor</em>, as described in the section on descriptors. The descriptor’s get-method returns a wrapper around the original function which automatically sets the first parameter (self).</p>

<p>This auto-self behaviour means that the returned function-object can be passed around - <code>doSomething(obj.method1)</code> will give function <code>doSomething</code> an invokable object which “knows” that it is bound to <code>obj</code>.</p>

<p>This wrapping only occurs when the method is retrieved from the class (because the descriptor was set up during class instantiation). If a function-object is stored directly in the dict of an <em>instance</em> then there is no decorator, and so the object is returned without any post-processing. See <a href="https://docs.python.org/3/reference/datamodel.html">instance methods</a> for more info.</p>

<h2 id="multiple-inheritance">Multiple Inheritance</h2>

<p>A class can have multiple ancestors, eg <code>class Foo(base1, base2, base3): pass</code>.</p>

<p>Python has a moderately complicated algorithm called MRO (method resolution order) which takes these bases, and their ancestors, and produces a plain linear list of classes used when performing attribute lookups. In general, this is equivalent to a depth-first search of the base classes in the order they are listed. However when the same class is found multiple times in the ancestry tree, then it is added just once to the list - and the exact position in the list is carefully chosen to provide “stable lookup ordering” when changes to the hierarchy occur. In some cases, no reasonable “stable” ordering can be found, in which case an exception is thrown while defining the class.</p>

<h2 id="metaclasses">Metaclasses</h2>

<p>Every object has a reference to its type. But a type is also a class - and has its own reference to a type. A “metaclass” is simply the class that a class object references via <code>__class__</code>. In most cases, classes (eg int, str, or your own custom classes) have the class “type” as their metaclass. However it is also possible to create a subclass of <code>type</code> with special behaviour, and then specify that via “metaclass=” for new classes.</p>

<p>A new class object can be created programmatically by using class <code>type</code> as a function - just like a custom <code>SomeClass</code> is used to create instances of that class. The <code>class</code> keyword in Python source code effectively does just that. Here is an example of creating a new class object (ie a new type) programmatically:</p>

<pre><code>class Parent: pass

# create class in usual implicit manner
class Foo1(Parent):
    i = 1
    def m(self): print("m1")

# create class in more explicit manner
bases = (Parent,) # tuple with one member
d = dict()
d["i"] = 1
d["m"] = lambda self: print("m2")
Foo2 = type("Foo2", bases, d)  # using "type" as the metaclass

# and verify behaviour

f1 = Foo1()
print(type(f1))
print(dir(f1))
f1.m()

f2 = Foo2()
print(type(f2))
print(dir(f2))
f2.m()
</code></pre>

<p>Custom metaclasses are primarily useful for changing the way the new/init methods work on a class, ie changing the way new instances of a class are created. In many cases, an alternative is to just create a base class with custom new/init methods and inherit from that. However that approach does sometimes change the “inheritance structure” in a way which might not be desirable.</p>

<p>A specific class is an instance of a metaclass, just like a specific string is an instance of the type <code>str</code>. Or looking at this from another angle, class <code>type</code> is a factory for objects which are “classes” - a factory of factories. And just like class <code>str</code> is used to create many instances at runtime, class <code>type</code> is used to create many different class-objects - which are then used to create objects which are “of that type”.</p>

<p>A class can specify its metaclass via several mechanisms; the obvious one is <code>class Foo(base, metaclass=xyz): ...</code>. Python also allows a class to declare an <em>attribute</em> named <code>__metaclass__</code> to control which class is invoked to transform the “temporary namespace” created by the class body into an actual class object. A value for <code>__metaclass__</code> can also be declared as a module-scoped variable, affecting all classes that do not override it. See the official docs for details.</p>

<p>Interestingly, while an instance object does not inherit methods from metaclasses associated with its class (searching for methods only looks in base-classes), invoking a method directly on a <em>class object</em> searches for methods in the metaclass, not the base classes.</p>

<p>Note that it is possible to be a good Python programmer without actually understanding metaclasses; it is seldom necessary to write a custom metaclass.</p>

<h2 id="the-difference-between-a-class-and-an-instance">The Difference Between a Class and an Instance</h2>

<p>Because classes are objects, and instances of classes are also objects, it can be helpful to look at the <em>differences</em> between them:</p>

<p>Lifecycle:</p>

<ul>
  <li>Instance objects are created during the program lifetime, as needed</li>
  <li>Instance objects are garbage-collected when their reference-count drops to zero.</li>
  <li>Class objects are (usually) created only when a module is loaded</li>
  <li>Theoretically, class objects can be garbage-collected, but they are usually referenced from modules and modules are rarely unloaded.</li>
</ul>

<p>Initialisation:</p>

<ul>
  <li>An instance object is initialised by an init-method on its class (a “constructor”)</li>
  <li>A class object can be initialised in several ways:
    <ul>
      <li>code in the class body</li>
      <li>code in the metaclass</li>
      <li>code in a base-class (method <code>__init_subclass__</code>)</li>
      <li>a class-decorator</li>
    </ul>
  </li>
</ul>

<p>Hierarchy:</p>

<ul>
  <li>An instance object has exactly one class</li>
  <li>A class object has both a class (its metaclass) and a set of base classes</li>
</ul>

<p>Lookups:</p>

<ul>
  <li>When an attribute is queried on an instance object
    <ul>
      <li>lookup is done on the object itself</li>
      <li>when the attribute is not found, lookup is delegated to its associated class</li>
      <li>When the attribute is still not found on the class object, lookup is delegated to its base classes</li>
    </ul>
  </li>
  <li>When an attribute is queried on a class object
    <ul>
      <li>lookup is done on the object itself</li>
      <li>when the attribute is not found, lookup is delegated to its class (ie the metaclass)</li>
    </ul>
  </li>
</ul>

<p>Slots:</p>

<ul>
  <li>An instance object can store its data in <code>__slots__</code> to reduce memory usage when lots of instances exist</li>
  <li>A class could <em>maybe</em> do this, but it would be pretty crazy - and not necessary, as there are relatively few class-objects in a program</li>
</ul>

<h1 id="abstract-base-classes">Abstract Base Classes</h1>

<p>Python’s use of types is a little bit odd for people (like me) coming from other programming languages.</p>

<p>Python deals with object types in three ways:</p>

<ul>
  <li>Duck Typing</li>
  <li>Declaration-time Inheritance</li>
  <li>Abstract Base Classes</li>
</ul>

<p>Duck typing is effectively <em>no typing</em> - a function expects that one of its parameters is an object with methods <code>x(a, b)</code> and <code>y(c)</code>, and as long as the parameter has those methods then all is good. The “isinstance” function is not useful, as the function simply does not care what actual type the parameter has.</p>

<p>Declaration-time inheritance is the kind of typing that programmers from C++, Java, and similar languages expect. When a class is defined, it declares its ancestor classes. Attributes and methods are inherited from those declared ancestors. The “isinstance” function can be used to determine whether a parameter is of the expected type (or a subtype thereof). The Python interpreter itself never performs any type-checks, but code can do so explicitly - and lots of standard-library functions do<sup id="fnref:noduck" role="doc-noteref"><a href="#fn:noduck" class="footnote" rel="footnote">4</a></sup>.</p>

<p>Python’s <a href="https://docs.python.org/3/library/abc.html">Abstract Base Class</a> feature (also known as ABC) is a very interesting third approach. Using metaclass <code>collections.abc.ABCMeta</code>, a class can be declared as “abstract” - with abstract method declarations too. Then either:</p>

<ul>
  <li>a class can be created with the abstract class declared as a parent (similar to Java, etc), or</li>
  <li>an existing class can be “registered” with the abstract class to <em>retrospectively make it a subclass of the abstract class</em>
</li>
</ul>

<p>The simple declaration-time subclassing is similar to most other object-oriented languages (Java, etc). Instances of a subclass cannot be created unless all methods declared abstract in the ancestor classes have been overridden with non-abstract implementations.</p>

<p>The register-based approach is more interesting; any class can be passed as a parameter and that class object is validated by the base class to ensure it implements all required methods (if not, an exception is thrown) and then the class is added to an internal list of “registered implementing classes”. Later, when <code>isinstance(obj, someabstractclass)</code> is invoked, <code>someabstractclass</code> just checks whether the object’s class is in its <em>list of registered classes</em>. Note that the registered class is not modified - it does not inherit any attributes or methods from the “abstract base” it was registered with, it just gets added to the “implementing classes list”.</p>

<p>The Abstract Base Class feature is used extensively throughout the Python standard libraries; there are ABCs for <code>Number</code> (all numeric types), and various other useful groupings of classes. Standard library type declarations are often followed by one or more call to <code>register</code> to link the types to their logical ancestors.</p>

<p>One nice use of ABCs is to create restricted subsets of existing types. For example the standard library might have a base class B with 3 methods, but you want a method that accepts any object that implements at least two of those methods. You can simply declare an ABC with those two methods, and register all relevant implementations of B with your new type; they are guaranteed to be compatible. You can then also provide your own classes that implement the same ABC.</p>

<p>The PEP document for ABCs states (reinterpreted by me) that with respect to types:</p>

<ul>
  <li>using declaration-time inheritance trees provides “false negatives” - an object might well be suitable for a specific purpose even when it does not inherit from an expected base type</li>
  <li>duck-typing provides “false positives” - an object might NOT be suitable for a specific purpose even when it happens to have a method with the right name and param-count</li>
</ul>

<p>The ABC approach gives flexibility - a specific abstract type may be required by called code, but the caller has the ability to mark any type as “being compatible” if they wish, regardless of its ancestry.</p>

<p>In Java and similar languages, when you have an object that really does provide the functionality required by a specific interface, but was not statically declared with the appropriate ancestor, then the <em>adapter pattern</em> needs to be applied - ie a trivial <em>wrapper object</em> needs to be created, which is somewhat ugly. With the “register” functionality of abstract base classes, no such adapter is needed; any code asking “is this object really an instance of the expected base type” gets the answer “yes” and can continue in relative confidence that the programmer did indeed pass an object of an appropriate type. Using <code>isinstance</code> to test for types that are not abstract base classes should be avoided, as that does really force the caller to use an adapter or similar workaround. And as with any object-oriented language, excessive use of <code>isinstance</code> suggests that perhaps polymorphism (ie a method with different implementations in different classes) might be a better solution. The author of the <code>abc</code> spec suggests their best use is for “sanity checks”, in order to provide good error messages etc., and that creating new <code>abc</code> types is probably not necessary - the core library types should be enough.</p>

<p>Interestingly, the widely-used Zope CMS (content management system) provides an implementation of traditional object-oriented interfaces <a href="https://zope.readthedocs.io/en/latest/zdgbook/ComponentsAndInterfaces.html">on top of Python</a>. And the well-known Twisted framework also uses Zope’s interface system. It appears that “duck typing” is not always considered the best solution. However one of the developers of Zope’s interfaces <a href="http://glyph.twistedmatrix.com/2009/02/explaining-why-interfaces-are-great.html">prefers them to Abstract Base Classes</a>.</p>

<h1 id="the-namedtuple-module">The namedtuple Module</h1>

<p>Function <code>collections.namedtuple(...)</code> takes a “data structure definition” as parameter and returns a class that can act as a factory for objects matching that definition.</p>

<p>Unlike tuples (and like classes) the namedtuple attributes can be referenced by name (<code>tuple.attr</code>). This works because the class generated by function <code>namedtuple</code> contains the “getter” methods needed to support lookup-by-name. The instance objects that the class creates have no <code>__dict__</code>, just an embedded tuple; the instances are therefore very space-efficient.</p>

<p>However because tuples are immutable, the generated class does not provide “setter” methods to update individual attributes. Instead, it provides a number of helper methods, the most useful of which is <code>_replace(keywordargs)</code> which generates a new instance, replacing each attribute specified in the keywordargs with the associated value. Don’t be fooled by the leading underscore - it is not there because the method is “private” but instead to indicate that the method is <em>generated</em>.</p>

<h1 id="enums">Enums</h1>

<p>Most languages provide explicit support for “enumerated types”. Python provides this via a <a href="https://docs.python.org/3/library/enum.html">standard-library class</a>:</p>

<p>Basic usage looks like the following:</p>

<pre><code>from enum import Enum
class Color(Enum):
  RED = 1
  GREEN = 2
  BLUE = 3
</code></pre>

<p>Lots of interesting options exist in the enum support; see the docs for details.</p>

<h1 id="local-variables">Local Variables</h1>

<p>Every module has its own namespace (a dict of names to objects), as does every “def”. The function “<code>locals()</code>” returns the namespace dict - which can be useful for looking up variables dynamically. Function <code>locals()</code> is quite often used as a parameter to <code>String.format</code> to elegantly interpolate the values of variables into format-strings:</p>

<pre><code>def foo():
  owner = "charlie"
  dog = "snoopy"
  print("{owner} is the owner of {dog}".format(\*\*locals()))
</code></pre>

<p>Function <code>vars</code> is actually a superset of function <code>local</code>:</p>

<ul>
  <li>
<code>vars(obj)</code> is equivalent to <code>obj.__dict__</code>
</li>
  <li>
<code>vars()</code> is equivalent to <code>locals()</code>, ie returns the dict for the current stack frame</li>
</ul>

<p>Formatted strings were introduced in Python recently: these can reference names from the current namespace directly:</p>

<pre><code>  print(f"{owner} is the owner of {dog}")
</code></pre>

<h1 id="ternary-expressions">Ternary Expressions</h1>

<p>The C programming language supports “ternary expressions” of form <code>a = (boolexpr) ? valwhentrue : valwhenfalse</code>, and this has been copied by many other languages. Python does not have this exact syntax, but similar effects can be achieved.</p>

<p>If-expressions are of form <code>var = 10 if a else 20</code>. The order is a little weird (values left and right, with the boolean clause in the middle) but Python often uses weird ordering - another is “import foo” but “from bar import baz”.</p>

<p>An alternate approach is to use chains of <code>and</code> and <code>or</code>:</p>

<ul>
  <li>in most languages, <code>a or b or c</code> evaluates to either true or false but in Python it evaluates to one of the values (a, b, c) - either the “first true-like value”, or the last value in the sequence</li>
  <li>similarly, <code>a and b and c</code> evaluates to either the “first false-like value” or the last value in the sequence</li>
</ul>

<p>Thus:</p>

<pre><code># x = (a=1) ? "yes" : "no"
x = (a==1) and "yes" or "no"
</code></pre>

<h1 id="functional-programming">Functional Programming</h1>

<p>Standard library modules <code>functools</code>, <code>itertools</code> and <code>operator</code> provides utilities for various functional-style goodies such as:</p>

<ul>
  <li><code>map/filter/reduce</code></li>
  <li>
<code>lambda</code>  (anonymous functions)</li>
  <li>closures</li>
  <li>partial function application</li>
</ul>

<h1 id="static-typechecking">Static Typechecking</h1>

<p>As noted earlier, Python does have a type-hierarchy, and typehints (Python 3.6) allow variables and parameters to be annotated with specific types.</p>

<p>It is therefore possible to write in a style where everything is annotated, and then use an external typechecker program such as Mypy to check the code for consistency. There are no plans for the CPython interpreter to support typechecking at runtime.</p>

<h1 id="persistence">Persistence</h1>

<p>Storing data on disk (<a href="https://docs.python.org/3/library/persistence.html">persistence</a>) is the goal of various features of the Python standard library:</p>

<ul>
  <li>pickle (serializing Python objects to bytearrays, and deserializing them again)</li>
  <li>shelve (combines pickles with disk-storage)</li>
  <li>dbm (standard API for key/value stores)</li>
  <li>dbapi2/sqlite - a simple relational database bundled with the Python standard library!</li>
</ul>

<p>The standard way of talking to a relational database from Python is the DBAPI2 api. This is similar to Java’s JDBC - although code is not quite so portable between databases. DBAPI2 is not actually part of the standard library; it is effectively a <em>protocol</em> (ie a documented convention).</p>

<p>There are various third-party ORM (object-relational mapping) libraries that make interacting with SQL databases from Python easier than using the very low-level DBAPI2; the best-known appear to be:</p>

<ul>
  <li><a href="https://www.sqlalchemy.org/">SQLAlchemy</a></li>
  <li><a href="http://sqlobject.org/">SQLObject</a></li>
  <li><a href="https://peewee.readthedocs.io/en/latest/">Peewee</a></li>
  <li><a href="https://ponyorm.com/">PonyORM</a></li>
</ul>

<p>The <code>sqlite</code> embedded database (and matching DBAPI2 driver) is included in the Python standard libraries, meaning basic SQL support is available “out of the box”.</p>

<h1 id="regular-expressions">Regular Expressions</h1>

<p>The <code>re</code> standard library module provides regular expression support - very similar to Java’s regular expression library. Unlike Perl or Javascript, regular expression support is not built into the language itself.</p>

<h1 id="logging">Logging</h1>

<p>Python provides a <a href="https://docs.python.org/3/library/logging.html">standard logging module</a> for code to emit debug/info/warn/error messages. The module is similar to the various logging libraries for Java (log4j, java.util.logging, etc).</p>

<h1 id="parsing-external-file-formats">Parsing External File Formats</h1>

<p>Python’s standard library includes support for reading and writing a wide range of data formats, including:</p>

<ul>
  <li>Delimiter-separated data with the <code>csv</code> module</li>
  <li>Windows-style <code>.ini</code> files with the <code>configparser</code> module</li>
  <li>JSON data with the <code>json</code> module</li>
  <li>XML (DOM and SAX approaches)</li>
</ul>

<p>For configuration-files, it is also possible to just use a Python file, and use <code>eval</code> to “read it”.</p>

<h1 id="context-managers">Context Managers</h1>

<p>It is often necessary to run code of form setup/dosomething/cleanup. Ensuring the cleanup is always executed, even in the presence of errors or exceptions, can be tricky. Python’s <a href="https://docs.python.org/3/reference/compound_stmts.html#with">answer to this</a> is the <em>context manager protocol</em> and the <em>with statement</em>.</p>

<p>Example (using path.open which returns a <code>file</code> object that is a valid context-manager):</p>

<pre><code>with path.open() as file:
  ...
</code></pre>

<p>The expression after <code>with</code> should return an object that implements the <em>context manager protocol</em>. This simply requires an <code>enter</code> and an <code>exit</code> method; method <code>enter</code>is invoked at the start of the with-clause, and the returned object is assigned to the “as-variable”. When control leaves the scope of the with-statement <em>for any reason</em>, method <code>exit</code> is invoked.</p>

<p>Sometimes the “enter” method just returns self, ie the expression following <code>with</code> is both the resource to access, and a context-manager at the same time (as is the case for a <code>file</code> object). In other cases, the context-manager is a “wrapper” around a resource.</p>

<p>This is equivalent to Java’s try-with-resources feature.</p>

<h1 id="generators">Generators</h1>

<p>Warning: some of the details in this section regarding internal implementation of generators are speculation. Given the behaviour of generators, I have tried to guess how they are implemented because I grasp concepts better that way (understanding the underlying implementation) than simply memorizing what features generators provide. If you prefer to just stick to the “what” rather than the “why”, then see <a href="https://docs.python.org/3/reference/expressions.html#yieldexpr">the official documenation on generators</a>. And if you know more about how generators work than I do, then feedback/corrections are very welcome!</p>

<p>Normal functions get allocated a <em>namespace</em> when they are called, and that namespace is destroyed when the function returns. Any local variables that function defines are therefore lost at function return; the next call starts with a new namespace. A generator instead has a <em>long-lived</em> namespace; when the <code>yield</code> operator is executed within a function, the caller receives the specified value (like a return-statement) but the current namespace is saved away. The function can later be <em>resumed</em> with the same set of local variables it previously had.</p>

<p>Anything a generator function can do can also be implemented as an <em>object</em> that stores state in its object attributes rather than in local variables - but the code is far less elegant.</p>

<p>When Python is about to create a “function object” as the result of executing a line of source-code starting with <code>def</code>, then it first checks whether operator <code>yield</code> occurs anywhere within the bytecode body of that function; if so then it does not return a normal function object, but instead a generator-constructor function (ie a function that is a factory for generator instances) which wraps that function.</p>

<p>When the generator-constructor-function is invoked for the first time, it just creates a <em>generator object</em> and returns it.</p>

<p>The generator object implements the following methods:</p>

<ul>
  <li><code>__iter__() # returns an iterator - actually just returns self, as a generator function object *is* an iterator object</code></li>
  <li><code>__next__() # the iterator protocol - equivalent to send(None)</code></li>
  <li>
<code>send(value) # causes the generator to run the target fn (on first call), or resume from </code>yield<code>. On first call, only "None" is allowed as the sent value.</code>
</li>
  <li>
<code>close() # causes the </code>yield<code> expression within the generator to throw a GeneratorExit exception</code>
</li>
  <li>
<code>throw(type, ..) # causes the </code>yield<code> expression within the generator to throw the specified exception</code>
</li>
</ul>

<p>The generator object also contains:</p>

<ul>
  <li>an attribute holding the set of local variables (a dict) - initialised to the parameters passed to the generator-constructor-function</li>
  <li>an attribute holding the “last instruction address” - the offset within the function’s bytecode of the most recent yield function executed (initially zero)</li>
</ul>

<p>The real function definition that the generator wraps is not directly accessible; it can be invoked only indirectly, via the generator methods <code>__next__</code> or <code>send</code>.</p>

<p>Originally, generators did not support send/close/throw - those features were added later (by PEP 342), in an attempt to support <em>coroutines</em> in Python (as was <a href="https://www.python.org/dev/peps/pep-0380/">yield from</a>). However the community eventually reached the conclusion that this was the wrong approach, and instead added keywords <code>async</code> and <code>await</code> to the language; <code>async def</code> produces objects that are similar to generators, but nevertheless independent. As far as I can tell, the use of send/close/throw on generators (and <code>yield from</code>) is effectively <em>deprecated</em> - I will therefore only mention very briefly how they work.</p>

<p>Note that programmers should not usually mess with system names of form “<code>__name__</code>” - here, that means that <code>__iter__</code> and <code>__next__</code> should really not be called directly. Built-in functions <code>iter(obj)</code> and <code>next(obj)</code> internally delegate to the underscore-based methods, but are considered more elegant.</p>

<h2 id="generators-as-producers-of-data">Generators as Producers of Data</h2>

<p>A generator which uses <code>yield</code> to output data, and expects its users to call <code>__next__</code> to obtain such data is a “producer” of values. An example is:</p>

<pre><code>def myrange(first, last):
    curr = first
    while curr &lt;= last:
        yield curr
        curr += 1

# prints values 6,7,8,9,10,11,12
g = myrange(6, 12)
for i in g:
    print(i)
</code></pre>

<p>Note that the line <code>for in in g:</code> actually triggers a call to <code>g.__iter__()</code> followed by repeated calls to <code>g.__next__()</code> (that is how for-loops work).</p>

<p>When <code>__next__</code> is invoked on a generator object, the generator object simply tells the Python interpreter to:</p>

<ul>
  <li>set the “current namespace” to the saved variables held by the generator object, and</li>
  <li>start executing bytecode at the “last instruction offset”.</li>
</ul>

<p>On the first call to <code>__next__</code>, this means that execution starts at the beginning of the function, and the only local variables defined are the function-parameters. The function continues until it executes a <code>yield</code> operation, at which point the offset is saved and the value passed to <code>yield</code> is returned as the output of the <code>__next__</code> call.</p>

<p>On the next call to <code>__next__</code>, the function continues at the bytecode instruction following the <code>yield</code> command - and with all its local variables intact.</p>

<p>A function with a single <code>yield</code> statement is effectively a function with two entry-points: the function start, and the line after the <code>yield</code> statement. It would therefore be possible to write a class whose instances behave similarly - all local vars would need to be self-attributes, and the function body would need an if-statement to select the appropriate “entry-point”. With N <code>yield</code> statements, N+1 entry points are needed - also doable, though somewhat more complex. However the object-based implementation would just not look as elegant as the generator approach.</p>

<p>The most common use-case for generators is to provide “lazy data providers” - data is computed as needed.</p>

<p>An extension of a simple single “lazy data provider” is to build a chain of such generators, in order to create a “pull-based data processing workflow”. Each generator in the chain has a constructor that takes an iterable object representing a “data source”; the first generator receives a real iterator (eg a file-object providing lines from a file) while other generators receive a generator (which is an iterator) as parameter. Each generator function consumes data from its input iterator, and outputs data using <code>yield</code>.  The resulting code is readable, and looks like usual imperative programming logic. However at runtime, as the “main thread” of the application calls next on the last generator in the chain, this triggers a sequence of calls that effectively “pull” a single item of data through the processing chain. This is elegant, particularly when the end consumer may decide to stop processing when it encounters the data it needs. This resembles the default “lazy” behaviour of functions in Haskell.</p>

<h2 id="generators-as-coroutines-deprecated">Generators as Coroutines (deprecated)</h2>

<p>The addition of the <code>send</code> method to generators means that a generator function can look like:</p>

<pre><code>def mygencoro(arg1, arg2):
  count = 0
  while True:
    x = yield
    count += 1
    print("{}: {}".format(count, x.uppercase()))

mygen = mygencoro("val1", "val2")
mygen.send(None)  # starts underlying function, which blocks at the first call to yield
mygen.send("hello") # resumes from yield
mygen.send("world") # resumes from yield
mygen.close()
</code></pre>

<p>Note that statement <code>x = yield</code> vs the earlier generator example which contained <code>yield curr</code>.</p>

<p>As usual, the initial call to the generator just saves the params away, and does not invoke the actual underlying function.</p>

<p>The first call to ‘send’ must always pass <em>None</em> as the value; the invoked function starts running at the beginning (rather than resuming from a previous <code>yield</code>) so the send-value is ignored - and thus providing a value is non-sensical and almost certainly a bug. The function then starts at the beginning, and is suspended when it encounters the <code>yield</code> operator, at which point the call to “send” returns.</p>

<p>On the next call to <code>send</code>, x is set to whatever value was sent, and <code>mygenfn</code> continues on the line following the <code>yield</code>.</p>

<p>Note that all processing occurs on a single thread; when “send” is called, the current thread is used to “resume” the generator. And when the generator executes <code>yield</code> then the current thread continues at the point after the <code>send</code>.</p>

<p>Theoretically it is possible for the <code>yield</code> operator here to have an associated expression (like the earlier generator example), in which case the expression becomes the return-value of the call to <code>send</code>. However a tutorial on generators that I found warned about trying to both consume and produce data using <code>yield</code> (ie code of form <code>x = yield {expr}</code>) - it “may make your head explode”.</p>

<p>Methods <code>close</code> and <code>throw</code> cause the function associated with the generator to resume, just like a call to <code>__next__</code> or <code>send</code> does - but instead of executing the code following <code>yield</code>, an exception is thrown. The function may catch the exception, and perform some cleanup (eg closing an “upstream data source” that the generator reads from). See the official docs for generators for more details.</p>

<p>PEP 342 gives a good description of the reasoning that drove creation of the <code>send</code> and <code>x = yield</code> syntaxes (to extend conventional generators to be useable as “coroutines”):</p>

<blockquote>
  <p>Coroutines are a natural way of expressing many algorithms, such as simulations, games, asynchronous I/O, and other forms of event-driven programming or co-operative multitasking. Python’s generator functions are almost coroutines – but not quite – in that they allow pausing execution to produce a value, but do not provide for values or exceptions to be passed in when execution resumes.</p>
</blockquote>

<p>Early versions of module <code>asyncio</code> then provided “asynchronous programming” APIs hased on these generator-based coroutines.</p>

<p>As noted earlier, my current understanding is that this approach is an evolutionary dead-end, and that keywords async/await, together with function <code>async.run()</code> which is provided in the latest version of module <code>asyncio</code>, should be used for all use-cases that this approach was intended to cover. See the following documents for details:</p>

<ul>
  <li>
<a href="https://www.python.org/dev/peps/pep-0492/">PEP 492 - Coroutines with async/await</a> - the currently recommended way to use coroutines</li>
  <li>
<a href="https://www.python.org/dev/peps/pep-0342/">PEP 342 - Coroutines via enhanced generators</a> - the now-deprecated specification for generator-based coroutines</li>
</ul>

<h1 id="async-coroutines">Async Coroutines</h1>

<p>Prefixing a function declaration with <code>async</code> causes a “coroutine constructor function” to be returned; the standard <code>def</code> behaviour is executed, ie a function-object is created and then another function-object is created which wraps the original. This behaviour is similar to how a “generator constructor function” is created to wrap a function-object. However to support generators, Python needs to inspect the bytecode of <em>every</em> function to see whether <code>yield</code> is present; the presence of <code>async</code> marks coroutines clearly (and triggers the appropriate wrapping logic) without need for such “bytecode scanning”.</p>

<p>Invoking the coroutine constructor function creates and returns a coroutine object - without invoking the underlying function. This is similar to invoking a generator constructor function and getting back a generator object.</p>

<p>To actually invoke the underlying (wrapped) function of a coroutine object, the application needs to start an “event loop” via <code>asyncio.run(initial_coroutine)</code> (or run some third-party framework that provides a similar event-loop). That initial coroutine can then invoke other coroutines by:</p>

<ul>
  <li>using <code>await some_coroutine_obj</code>
</li>
  <li>passing the coroutine object to <code>asyncio.create_task(..)</code>
</li>
  <li>using <code>async for</code>
</li>
</ul>

<p>Async-based coroutines (ie async/await keywords) were added to Python in version 3.5. The event-loop support in module <code>async</code> was added in version 3.7.</p>

<p>See below for brief coverage of <em>asynchronous programming with coroutines</em> and <a href="/programming/python-async">this separate article on asynchronous programming with coroutines in Python</a> for more details.</p>

<h1 id="concurrent-programming">Concurrent Programming</h1>

<p>There are many operations that a program can do which will “block” waiting for some operating system operation to complete; file or network IO are typical examples. However a program may well have other things it could do while waiting for that blocking operation to complete. There are <a href="https://docs.python.org/3/library/concurrency.html">three different approaches</a> to doing this:</p>

<ul>
  <li>os-level threads</li>
  <li>multiprocessing</li>
  <li>user-level “asynchronous programming”</li>
</ul>

<p>Python’s support for these alternatives are discussed below.</p>

<h2 id="threading">Threading</h2>

<p>Threading allows code to be written in a linear style. Calls to operating-system level functions that may block can just be written in the obvious way; the code will indeed <em>block</em> (be suspended) until the operation completes.</p>

<p>Obviously, while a thread is blocked, it is making no progress. To make an application efficiently use the CPU or CPUs, while still allowing code to perform blocking operations, the application must start multiple <em>threads</em>. Starting threads is easy; the hard part is safely exchanging data between threads.</p>

<p>Threads allow a correctly-designed program to take advantage of all the CPUs on a host system. It also provides “preemption”, ie makes sure that each (runnable) thread gets a fair share of the CPU.</p>

<p>However threads also have some problems;</p>

<ul>
  <li>each thread has significant overhead related to memory usage (stack)</li>
  <li>each thread has overhead related to cpu-usage (context-switching)</li>
  <li>setting up a thread has significant overhead, ie it is not advisable to start and stop threads rapidly</li>
  <li>safely exchanging data between code in different threads requires synchronization (mutexes, etc).</li>
</ul>

<p>Sometimes other approaches end up being more efficient (particularly when only one physical CPU exists) - eg asyncio.</p>

<p>The Python standard library provides functions for creating threads, and provides various “synchronization primitives” for exchanging data between threads (a threadsafe queue, mutexes, etc).</p>

<p>However there is a problem with threads that is specific to CPython - the Python interpreter itself is not threadsafe. Any time a thread tries to perform an operation such as looking up a variable, it must first become owner of the <em>global interpreter lock</em> (GIL). In practice, this means that when multiple threads try to run Python code at the same time, all but one of them will be blocked waiting for the GIL. The result is that the application uses at most one CPU at a time. The threaded program is still faster than a non-threaded one, because while one thread is waiting for a blocking operation to complete, another thread can be using the CPU. But really scalable, it is not.</p>

<p>When a Python thread calls into a native-code library, and that library is doing CPU-intensive work that does not involve calling back into the Python interpreter, then threading can be efficient. An example is the Numpy numeric library; multiple threads that call from Python into the numpy native code can make good use of multiple CPUs.</p>

<h2 id="multiprocessing">Multiprocessing</h2>

<p>Given the problems with threads, a good option for scalable processing of data is sometimes to just start <em>multiple operating-system-level processes</em> which communicate with each other over sockets or similar. The startup overhead is of course high, but as each process has its own complete Python interpreter, the GIL is no longer a limiting factor.</p>

<p>The Python standard library includes some features that makes building multiprocessing applications a little easier; see:</p>

<ul>
  <li>module <code>multiprocessing</code>
</li>
  <li>class <code>concurrent.futures.ProcessPoolExecutor</code> – provides an interesting API for distributing workload across a pool of <em>processes</em> rather than threads.</li>
</ul>

<p><a href="https://www.python.org/dev/peps/pep-0554/">PEP 554</a> (currently in draft) is proposing an interesting variant on multiprocessing - starting multiple independent Python interpreter instances within the same operating-system process. Each such interpreter has its own GIL, and so there is no competition for the lock. Of course, Python code in one interpreter cannot see variables in another interpreter, but the proposal also includes a mechanism for inter-interpreter communication.</p>

<h2 id="asynchronous-programming-with-coroutines">Asynchronous Programming with Coroutines</h2>

<p>The goal of asynchronous programming is not to run Python code in multiple threads, but instead to make the best possible use of a single thread. Because multiple os-level threads are not involved, the CPython GIL is not a limiting factor when using async programming.</p>

<p>Async programming is quite useful for a number of common problems, including:</p>

<ul>
  <li>implementing an http server which needs to handle multiple concurrent http requests</li>
  <li>implementing a message-broker server which needs to handle multiple concurrent client requests</li>
  <li>handling incoming requests which trigger calls to a remote database</li>
</ul>

<p>As noted previously, async code is still limited to 1 CPU - it just makes better use of that CPU than blocking-style programming. However when a system has N cpus, then spawning N instances of the Python app and using async programming within each instance is an effective way to get good performance.</p>

<p>Asynchronous programming requires code be broken up into chunks of non-blocking code joined together with blocking operations. A “scheduler” then runs each chunk; when the blocking operation is reached, that is delegated to a pool of background threads and the “scheduler” thread switches to running a different chunk which is not waiting for any blocking operations. When a blocking operation (managed by a background thread) completes, any chunks that are waiting for that operation to complete are then marked as “runnable” and will (eventually) be executed by the scheduler thread.</p>

<p>Support for <em>asynchronous programming</em> in Python has gone through four major revisions:</p>

<ul>
  <li>using callback functions (not coroutines)</li>
  <li>using coroutines based on generators with <code>generator.send</code>
</li>
  <li>improved coroutines based on generators with <code>yield from</code>
</li>
  <li>new implementation of coroutines based on new keywords async/await</li>
</ul>

<p>Module <code>async</code> has provided support for all these approaches, as have various third-party libraries.</p>

<p>Hopefully the most recent approach based on keyword <code>async</code> will be a long-term solution; the chances are good as the <code>async</code> approach has been copied from other languages where it has been successful (eg <a href="http://thecodebarbarian.com/80-20-guide-to-async-await-in-node.js.html">in node.js</a>). Keywords async/await were added in Python 3.5; function <code>async.run()</code> was added in Python 3.7.</p>

<p>See <a href="/programming/python-async">this separate article on asynchronous programming with coroutines in Python</a> for more details.</p>

<h1 id="garbage-collection">Garbage Collection</h1>

<p>CPython reclaims no-longer-used memory using reference-counting combined with cycle-detection. In practice this means that objects are destroyed immediately after their last reference goes out of scope - unlike systems with mark-and-sweep garbage collection, where destruction time is indeterminate. Nevertheless, relying on prompt destruction of objects is a bad idea, as it is not guaranteed in the Python language - and other Python implementations (eg Jython) do use mark-and-sweep.</p>

<h1 id="unit-testing">Unit Testing</h1>

<p>The Python standard library includes a unit-testing framework similar to JUnit/NUnit. The usual convention is for a directory containing Python modules (ie a package) to have a subdirectory named <code>tests</code> containing unit-test files with names of form <code>test_*.py</code>, ie directory structure looks like:</p>

<pre><code>mypackage/
  __init__.py
  __main__.py
  mymodule1.py
  mymodule2.py
  tests/
    test_mymodule1.py
    etc
</code></pre>

<p>The standard library also includes an interesting framework <code>doctest</code> which looks for unit-tests in doc-strings; there is a standard format which makes such code look like examples for documentation purposes while also being executable/validatable. This feature is not really meant for testing, but rather for ensuring that example code does not get out-of-date.</p>

<p>There are a few third-party libraries for unit-testing which are popular with the Python community.</p>

<h1 id="monkeypatching">Monkeypatching</h1>

<p>This term refers to dynamically adding/removing/replacing methods on classes at runtime.</p>

<p>Methods are normally declared once when the class is created:</p>

<pre><code>class Foo:
  def method1(self, *args): ...
</code></pre>

<p>However due to Python’s dynamic nature, it is possible to add extra methods:</p>

<pre><code>Foo.method2 = lamba self, val: ...
</code></pre>

<p>or to replace methods with alternative implementations:</p>

<pre><code>Foo.method1 = lambda self, *args: ...
</code></pre>

<p>Monkeypatching <a href="https://semaphoreci.com/community/tutorials/mocks-and-monkeypatching-in-python">can be useful for testing</a>.</p>

<p>It can also sometimes be useful to force existing libraries to do things they weren’t designed to do. This can be good (flexible) and horrible (very difficult to debug and understand code) at the same time.</p>

<h1 id="virtual-environments-venv">Virtual Environments (venv)</h1>

<p>When running (or developing) multiple different Python applications on the same machine, it is very difficult to have just a single global pool of all third-party Python libraries. Different versions of libraries have different versions and bugs, and can be incompatible with each other. Linux distributions (eg RedHat, Debian) do manage to define a base set of Python libraries, and applications that use those libraries, but it requires significant effort. As soon as you wish to run an arbitrary Python app that is not part of the standard packages for that distribution, conflicts can occur.</p>

<p>The solution is <code>venv</code>: a command that sets up an isolated pool of libraries. A command-shell simply needs to specify which pool is “currently active” and all Python code run in that environment then sees only libraries in that pool.</p>

<p>Module <code>venv</code> is implemented in the Python standard libraries (since v3.4). There were previously other similar commands, but I won’t talk about historical solutions here.</p>

<p>Python has two primary locations it looks in for modules: the standard library dir, and the site-packages dir. Anything installed via setuptools, pip, rpm/dpkg, etc. goes into a site-packages directory.</p>

<p>When command “{python} -m venv {dirname}” is executed, the venv module creates the target directory, and fills it with a small number of files:</p>

<ul>
  <li>bin/
    <ul>
      <li>activate – a shellscript that “activates this virtual environment”</li>
      <li>python3  – a symlink to the Python interpreter that was run</li>
      <li>pip – a simple script that runs pip</li>
      <li>and a few other commands</li>
    </ul>
  </li>
  <li>lib/
    <ul>
      <li>{pythonversion}/
        <ul>
          <li>site-packages</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>pyvenv.cfg</li>
</ul>

<p>It then automatically runs “python -m ensurepip” which results in pip and setuptools being installed into site-packages; see later.</p>

<p>Running “<code>source {venvdir}/bin/activate</code>” modifies environment-variables in the current shell; primarily it inserts directory <code>{venvdir}/bin</code> into the front of environment variable <code>$PATH</code> so that running <code>python3</code> then uses the symlink from that virtual environment.</p>

<p>That’s about all that needs to occur to create (and enable) a virtual environment.</p>

<p>Standard library file <code>site.py</code> (eg <code>/usr/lib/python3.6/site.py</code> on my Ubuntu system) has the necessary logic to support using the “virtual environments” that <code>venv</code> creates.  When Python is started, <code>site.py</code> is automatically loaded (see comments in the file). At this point, Python has already defined <code>sys.path</code> (the module search path) to include the standard libraries and <code>site.py</code> <a href="https://docs.python.org/3.7/library/site.html">then prepends additional locations to it</a>. The algorithm is (simplified):</p>

<ul>
  <li>determine the path through which Python was started</li>
  <li>look in the parent directory for a file named “pyvenv.cfg”
    <ul>
      <li>if found, prepend subdir <code>lib/{python-version}/site-packages</code> to <code>sys.path</code>
</li>
    </ul>
  </li>
</ul>

<p>When no venv is active, then command <code>python3</code> is a symlink in some global location (eg <code>/usr/bin/python3</code>) and the corresponding (global) site-packages directory for that Python installation is used.</p>

<p>When a venv is active, then <code>python3</code> is a symlink in some venv directory-structure (see earlier), and the corresponding site-packages dir is used instead.</p>

<p>When packages are installed via pip, it uses the same method to determine where to write its packages - ie when a venv is active then “pip install ..” puts files in the site-packages directory for the active environment. When no virtual environment is active, files are written into the site-packages directory associated with the “global” pip install (which might require sudo to write into..).</p>

<p>When packages are installed via tools like <code>apt install python3-{modulename}</code> then they simply go into the global site-packages directory.</p>

<h1 id="packaging-and-distributing-python-code">Packaging and Distributing Python Code</h1>

<p>As users of code, we want to download libraries or applications written by others. As developers of code, we want to be able to bundle our code for installation in production environments, or for others to use.</p>

<p>This topic is too complex to include in this (already large) article; I have therefore summarized what I have learned about this topic <a href="/programming/python-pack">in a separate article</a>.</p>

<h1 id="ides">IDEs</h1>

<p>I have been using Jetbrains Intellij IDEA (licenced) with the Python plugin as an IDE, and it works great. Of course, it is a bit ..odd.. to install a Java-based IDE to develop Python if you are not using IDEA for other reasons.</p>

<p>The <a href="https://docs.python-guide.org/dev/env/#ides">Python Guide page on IDEs</a> is a good source of info on alternatives.</p>

<h1 id="installing-python-manually">Installing Python Manually</h1>

<p>The easiest way to install Python is of course to use your Linux distribution’s packages, eg “<code>apt install python3</code>”. However sometimes:</p>

<ul>
  <li>you are not admin on the system, or</li>
  <li>the version of python provided by the distribution is not what you want (too old or too new)</li>
</ul>

<p>The options I am aware of are:</p>

<ul>
  <li>
<a href="https://www.tecmint.com/install-python-in-linux/">install from source</a> (<a href="https://kerneltalks.com/tools/install-python-3-on-linux-redhat-centos-ubuntu/">alternative docs</a>)</li>
  <li><a href="https://conda.io/docs/user-guide/install/linux.html">install using <code>conda</code></a></li>
</ul>

<p>Note that Ubuntu 18.04 LTS comes with <code>python3.6</code> by default (and <code>python3</code> is an alias for <code>python3.6</code>). However <code>python3.7</code> is available if desired; <code>sudo apt install python3.7</code> will make command <code>python3.7</code> available - although <code>python3</code> remains an alias for <code>python3.6</code> as other Python software on that distribution version expects the slightly older version.</p>

<p>To install from source, you will need a c-compiler available, and some time.</p>

<p>The <code>conda</code> approach instead downloads prebuilt binaries from the <code>conda</code> project. Note that <code>conda</code> is more than just a provider of binary builds of Python - it also:</p>

<ul>
  <li>hosts its own builds of most of the Pypi package archive</li>
  <li>and includes its own package-manager <code>conda</code> (ie alternative to pip)</li>
</ul>

<p>However after installing Python using <code>conda</code>, you can use pip to install packages instead of the <code>conda</code> package manager.</p>

<p>To quote the <code>conda</code> docs:</p>

<blockquote>
  <p>If you have used pip and virtualenv in the past, you can use conda to perform all of the same operations. Pip is a package manager, and virtualenv is an environment manager. Conda is both.</p>
</blockquote>

<p>Both the from-source and from-conda installation approaches just write into your local user directory, and are reasonably easy to remove if desired. The <code>conda</code> solution optionally modifies your user’s path, thus redirecting command <code>python3</code> to the conda-managed installation rather than the system default installation - but as alternative, just choose not to modify <code>bashrc</code> during install, then <code>source ~/miniconda3/bin/activate</code> when you want to use the <code>conda</code> Python install.</p>

<h1 id="other">Other</h1>

<p>The Python  type <code>int</code> is not limited to 64 bits. Instead, the wrapper instance dynamically changes the representation of the data depending on its size - 64 bits if the value fits, otherwise a more complex structure. This change in representation happens automatically.</p>

<p>Python has two distinct implementations: <code>float</code> (64-bit native representation) and the library type <code>decimal.Decimal</code>. The type <code>float</code> does NOT work like the integer type (no automatic expansion of the number of bits available).</p>

<p>The easiest way to copy a list is with <code>list(src)</code> where src is any iterable (including a list). Similarly, <code>dict(src)</code>. These are shallow-copies; for deep copies use standard library module <code>copy</code>.</p>

<p>Keyword <code>del</code> simply invokes <code>__delete__</code> on some object. When invoked without an obvious object, it is invoked on the <em>current namespace dict</em>, ie the local scope of names (thus removing a reference to the object).</p>

<p>A list-comprehension is just a short-hand for a (filter, map) pair of operations. Similiarly for dict-comprehensions.</p>

<p>Flow-control structures <code>for</code>, <code>while</code>, and <code>try</code> all support an optional <code>else:</code> clause. They all work the same if somewhat counter-intuitively: if the “main clause” runs to completion, then the else-clause is executed. If the main clause terminates in an unusual way (eg via the <code>break</code> or <code>return</code> keyword, or an exception) then the else is not executed. This is actually quite useful.</p>

<p>The CPython interpreter can run in various modes:</p>

<ul>
  <li>“standard”</li>
  <li>
<code>-O</code> - discards asserts from the code</li>
  <li>
<code>-OO</code> - discards asserts and docstrings from the code</li>
</ul>

<p>Python has inbuilt support for the “assert” keyword.</p>

<p>Function <code>id(obj)</code> returns a unique identifier for each object (based on its address in memory).</p>

<p>Two adjacent strings are automatically concatenated. This is useful when a long string literal needs to be split across multiple lines, and the triple-quote format is for some reason not desired.</p>

<p>Python does not support “function overloading”, ie treating two methods with the same name but different signatures as different methods. Python’s positional-args, keyword-args, and default values for params allows a lot of flexibility that in most cases makes “function overloading” unnecessary. Decorator <code>@functools.singledispatch</code> does provide a way to do basic function-overloading if you really want it.</p>

<p>It is possible to put multiple Python statements on the same line by separating them with semicolons, eg: <code>msg="hello"; print(msg, "world")</code>. All statements are considered to be “in the same suite”, ie effectively at the same indentation.</p>

<p>Module <code>array</code> provides methods for storing arrays of objects in a more memory-dense format than a Python list.</p>

<p>Python has no switch/case statement - use a chain of <code>if .. elif .. elif .. else</code> instead.</p>

<p>All functions return a value; “falling off the end of a function” effectively returns None. There is no explicit check that every path in a function returns the same datatype.</p>

<p>Python <a href="http://neopythonic.blogspot.com/2009/04/final-words-on-tail-calls.html">does not support Tail Call Optimisation</a>.</p>

<h1 id="references">References</h1>

<ul>
  <li>
<a href="https://docs.python.org/3/reference">The Python Language Reference</a> – the official language specification</li>
  <li><a href="https://realpython.com/python-modules-packages/">Real Python: modules and packages</a></li>
  <li><a href="https://packaging.python.org/">Python Packaging</a></li>
  <li><a href="https://stackoverflow.com/questions/13784713/what-good-are-python-function-annotations">StackOverflow: What Good are Python Function Annotations?</a></li>
  <li>
<a href="https://www.python.org/dev/peps/pep-0008/">PEP 8: Style Guide for Python</a> - also contains some good “best practice” hints</li>
  <li><a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python">Stackoverflow: what are metaclasses in Python?</a></li>
  <li>Fluent Python, Ramalho, O’Reilly, 2015 - good coverage of moderately advanced topics such as <code>abc</code>, coroutines (yield-based) and asyncio (all discussed above)</li>
</ul>

<h1 id="footnotes">Footnotes</h1>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:exceptions" role="doc-endnote">
      <p>Python tends to use exceptions for “flow control” as well as error-signalling, something that other languages warn against. As an example, iterator implementation throw an exception to terminate iteration. <a href="#fnref:exceptions" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:initopt" role="doc-endnote">
      <p>For Python versions earlier than 3.4, the <code>__init__.py</code> file is mandatory for packages; from v3.4 onwards it is optional. <a href="#fnref:initopt" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:nodict" role="doc-endnote">
      <p>Instances of types like <code>int</code> and <code>float</code> do not have a <code>__dict__</code>, instead embedding the value directly into their in-memory struct. Type like <code>str</code> also does not have a <code>__dict__</code>, although the actual string data is not in-line. <a href="#fnref:nodict" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:noduck" role="doc-endnote">
      <p>Although Python promotes “duck typing” over “static typing”, the fact that the standard libraries are full of <em>isinstance</em> checks perhaps shows that static types are not so useless after all.. <a href="#fnref:noduck" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

    </article>
  </div>
    
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'mineofinformation'; // mineofinformation (disqus site id)
      var disqus_pageid = '/programming/python/'; // /relative/path/to/article/dir

      var disqus_config = function () {
        this.page.identifier = disqus_pageid;
        this.page.url = 'https://moi.vonos.net' + disqus_pageid;
      };
      (function() {
        var d = document, s = d.createElement('script');
        s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  



      </section>
    </div>
    <section id="footer">
      <p>Copyright &copy; 2025 - Simon Kitching</p>
    </section>
  </body>
</html>

