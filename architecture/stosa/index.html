<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Mine of Information - STOSA Architecture at willhaben</title>
    <link rel="stylesheet" type="text/css" href="/assets/css/coderay.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/stylesheet.css">
    <link type="application/atom+xml" title="Mine of Information" rel="alternate" href="/atom.xml"> 

    <meta name="generator" content="nanoc 4.12.15"> 
    <meta name="author" content="Simon Kitching"> 
  </head>
  <body>
    <section id="header">
      <span class='title'>The Mine of Information</span> <span class='desc'>(Nuggets of Programming and Linux)</span>
    </section>
    <div id="main">
      <section id='navpane'>
        <section>
  <ul id="navicons">
      <li class="nav">
      <a href="/" title="Home"><img src="/assets/images/Home.png"></a>
      <a href="/archives/" title="Archives"><img src="/assets/images/Calendar.png"></a>
      <a href="/site/welcome" title="E-Mail"><img src="/assets/images/Envelope.png"></a>
      <a href="/atom.xml" title="Subscribe Feed"><img src="/assets/images/RSS.png"></a>
      </li>
  </ul>
</section>

<section>
  <h1>About</h1>
  <ul id="about">
    <li>
      <a href="/site/welcome">Welcome</a>
    </li>
  </ul>
</section>

<section>
<h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2023/12/monorepos/">Monorepos and Polyrepos</a>
      </li>
    
      <li class="post">
        <a href="/2023/12/httpapis/">HTTP APIs, REST APIs, and Others</a>
      </li>
    
      <li class="post">
        <a href="/2023/09/biden/">Biden on Democracy</a>
      </li>
    
      <li class="post">
        <a href="/2023/09/tech-breadth/">Maintaining Technical Depth</a>
      </li>
    
      <li class="post">
        <a href="/2023/08/vpns/">The Uselessness of Consumer VPNs</a>
      </li>
    
      <li class="post">
        <a href="/2023/06/microservices/">Some Aspects of Implementing Microservices..</a>
      </li>
    
      <li class="post">
        <a href="/2023/06/dtest-evolution-scrum-monad/">DDD, Architecture patterns, and More..</a>
      </li>
    
      <li class="post">
        <a href="/2023/05/testing/">Should Unit Tests Verify Requirements Only?</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Categories</h1>
  <ul id="categories">
    
      <li class="catlink">
        <a href='/category/Architecture/'>Architecture</a>
      </li>
    
      <li class="catlink">
        <a href='/category/BigData/'>BigData</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Cloud/'>Cloud</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Cryptography/'>Cryptography</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Git/'>Git</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Infrastructure/'>Infrastructure</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Java/'>Java</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Links/'>Links</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Linux/'>Linux</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Network/'>Network</a>
      </li>
    
      <li class="catlink">
        <a href='/category/OSGi/'>OSGi</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Off-topic/'>Off-topic</a>
      </li>
    
      <li class="catlink">
        <a href='/category/OpenWRT/'>OpenWRT</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Programming/'>Programming</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Security/'>Security</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Site/'>Site</a>
      </li>
    
  </ul>
</section>


      </section>
  
      <section id='content'>
        
  <div class='page'>
    <h1>STOSA Architecture at willhaben</h1>
    <aside>First published on: June 22, 2023</aside>
    
    <article>
    <p>Categories: <a href='/category/Architecture/'>Architecture</a></p>
      
<h1 id="why-and-what">Why and What</h1>

<p>As with any other company, we at <a href="https://www.willhaben.at">willhaben</a> want to enable software teams to produce quality results fast and with low cost. This is in the interest of both the company and IT staff — who wants to produce low-quality software slowly?</p>

<p>This goal is a never-ending process of improvements, and we’re on the journey, not at the end. But we’re doing pretty well. And we rely not just one tool, but a big box of tools. One of the tools we use is to follow <a href="https://stosa.org/">STOSA — Single Team Oriented Service Architecture</a>.</p>

<p>STOSA is a pattern that is mostly about project management and team structure, but it does also have consequences for software technical details. It is related to the <a href="https://piotr-nowinski.pl/inverse-conway-maneuver/">Inverse Conway Maneuver</a> — restructure your teams, and your architecture will follow. We applied this successfully (and really should write a blog article about our experience!).</p>

<p>STOSA is not particularly complicated; the referenced article can be read in 10 minutes. And it is not particularly surprising; many of its recommendations are “mainstream” ideas. However taken together, these ideas can boost productivity.</p>

<p>What this means specifically for willhaben is:</p>

<ul>
  <li>grouping the majority of our IT staff into <em>tribes</em> — cross-functional teams who develop, maintain, deploy, and run specific features</li>
  <li>building software systems as distributed services whose code-bases are each small enough and specific enough to belong to a single tribe</li>
</ul>

<p>Note that willhaben is a company that produces software for its own use, driving its online services. We can release software whenever we wish (and do so frequently). This is quite different from companies who provide software for others. And (occasional) errors can be tolerated; we don’t like user-visible problems in our services but producing software fast with occasional mistakes is still better than producing perfect software slowly and expensively. Nobody’s life depends on our services. Together these aspects mean that a distributed system works well for us, without excessive costs.</p>

<p>This approach is similar to what is called the “Spotify Model”, and Spotify themselves point out that they use this pattern to “optimise for innovation”. This is important to them because they are in a very competitive market and their competition is evolving rapidly in terms of services offered to customers so they need to do so too; rapid development (innovation) is therefore valued over system reliability or cost-effectiveness. As willhaben happens to be in a similar situation (at a smaller scale), this approach works well for us too. For companies who have limited budgets, have high reliability requirements, are working in a slower-moving business environment, or multiple of these factors together, then this might not apply so well. A company building software for nuclear reactors will have other values and may choose a different approach.</p>

<h1 id="organisational-aspects">Organisational Aspects</h1>

<p>Cross-functional means each tribe contains business-domain experts, mobile-app devs, web devs, back-end devs, SREs (sysadmins), and <a href="https://en.wikipedia.org/wiki/Quality_assurance">QA</a>. For many change-requests the entire task can be done by a single tribe, from requirements to rollout, without needing any meetings with other tribes or teams. This gets rid of a lot of time-consuming tasks — meeting agendas, scheduling problems, priority discussions, waiting for someone else to do their part — or worse, waiting for approval for some step. Of course discussions are needed, but they are primarily internal to the tribe — and the tribe is a small group of people who know each other well and have the same priorities. Answers to a question can often be obtained without leaving the tribe’s workroom — and often without needing to get out of a chair.</p>

<p>Where possible, tribes are responsible for <em>user facing functionality</em> from UI to database, ie vertical slices of behaviour rather than horizontal layers. This reduces the number of interactions needed between teams; any time teams have an upstream/downstream relationship then additional coupling occurs. This is effectively assigning “use cases” to tribes and is sometimes called <a href="https://www.youtube.com/watch?v=haejb5rzKsM">value stream aligned teams</a> or “customer journey oriented teams”. In some ways, each tribe somewhat resembles a separate startup company with its own customer market and customer-facing product.</p>

<p>There are of course projects that cross tribe boundaries, and require more formal coordination, including specifications and timelines. However making these the exception rather than the normal case helps productivity significantly.</p>

<p>As Rebecca Parsons pointed out (paraphrased by me), “horizontally partitioned systems protect against technical change, vertically partitioned systems protect against business change”.</p>

<p>In addition to tribes, there is a set of “supporting teams” who take care of things that are not related to any specific feature — eg providing the infrastructure for our production and development environments, providing test-automation frameworks and advice, supporting agile development practices, or dealing with cross-tribe issues such as security and overall architecture. However the number of people in these roles is kept as small as possible — it’s the tribes who do the work that really earns money!</p>

<h1 id="domain-driven-design-ddd">Domain Driven Design (DDD)</h1>

<p>Much of our work is influenced by the well-known and widely-used ideas of DDD. In particular, each tribe <em>owns</em> one or more domains<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> — coherent sets of functionality. This is important for achieving a good hit-rate for the goal “change requests don’t cross tribe boundaries”. We’ve identified 14 primary domains, and currently have 4 tribes each of which is responsible for several domains. Having more than one domain per tribe allows responsibility to potentially be moved between tribes if the workload becomes unbalanced for any tribe. Or to create an additional tribe if workload justifies it, without needing to split a domain.</p>

<h1 id="technical-aspects">Technical Aspects</h1>

<h2 id="ownership-and-autonomy">Ownership and Autonomy</h2>

<p>Making it possible for a tribe to minimise external coordination requires software to be “owned” by a single tribe. Each deployable unit of software (“component”) ideally has an independent code-base (a separate Git repo in our case), and its own deployment pipeline, so that the owning tribe can change code and release the changes into production without coordination. We call this code-ownership and authority to change and deploy code <em>tribe autonomy</em>.</p>

<p>Autonomy isn’t an absolute law; the end goal is to increase company profits via high software productivity and ownership/autonomy are just tools to achieve that. However ownership is a core concept of STOSA and brings multiple benefits:</p>

<ul>
  <li>better maintainability — developers who feel they “own” code take more care with it</li>
  <li>better stability — a team who have to deal with production issues will build better diagnostics and test-suites</li>
  <li>better bug-resolution — when an issue arises, it is clearer who is the expert and who will feel responsible</li>
</ul>

<p>To balance ownership and openness to other tribes, all source-code is visible to all developers and pull-requests from outside of the owning group are encouraged. Making this process easy requires support from the owning team (good docs, etc) — something we call “internal open source”. Doing this right is a continual process, however, and we’re just starting here. Maybe we can write an article on our experiences here in the near future.</p>

<h1 id="front-end-components">Front-End Components</h1>

<p>For front-end software, we haven’t yet found full solutions for tribe autonomy with regards to software releases. We do structure app and web codebases in a modular way, with modules being aligned with domains i.e. tribe responsibilities. However releases still involve “the whole cross-tribe codebase” and therefore (sometimes) require cross-tribe coordination.</p>

<p>Obviously, mobile apps are released as monoliths by their very nature. We are currently looking into “server-driven UI” concepts, in which server-side code (which we can deploy at any time) serves up templates, validation rules, and other similar data which is then processed by some kind of interpreter built in to the client application, allowing new functionality to be provided to users without updating the client. There are of course limits to this (a web browser is the ultimate form of this, and server-driven UI shouldn’t lead to a bad reimplementation of one) but something in this direction may be useful to support the concepts of STOSA.</p>

<p>There are <a href="https://codeburst.io/4-practical-ways-to-build-micro-frontends-4dc4f0b8a921">various proposals</a> for web micro-front-ends (built from multiple independently-deployed processes while still looking like one site to the user). For our primary web front-end we are currently using the “fragment integration style” which preserves ownership but deploys as a single artifact. While perhaps not 100% “STOSA compliant” we do manage multiple releases per day of this application.</p>

<p>STOSA’s technical impact is (at least for us) most applicable to “back end components”, ie deployable artifacts that offer APIs rather than interfaces, and which own some set of data. The remainder of this chapter talks specifically about these.</p>

<h1 id="back-end-components">Back-end Components</h1>

<h2 id="right-sized-micro-services">Right-sized Micro-services</h2>

<p>For back-end components, the above requirement for independent code-base and independent deployment leads naturally to a micro-service architecture. However at willhaben we focus more on the <em>service</em> than the <em>micro</em>. As long as a component is small enough to belong to a single tribe, that’s sufficient. And in practice, the “back end code” for each domain is usually implemented as a single component. Truly fine-grained components do have some advantages, but also have a lot of issues associated with them, and so we are avoiding these (at least for now). This cautious approach to microservices also appears to be the mainstream consensus at the current time.</p>

<h2 id="testing-and-api-compatibility">Testing and API Compatibility</h2>

<p>Tests for each component need to be as independent of other components as possible; requiring execution of a full system integration test suite before release of any component would be a major hurdle to rapid releases and cost-effective software. As noted above, nobody’s life depends on us, and so testing should be good but doesn’t need to be perfect.</p>

<p>However as components interact, API compatibility needs to be managed carefully; each component must provide backwards-compatible interfaces until all interacting components have been updated. And as we strongly discourage tribes forcing deadlines for work onto other tribes, such backwards-compatibility needs to be long-term.</p>

<p>This API compatibility management (given no full system integration test suite run before each release) is a tricky issue. And honestly, one with which we are still struggling. We use contract-tests with <a href="https://docs.pact.io/">PACT</a>, but not as extensively as we would like, and intend to investigate other options in the future. For now, relying on developers to “be careful” with API changes is our primary mechanism.</p>

<p>Testing a distributed system (as compared to a monolith) is significantly more complicated (as we experienced). This alone justifies the growing consensus that there is nothing wrong with a monolithic IT system if it fits your requirements. We’ve outgrown that phase; our rate of software development, frequency of release, and plain number of people working on our code-base, is just too high to make a monolith practical. However the complexity (and therefore cost) of a distributed system (with testing being an important issue) are significant!</p>

<p>In short: in a microservice architecture with multiple releases per day (of various components), it is an illusion that it is possible to create a realistic replica of the production environment. We are therefore currently moving from our traditional testing approach to <a href="/architecture/testing-distributed-systems">something more distributed-system-compatible</a>.</p>

<h2 id="data-storage">Data Storage</h2>

<p>STOSA recommends that each back-end component has its own database, and we follow this strictly, for multiple very good reasons:</p>

<ul>
  <li>independent releases</li>
  <li>security</li>
  <li>performance impact</li>
</ul>

<p>When one component reaches into another component’s database to read data, then this impacts the ability of each to make changes to the schema of that database. Meetings are required to agree on changes, and release-schedules potentially need to be synchronized. This brings back exactly the issues that STOSA tries to resolve.</p>

<p>Having one component write into another’s database is worse; enforcing data consistency rules then becomes very difficult.</p>

<p>Partitioning data across multiple databases increases security; a vulnerability in one component only exposes the data that that particular component has available — which is hopefully a small subset of the full dataset.</p>

<p>And separating databases means that performance issues in one component (eg missing indices on a relational table) cannot affect the performance of a component owned by a different tribe.</p>

<p>One problem that separation of databases brings is the need to access data owned by a different component/domain. There are two general solutions to this:</p>

<ul>
  <li>use synchronous calls between domains to obtain data as needed</li>
  <li>replicate data asynchronously</li>
</ul>

<p>Both solutions are widely used — though the first is probably more common than the second. And each approach has its advantages and disadvantages.</p>

<p>Systems based on synchronous calls between “microservices”:</p>

<ul>
  <li>are obvious to build (developers are familiar with such calls)</li>
  <li>don’t need to deal with eventual consistency issues (synchronous data read requests always return recent data)</li>
  <li>have efficient data storage (each data item is stored only once)</li>
</ul>

<p>However such systems also:</p>

<ul>
  <li>can have complex nets of synchronous calls which make it hard to understand dependencies</li>
  <li>need to put lots of effort into interface compatibility</li>
  <li>have complicated failure-modes</li>
  <li>are IO-intensive</li>
  <li>can have performance issues (“chatty APIs”)</li>
  <li>have more potential security issues (each API can be abused, simple firewalling cannot be used between services)</li>
  <li>are difficult to scale appropriately</li>
  <li>can have startup ordering problems</li>
  <li>can lead to development being “blocked” by missing APIs (one tribe’s work requires a new API from another tribe)</li>
  <li>really need distributed-tracing support</li>
  <li>are difficult to test (testing requires interactions with other systems)</li>
</ul>

<p>The “replication” approach has additional up-front complexity but resolves many of the above problems. Given the (relatively high) volume of traffic that willhaben carries, our relatively small development team, and our intention to be in business long-term, we are therefore currently applying the “replication” approach — called “Event-carried State Transfer” (also known internally here as <a href="/architecture/distributed-read-models-part1">distributed read models</a>).</p>

<p>The most important concept related to data storage is: each piece of data has exactly ONE owner, and only the owner may change that data. That owner is the “source of truth” for that data; other systems may potentially have copies of it, but must never modify that copy.</p>

<h1 id="legacy-systems">Legacy Systems</h1>

<p>We do of course have some legacy systems that don’t follow the STOSA principles, ie are too big to belong to a tribe and/or cross DDD domain boundaries. However we’re working on that, and expect within the next few years that all our software components have just one owner, ie are completely compatible with STOSA.</p>

<h1 id="pre-requisites">Pre-requisites</h1>

<p>If you are looking at applying this yourself, there are a few abilities that a company needs first:</p>

<ul>
  <li>you need to be providing an online service; shipping “packaged software” isn’t a good match for this pattern</li>
  <li>good automated deployment pipelines</li>
  <li>a good monitoring/alerting system</li>
  <li>good API compatibility testing (ideally)</li>
  <li>an IT team of at least 30 people (below that, the overhead is not worth it)</li>
</ul>

<h1 id="the-negatives-of-stosa">The Negatives of STOSA</h1>

<p>We’ve of course noticed a few problems as a result of adopting this pattern:</p>

<ul>
  <li>ownership can lead to a “your problem, not mine” attitude</li>
  <li>ownership can lead to a “keep your hands off my code” attitude</li>
  <li>uneven workloads for tribes can occur</li>
  <li>inter-tribe communication can suffer</li>
  <li>knowledge-sharing with staff of the same “skillset” can suffer</li>
  <li>more frequent integration issues (as noted earlier)</li>
</ul>

<p>We use the following strategies to deal with some of the above:</p>

<ul>
  <li>“chapters” — regular meetings, presentations, and support-channels for specific skillsets (eg iOS devs, or QA)</li>
  <li>emphasise T-shaped skillsets (staff have a primary role, but also actively use/learn an additional role)</li>
  <li>emphasise consistent toolsets and frameworks (tech radar etc)</li>
  <li>tools for verifying api compatibility</li>
  <li>good devops practices (good monitoring, good support for rollbacks, etc)</li>
  <li>regular cross-tribe presentations</li>
  <li>whole-company community-building events</li>
</ul>

<p>And STOSA requires building software as a “distributed system” which brings significant technical complexity. Below a certain scale, a monolithic application can well be a better solution — in which case STOSA does not apply.</p>

<h1 id="summary">Summary</h1>

<p>Given that the STOSA overview is only a 10-minute read, it has quite an impact on how we develop software. Well, actually we discovered the STOSA definition long after we had made similar decisions, but the article brings the ideas together nicely.</p>

<p>As described above, it influences:</p>

<ul>
  <li>Tribe and team structure</li>
  <li>Personal communication patterns</li>
  <li>Version control decisions</li>
  <li>CI/CD pipelines</li>
  <li>Responsibility for production issues (owning tribe)</li>
  <li>Modularity of mobile-app and web-ui code</li>
  <li>Size of “domains” in our DDD analysis of the company featureset</li>
  <li>Integration-testing approaches</li>
  <li>API-compatibility verification</li>
  <li>Component interaction patterns</li>
  <li>Data storage and replication</li>
</ul>

<p>Getting all of this organised has been a lot of work, and it’s not done yet. However, given the size of our IT department, we’re producing some excellent <a href="https://devcycle.com/blog/the-ultimate-guide-to-dora-metrics">DORA (aka Accelerate) metrics</a> (DF/LTC/CFR/MTTR) and this STOSA approach can take at least some of the credit.</p>

<p>And importantly, we’re generally happy with it. Developer satisfaction is high and we have multiple releases into production every day which everyone (business and tech) enjoys. There are of course always differing opinions, and it’s hard to know whether other approaches would be better or worse. It will be interesting to see 10 years from now how this looks, but for now it’s looking like a pretty good way to deliver IT value.</p>

<h1 id="change-history">Change History</h1>

<p>This article was written by myself while an employee of <a href="https://www.willhaben.at">willhaben</a>, and originally published on Medium (with link from the company website) in February 2023. Minor updates were made in June 2023.</p>

<h1 id="footnotes">Footnotes</h1>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Possibly the word “subdomain” could be used here - but domain is just easier to write. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

    </article>
  </div>
    
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'mineofinformation'; // mineofinformation (disqus site id)
      var disqus_pageid = '/architecture/stosa/'; // /relative/path/to/article/dir

      var disqus_config = function () {
        this.page.identifier = disqus_pageid;
        this.page.url = 'https://moi.vonos.net' + disqus_pageid;
      };
      (function() {
        var d = document, s = d.createElement('script');
        s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  



      </section>
    </div>
    <section id="footer">
      <p>Copyright &copy; 2025 - Simon Kitching</p>
    </section>
  </body>
</html>

