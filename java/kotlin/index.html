<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Mine of Information - Notes on Kotlin for Java Programmers</title>
    <link rel="stylesheet" type="text/css" href="/assets/css/coderay.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/stylesheet.css">
    <link type="application/atom+xml" title="Mine of Information" rel="alternate" href="/atom.xml"> 

    <meta name="generator" content="nanoc 4.12.15"> 
    <meta name="author" content="Simon Kitching"> 
  </head>
  <body>
    <section id="header">
      <span class='title'>The Mine of Information</span> <span class='desc'>(Nuggets of Programming and Linux)</span>
    </section>
    <div id="main">
      <section id='navpane'>
        <section>
  <ul id="navicons">
      <li class="nav">
      <a href="/" title="Home"><img src="/assets/images/Home.png"></a>
      <a href="/archives/" title="Archives"><img src="/assets/images/Calendar.png"></a>
      <a href="/site/welcome" title="E-Mail"><img src="/assets/images/Envelope.png"></a>
      <a href="/atom.xml" title="Subscribe Feed"><img src="/assets/images/RSS.png"></a>
      </li>
  </ul>
</section>

<section>
  <h1>About</h1>
  <ul id="about">
    <li>
      <a href="/site/welcome">Welcome</a>
    </li>
  </ul>
</section>

<section>
<h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2023/12/monorepos/">Monorepos and Polyrepos</a>
      </li>
    
      <li class="post">
        <a href="/2023/12/httpapis/">HTTP APIs, REST APIs, and Others</a>
      </li>
    
      <li class="post">
        <a href="/2023/09/biden/">Biden on Democracy</a>
      </li>
    
      <li class="post">
        <a href="/2023/09/tech-breadth/">Maintaining Technical Depth</a>
      </li>
    
      <li class="post">
        <a href="/2023/08/vpns/">The Uselessness of Consumer VPNs</a>
      </li>
    
      <li class="post">
        <a href="/2023/06/microservices/">Some Aspects of Implementing Microservices..</a>
      </li>
    
      <li class="post">
        <a href="/2023/06/dtest-evolution-scrum-monad/">DDD, Architecture patterns, and More..</a>
      </li>
    
      <li class="post">
        <a href="/2023/05/testing/">Should Unit Tests Verify Requirements Only?</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Categories</h1>
  <ul id="categories">
    
      <li class="catlink">
        <a href='/category/Architecture/'>Architecture</a>
      </li>
    
      <li class="catlink">
        <a href='/category/BigData/'>BigData</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Cloud/'>Cloud</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Cryptography/'>Cryptography</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Git/'>Git</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Infrastructure/'>Infrastructure</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Java/'>Java</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Links/'>Links</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Linux/'>Linux</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Network/'>Network</a>
      </li>
    
      <li class="catlink">
        <a href='/category/OSGi/'>OSGi</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Off-topic/'>Off-topic</a>
      </li>
    
      <li class="catlink">
        <a href='/category/OpenWRT/'>OpenWRT</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Programming/'>Programming</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Security/'>Security</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Site/'>Site</a>
      </li>
    
  </ul>
</section>


      </section>
  
      <section id='content'>
        
  <div class='page'>
    <h1>Notes on Kotlin for Java Programmers</h1>
    <aside>First published on: December 8, 2019</aside>
    
    <article>
    <p>Categories: <a href='/category/Java/'>Java</a></p>
      
<h1 class="no_toc" id="about-this-article">About this Article</h1>

<p>I am an experienced Java developer, have done <a href="/java/scala">a little Scala development</a>, and am now learning Kotlin. These are some brief notes about the primary similarities and differences between Java, Scala and Kotlin.</p>

<p>This article is <em>not</em> a tutorial on Kotlin; instead it presents Kotlin in comparison to Java.</p>

<p>There is nothing original here; it is mostly taken from the excellent <a href="https://kotlinlang.org/docs/reference/">Kotlin reference docs</a> and just summarized. Where the details are complicated, the original reference docs are the best source of info.</p>

<p>Important! There are far better ways to learn Kotlin than reading this page; these notes are really only for my own use. Depending on your learning style, I would recommend:</p>

<ul>
  <li>the <a href="https://kotlinlang.org/docs/kotlin-docs.pdf">Language Reference PDF</a> - see section “Getting Started” for a terse but complete walkthrough of the language syntax</li>
  <li>the <a href="https://kotlinlang.org/docs/reference/">Official Learn Kotlin Page</a> - this is called a “Reference”, but is actually just the “highlights” of the language</li>
  <li>the <a href="https://kotlinlang.org/docs/tutorials/koans.html">Kotlin Koans</a> - learn by example</li>
</ul>

<p>Reading the language reference suited my style of learning best; it presents the whole Kotlin language feature by feature in a reasonable order. This does assume you’re fluent in similar languages - but so does this article. The “Learn Kotlin” page covers only the highlights, while the Koans approach is very different: learning by doing.</p>

<h1 class="no_toc" id="table-of-contents">Table of Contents</h1>

<ul id="markdown-toc">
  <li><a href="#overview" id="markdown-toc-overview">Overview</a></li>
  <li><a href="#language-evolution" id="markdown-toc-language-evolution">Language Evolution</a></li>
  <li><a href="#installing-kotlin" id="markdown-toc-installing-kotlin">Installing Kotlin</a></li>
  <li>
<a href="#basics" id="markdown-toc-basics">Basics</a>    <ul>
      <li><a href="#compiled-form" id="markdown-toc-compiled-form">Compiled Form</a></li>
      <li><a href="#kotlin-as-scripting-language" id="markdown-toc-kotlin-as-scripting-language">Kotlin as Scripting Language</a></li>
      <li><a href="#directory-structure" id="markdown-toc-directory-structure">Directory Structure</a></li>
      <li><a href="#core-syntax-and-simple-differences" id="markdown-toc-core-syntax-and-simple-differences">Core Syntax and Simple Differences</a></li>
      <li><a href="#javadoc" id="markdown-toc-javadoc">Javadoc</a></li>
      <li><a href="#local-variable-declarations" id="markdown-toc-local-variable-declarations">Local Variable Declarations</a></li>
      <li><a href="#operator-overloading" id="markdown-toc-operator-overloading">Operator Overloading</a></li>
      <li><a href="#nulls" id="markdown-toc-nulls">Nulls</a></li>
      <li><a href="#lambdas" id="markdown-toc-lambdas">Lambdas</a></li>
      <li><a href="#scope-functions" id="markdown-toc-scope-functions">Scope Functions</a></li>
      <li><a href="#type-casts" id="markdown-toc-type-casts">Type Casts</a></li>
      <li><a href="#exceptions" id="markdown-toc-exceptions">Exceptions</a></li>
      <li><a href="#for-loops" id="markdown-toc-for-loops">For-loops</a></li>
      <li><a href="#when-expressions" id="markdown-toc-when-expressions">When-expressions</a></li>
      <li><a href="#string-templates-and-raw-strings" id="markdown-toc-string-templates-and-raw-strings">String Templates and Raw Strings</a></li>
      <li><a href="#map-access" id="markdown-toc-map-access">Map Access</a></li>
      <li><a href="#access-control" id="markdown-toc-access-control">Access Control</a></li>
      <li><a href="#function-declarations" id="markdown-toc-function-declarations">Function Declarations</a></li>
      <li><a href="#higher-order-functions-and-function-types" id="markdown-toc-higher-order-functions-and-function-types">Higher Order Functions and Function Types</a></li>
      <li><a href="#generics" id="markdown-toc-generics">Generics</a></li>
      <li><a href="#packages-and-imports" id="markdown-toc-packages-and-imports">Packages and imports</a></li>
      <li><a href="#top-level-declarations" id="markdown-toc-top-level-declarations">Top-Level Declarations</a></li>
      <li><a href="#destructuring-declarations" id="markdown-toc-destructuring-declarations">Destructuring Declarations</a></li>
      <li><a href="#extension-functions" id="markdown-toc-extension-functions">Extension Functions</a></li>
      <li><a href="#the-use-function" id="markdown-toc-the-use-function">The Use Function</a></li>
      <li><a href="#annotations" id="markdown-toc-annotations">Annotations</a></li>
      <li><a href="#varargs-parameters" id="markdown-toc-varargs-parameters">Varargs Parameters</a></li>
    </ul>
  </li>
  <li>
<a href="#classes" id="markdown-toc-classes">Classes</a>    <ul>
      <li><a href="#simple-class-declarations" id="markdown-toc-simple-class-declarations">Simple Class Declarations</a></li>
      <li><a href="#class-properties" id="markdown-toc-class-properties">Class Properties</a></li>
      <li><a href="#data-classes" id="markdown-toc-data-classes">Data Classes</a></li>
      <li><a href="#sealed-classes" id="markdown-toc-sealed-classes">Sealed Classes</a></li>
      <li><a href="#object-declarations" id="markdown-toc-object-declarations">Object Declarations</a></li>
      <li><a href="#companion-objects" id="markdown-toc-companion-objects">Companion Objects</a></li>
      <li><a href="#object-expressions-anonymous-objects" id="markdown-toc-object-expressions-anonymous-objects">Object Expressions (anonymous objects)</a></li>
      <li><a href="#delegation" id="markdown-toc-delegation">Delegation</a></li>
      <li><a href="#nested-classes" id="markdown-toc-nested-classes">Nested Classes</a></li>
    </ul>
  </li>
  <li><a href="#kotlin-libraries" id="markdown-toc-kotlin-libraries">Kotlin Libraries</a></li>
  <li><a href="#reflection" id="markdown-toc-reflection">Reflection</a></li>
  <li><a href="#builders" id="markdown-toc-builders">Builders</a></li>
  <li><a href="#coroutines" id="markdown-toc-coroutines">Coroutines</a></li>
  <li>
<a href="#minor-notes" id="markdown-toc-minor-notes">Minor notes</a>    <ul>
      <li><a href="#slf4j" id="markdown-toc-slf4j">SLF4J</a></li>
      <li><a href="#java-streams" id="markdown-toc-java-streams">Java Streams</a></li>
      <li><a href="#java-incompatibilities" id="markdown-toc-java-incompatibilities">Java Incompatibilities</a></li>
    </ul>
  </li>
  <li>
<a href="#kotlin-vs-scala" id="markdown-toc-kotlin-vs-scala">Kotlin vs Scala</a>    <ul>
      <li><a href="#tuples" id="markdown-toc-tuples">Tuples</a></li>
      <li><a href="#custom-operators" id="markdown-toc-custom-operators">Custom Operators</a></li>
      <li><a href="#powerful-generics" id="markdown-toc-powerful-generics">Powerful Generics</a></li>
      <li><a href="#pattern-matching-and-destructuring" id="markdown-toc-pattern-matching-and-destructuring">Pattern Matching and Destructuring</a></li>
      <li><a href="#implicit-conversions" id="markdown-toc-implicit-conversions">Implicit Conversions</a></li>
      <li><a href="#implicit-parameters" id="markdown-toc-implicit-parameters">Implicit Parameters</a></li>
      <li><a href="#mixins" id="markdown-toc-mixins">Mixins</a></li>
      <li><a href="#exception-handling-with-try" id="markdown-toc-exception-handling-with-try">Exception-handling with Try</a></li>
      <li><a href="#factory-methods-on-companion-objects" id="markdown-toc-factory-methods-on-companion-objects">Factory Methods on Companion Objects</a></li>
      <li><a href="#partial-function-application-and-currying" id="markdown-toc-partial-function-application-and-currying">Partial Function Application and Currying</a></li>
      <li><a href="#function-composition" id="markdown-toc-function-composition">Function Composition</a></li>
    </ul>
  </li>
  <li><a href="#build-systems" id="markdown-toc-build-systems">Build Systems</a></li>
  <li><a href="#conciseness" id="markdown-toc-conciseness">Conciseness</a></li>
  <li><a href="#useful-references" id="markdown-toc-useful-references">Useful References</a></li>
</ul>

<h1 id="overview">Overview</h1>

<p>There are five major languages that run on the JVM: Java/Scala/Kotlin (statically typed), and Clojure/Groovy (dynamically typed).</p>

<p>Kotlin sits between Java and Scala in complexity; it basically includes the 50% of Scala’s features that bring 90% of its benefits, while leaving out the features that make it difficult to use.</p>

<p>The result is a quite elegant language that is relatively easy to learn for experienced Java developers - and even easier for Scala users. It also compiles fast, and produces small binaries (no bigger than Java, and much smaller than Scala).</p>

<p>Kotlin borrows several features from <em>functional programming</em> languages, and can be used as one (particularly in combination with a library such as <a href="https://arrow-kt.io/">Arrow</a>) but there are some aspects of functional languages that it doesn’t support (eg no way to ensure a function is pure). IMO it is fair to say its focus is really on being a <em>better Java</em>.</p>

<h1 id="language-evolution">Language Evolution</h1>

<p>Suggestions for modifying the Kotlin language are tracked via <a href="https://github.com/Kotlin/KEEP">KEEP - the Kotlin Evolution and Enhancement Process</a>. This works similarly to <a href="https://www.python.org/dev/peps/">Python PEPs</a>.</p>

<p>Kotlin’s compiler and standard libraries are completely open-source. Its development is currently mostly driven by a team from Jetbrains (the makers of the Intellij IDEA IDE) but as Google recommend and support Kotlin as the primary development language for the Android OS, it is certain to be supported long-term even if Jetbrains lose interest.</p>

<h1 id="installing-kotlin">Installing Kotlin</h1>

<p>The easiest way to install is with <a href="https://kotlinlang.org/docs/tutorials/command-line.html">sdkman</a>, which installs Kotlin at user level.</p>

<p>Most Linux distros also have a Kotlin package in their standard package repositories.</p>

<h1 id="basics">Basics</h1>

<h2 id="compiled-form">Compiled Form</h2>

<p>Like Java, Kotlin is a strictly-typed compiled language. There are several supported “targets” when compiling:</p>

<ul>
  <li>JVM bytecode</li>
  <li>Android bytecode</li>
  <li>Javascript</li>
  <li>WebAssembly</li>
  <li>Native machinecode (eg x86 or ARM)</li>
</ul>

<p>When compiling Kotlin code to JVM bytecode, the results are very similar to class-files created from Java source-code and integration between classes generated by Kotlin and Java is very good (much better than Scala/Java). Even a single “module” can consist of a mix of Kotlin and Java code.</p>

<p>When compiled to Javascript, the output can be loaded into a web-browser for execution client-side, or into a server-side engine for a nodejs-like architecture. I don’t know much about this though, and am not sure how popular it is.</p>

<p>When complied to WebAssembly, the output can be run in any compatible browser, or run in a WebAssembly runtime on any platform (similar to a JVM).</p>

<h2 id="kotlin-as-scripting-language">Kotlin as Scripting Language</h2>

<p>It is possible to use Kotlin code for simple scripting tasks that might otherwise be done in Bash or Perl. Only a single file is supported, it does not have a package-declaration, and by convention it has suffix <code>.kts</code>. Scripts are run with:</p>

<ul>
  <li><code>kotlinc -script {filename} {args}</code></li>
</ul>

<h2 id="directory-structure">Directory Structure</h2>

<p>Like Java, Kotlin organises code into classes and packages.</p>

<p>Java is very strict about file and directory layout; each top-level class must be in a file whose name matches the classname. The directory structure must also match the package-structure.</p>

<p>Kotlin just sees a program as a bunch of files, each starting with a package-declaration followed by one or more class/object/function/property declarations (see later for more on these package-level items); it doesn’t care at all about the filenames or directory structure. A single file cannot declare multiple packages, but multiple files can contribute definitions to the same package.</p>

<p>Although the compiler supports a free-form directory structure, it is convention for Kotlin source to be stored in a directory-tree that follows the package hierarchy. However the top levels of the directory tree are typically omitted; in a typical maven project, directory <code>src/main/kotlin</code> thus directly contains files whose package-declaration is the “base” package for the project.</p>

<p>Files use the suffix “<code>.kt</code>”.</p>

<h2 id="core-syntax-and-simple-differences">Core Syntax and Simple Differences</h2>

<p>Kotlin naming conventions basically follows the Java rules for package, class, function, variable and constant names.</p>

<p>Single-line and block comments are like Java, except that block comments nest (making commenting-out code much easier). See later for info on function, class and package documentation.</p>

<p>Braces are generally used in the same way as with Java. The most significant syntactic difference is that semicolons are in general unnecessary (unless multiple statements are on the same line).</p>

<p>Keyword <code>new</code> is not used; instead the type-name acts as a factory-method: <code>foo = Foo()</code>.</p>

<p>Kotlin if-statements are similar to Java, but can also be used as expressions, for example: <code>val foo = if (true) a else b</code>.</p>

<p>The Kotlin language does not have “primitive types” (eg int, char); value types have methods like any other type. At runtime, the JVM primitive forms (on-stack rather than on-heap) are automatically used except when object-references are needed (eg when storing into a collection). The built-in value-types are:</p>

<ul>
  <li>Byte, Short, Int, Long, Float, Double, Char, Boolean.</li>
</ul>

<p>Arrays are normal objects of type Array (rather than being an odd primitive/object hybrid as in Java). They are declared like <code>ints : Array&lt;Int&gt;</code> and instantiated via <code>Array&lt;T&gt;(size, lambda)</code> or various functions such as <code>arrayOf(...)</code>. Array instances provide get and set methods in addition to <code>[]</code> access. They also provide method <code>size</code> and a few others. These arrays hold only objects; for an array of primitives there are special types (ByteArray, IntArray, etc).</p>

<p>Unlike Java, the Kotlin operator <code>==</code> is equivalent to method <code>.equals</code> (but null-safe). To check identity, use three chars: <code>===</code>.</p>

<p>Classes and interfaces work similarly to Java; the declaration syntax is somewhat different but recognisable. See later for more details.</p>

<p>Enums are roughly similar to Java. One of the few uses of semicolons in Kotlin is to terminate the comma-separated list of enum values; this is needed only when the enum type has methods or properties.</p>

<p>The base type for Kotlin objects is <code>Any</code> (roughly equivalent to Java’s Object).</p>

<p>Several keywords used by Java as class, method or member modifiers are instead provided by Kotlin as annotations from package <code>kotlin.jvm</code>. As is clear from the package-name, these annotations are only valid in code that is compiled to JVM bytecode (eg not available when compiling to Javascript):</p>

<ul>
  <li>Java <code>transient</code> is <code>@kotlin.jvm.Transient</code>
</li>
  <li>Java <code>volatile</code> is <code>@kotlin.jvm.Volatile</code>
</li>
  <li>Java <code>synchronized</code> modifier is <code>@kotlin.jvm.Synchronized</code> (and synchronized blocks are similar to Java: <code>synchronized(someobj) { ... }</code>).</li>
</ul>

<p>Reserved words can be used as normal names in Kotlin syntax by enclosing them in backticks. This is particularly useful when Kotlin code needs to call into Java code which uses a Kotlin keyword as a method-name. Example: foo.`in`(bar). Backticks can also be used to create function (or even variable) names that include spaces; this is however not recommended with one exception: unit test names are often descriptive strings with spaces in them.</p>

<p>Functions can be marked with modifier <code>tailrec</code>; if they are indeed tail-recursive then the recursion is rewritten to a loop.</p>

<h2 id="javadoc">Javadoc</h2>

<p>Instead of Javadoc, Kotlin uses “kdoc” format, which is somewhere between Javadoc and Markdown; see the reference-docs for details.</p>

<p>Kotlin provides application <a href="https://github.com/Kotlin/dokka">dokka</a> for gathering kdoc from all classes and building a site. For overall documentation on a whole “module” (maven or gradle project), a single markdown file is supported; the dokka plugin in your build definition must be configured with the name of this file (eg in the maven plugin config).</p>

<p>Sadly, Dokka does not support any kind of per-package documentation file (see <a href="https://discuss.kotlinlang.org/t/equivalent-of-package-info-java/3272/4">this discussion</a>). It also appears to ignore any kdoc placed against package-declarations; at least I found no way to get such documentation into the generated output files.</p>

<p>Dokka supports code-bases with a mix of Kotlin and Java files; it extracts Javadoc from Java files and includes it in the overall output. Sadly Dokka ignores <code>package-info.java</code> files.</p>

<p>In fact, dokka (version 0.10.0) is rather feature-poor and difficult to use, and its html output format just looks ugly; from my limited experience it is currently the weakest part of the Kotlin experience. However as an external project, it may improve.</p>

<h2 id="local-variable-declarations">Local Variable Declarations</h2>

<p>Variables are declared within functions using syntax <code>var|val {name} : {type} = {value}</code>.</p>

<p>Keyword <code>var</code> indicates the name is rebindable while <code>val</code> is like <code>final</code> in Java; the name is not rebindable. This does not imply that the referenced object is immutable.</p>

<p>A type-specification is optional when the type can be deduced from the initial value (type inference).</p>

<p>The value is required unless the declaration is an abstract property declaration (see later for information on class properties).</p>

<p>A question-mark following the type-specification indicates that the variable is nullable; see later for more details.</p>

<p>Note that <code>var</code> or <code>val</code> used within a class-body or primary-constructor-parameter-list or at file-level does not declare a variable but instead declares a  <em>property</em>; see later for more information.</p>

<h2 id="operator-overloading">Operator Overloading</h2>

<p>Kotlin supports a basic form of operator-overloading, ie functions with names that are from a small set of traditionally built-in operator chars. In general, operators are equivalent to a specific function-name which can be overridden, eg:</p>

<p>Simple cases:</p>

<ul>
  <li>
<code>!a</code> is transformed to <code>a.not()</code>
</li>
  <li>
<code>a + b</code> is transformed to <code>a.plus(b)</code>
</li>
  <li>
<code>a in b</code> is transformed to <code>b.contains(a)</code>
</li>
  <li>
<code>a += b</code> is transformed to <code>a.plusAssign(b)</code>
</li>
  <li>
<code>a &gt; b</code> is transformed to <code>a.compareTo(b) &gt; 0</code> where the compareTo function must return an integer</li>
</ul>

<p>Self-modification cases:</p>

<ul>
  <li>
<code>++a</code> is transformed to <code>{a = a.inc(); return a}</code>
</li>
  <li>
<code>a++</code> is transformed to <code>{tmp = a; a = a.inc(); return tmp}</code>
</li>
</ul>

<p>Also:</p>

<ul>
  <li>
<code>a[i]</code> is transformed to <code>a.get(i)</code>
</li>
  <li>
<code>a[i] = b</code> is transformed to <code>a.set(i, b)</code>
</li>
  <li>
<code>a(i)</code> is transformed to <code>a.invoke(i)</code>
</li>
</ul>

<p>The declaration of such methods must be marked with keyword <code>operator</code>, eg <code>operator fun not() ..</code>.</p>

<p>The <code>invoke</code> function can be particularly useful; it makes it possible for any object to act as a function, just by implementing that method. An object with such a method is called a ‘function object’. In fact, that is exactly what a lambda is: an object with an invoke-function whose signature is the param-list of the lambda and whose body is the body of the lambda. A reference to a method of an existing object is also a function object: <code>val foo = SomeType::someMethod</code> (unbound) or <code>val bar = someInstance::someMethod</code> (bound).</p>

<h2 id="nulls">Nulls</h2>

<p>A variable of a specific type cannot be assigned the value <code>null</code> unless it is declared with <code>:T?</code>, ie the variable has type “T or null”.</p>

<p>The <code>?</code> suffix can be considered equivalent to Java’s <code>Optional&lt;T&gt;</code>.</p>

<p>After an <code>if (var != null)</code> the compiler treats the variable as effectively non-nullable (ie definitely-not-null).</p>

<p>There are a few null-aware operators that make code much shorter:</p>

<ul>
  <li>Expression <code>val result = x ?: expr</code> is a convenient shorthand for <code>result = if (x != null) x else expr</code>
</li>
  <li>Expression <code>val result = x ?.somemethod()</code> is short for <code>result = if (x == null) null else x.somemethod(..)</code>
</li>
</ul>

<p>These operators are similar to Java’s Optional class. For example:</p>

<ul>
  <li>
<code>x?:1</code> is like <code>Optional.ofNullable(x).getOrElse(1)</code>
</li>
  <li>
<code>x?.method()</code> is like <code>Optional.ofNullable(x).map(X::method)</code>
</li>
  <li>
<code>x?.let {..}</code> is like <code>Optional.ofNullable(x).map({..})</code>
</li>
</ul>

<p>Operator <code>!!</code> converts a variable of nullable type to a non-nullable, with possible NullPointerException:</p>

<pre><code>val foo : Int? = 1
val bar : Int? = null

var r0 : Int = foo    // does not compile
var r1 : Int = foo!!  // succeeds because foo is not null
var r2 : Int = bar!!  // throws NullPointerException
</code></pre>

<p>The <code>!!</code> operator can also be considered similar to <code>Optional.ofNullable(x).get()</code> - which throws an exception if x is null.</p>

<p>Return values from Java code are treated specially; they are technically nullable (or at least the Kotlin compiler does not know if they are nullable or not) but treating them as such would lead to really ugly code. They are therefore handled as a special “platform type” which may be treated like a Kotlin non-nullable but might throw an exception at runtime. See the official documentation on “platform types” for more details.</p>

<h2 id="lambdas">Lambdas</h2>

<p>Kotlin provides syntax similar to Java lambdas: <code>params -&gt; body</code> or <code>{ params -&gt; body }</code> depending on context.</p>

<p>When passing a lambda to a function as the last parameter, the lambda can be placed in braces outside the parameter-list. And if the function has only one parameter, the function parameter round-brackets can be omitted completely:</p>

<ul>
  <li>
<code>list.forEach({item -&gt; println(item)})</code> // seldom seen</li>
  <li>
<code>list.forEach() { item -&gt; println(item) }</code> // seldom seen</li>
  <li><code>list.forEach { item -&gt; println(item) }</code></li>
</ul>

<p>When the lambda takes one argument, the varname can be omitted in which case name <code>it</code> is used by default:</p>

<ul>
  <li><code>list.forEach { println(it) }</code></li>
</ul>

<p>The body of a lambda may access variables in the outer scope when it (eventually) runs - ie it is a <em>closure</em>.</p>

<p>And just for interest, in the case where the lambda body just invokes one function with the same params as the lambda (which is true for our example above):</p>

<ul>
  <li><code>list.forEach(::println)</code></li>
</ul>

<p>The Kotlin standard library provides lots of functions that take lambdas as parameters.</p>

<h2 id="scope-functions">Scope Functions</h2>

<p>Kotlin provides a family of methods that are available on every object which allow applying a lambda to the object in various ways:</p>

<ul>
  <li>
<code>let</code>, <code>run</code>, <code>with</code>, <code>apply</code> and <code>also</code>
</li>
</ul>

<p>For two methods (let and also), the object on which the method was invoked is passed as the (sole) param of the lambda (and as usual can be referred to as <code>it</code> if the lambda does not explicitly declare a param-list).</p>

<p>For the other scope-functions, the lambda which is invoked takes no parameters; instead the object on which the method was invoked is available within the lambda body as <code>this</code>. The latter results in slightly more elegant code when the lambda body accesses methods or properties on its parameter.</p>

<p>For two of the methods (apply and also), the return-value of the lambda is the object on which the method was invoked while for the other three (let, run, with) the return-value of the lambda is whatever the body returns. The former is useful when chaining calls to the original object.</p>

<p>Interestingly, because the scope-functions are implemented as <em>extension functions</em>, they can be invoked on null-references; within the lambda <code>it</code> or <code>this</code> (depending on scope-function) is null.</p>

<p>Examples:</p>

<ul>
  <li><code>"hello world".let(::println)</code></li>
  <li><code>"hello world".let { println(it) }</code></li>
  <li>
<code>"hello world".apply { println(this.capitalize()) }</code> – where “this” in lambda is not needed</li>
  <li>
<code>maybeNullString.?let { println(it) }</code> – print string iff the value is not null</li>
  <li>
<code>maybeNullString.let { println(it) }</code> – print string or “null”</li>
</ul>

<p>The <code>with</code> method supports a simple but useful syntax:</p>

<pre><code>with(someobj) {
  method1()
  for(i in 1..4) {
    method2()
    method3()
  }
}
</code></pre>

<p>Within the with-block, the specified object is “this”, ie the first object on the method-resolution list.</p>

<h2 id="type-casts">Type Casts</h2>

<p>The operator <code>is</code> tests the type of a reference and implicitly casts the reference to the tested type. Explicit casts are therefore seldom needed. Example:</p>

<ul>
  <li><code>val r = if (s is String) s.trim() else s</code></li>
</ul>

<p>When necessary, keyword <code>as</code> can be used for explicit type-casts. The details are a little complicated; see the official docs. Example:</p>

<ul>
  <li><code>val x = y as String?</code></li>
</ul>

<p>Due to the JVM’s type-erasure, it is not possible to use <code>if (x is SomeGenericType&lt;ParamType&gt;)</code>; the best that is available is <code>is SomeGenericType&lt;*&gt;</code>. An exception is for “inline functions” which can use keyword <code>reified</code>, but inline functions should be used sparingly; see the official docs for more info.</p>

<h2 id="exceptions">Exceptions</h2>

<p>Exceptions work similarly to Java. However:</p>

<ul>
  <li>all exceptions are unchecked, ie the compiler never forces you to catch exceptions</li>
  <li>and therefore “throws clauses” are never needed on function declarations</li>
</ul>

<p>One of the major reasons for not having typed exceptions in Kotlin is that they don’t work well with higher-order functions; a function that accepts and executes a lambda must declare any exceptions that the lambda may throw - which would strongly limit the lambdas that the function could accept <em>and</em> require throws-clauses on lambdas. Java already has this problem.</p>

<p>This does not mean that Kotlin functions should throw unchecked exceptions as a regular thing; instead Kotlin functions should generally indicate failure via some mechanism other than an exception, reserving exceptions only for errors that are truly “exceptional” and which are expected to be handled “high up” in the software stack rather than being dealt with by the caller (eg out-of-memory). Kotlin’s standard library follows this approach.</p>

<p>Try/catch statements are expressions (ie return a value) in Kotlin. The value is the last statement in the try-clause, or the last statement in some catch-clause.</p>

<h2 id="for-loops">For-loops</h2>

<p>Work like Python (and other langs):</p>

<ul>
  <li><code>for (item in items) ...</code></li>
  <li><code>for (index in items.indices) ...</code></li>
</ul>

<p>The equivalent of Java’s <code>for (int x = 0; x &lt; 10; x+=2)</code> is <code>for (x in 0 until 10 step 2)</code> - where “until” is an infix function that returns a collection-like object.</p>

<h2 id="when-expressions">When-expressions</h2>

<p>Kotlin when-expressions are the equivalent of Java switch-statements, but somewhat more elegant. The when-expression can optionally take a parameter in which case the condition-expressions can be a constant, is-expression or in-expression.</p>

<pre><code>val obj = 17

val result1 = when {
  obj &lt; 10 -&gt; "small"
  obj &lt; 20 -&gt; "medium"
  else -&gt; "large" 
}

val result2 = when (obj) {
  in 0..10 -&gt; "small"
  in 11..20 -&gt; "medium"
  else -&gt; "large"
}

when (result2) {
  "small" -&gt; println("too small")
  "large" -&gt; println("too large")
  "medium" -&gt; println("just right")
  else -&gt; println("completely unexpected")
}
</code></pre>

<h2 id="string-templates-and-raw-strings">String Templates and Raw Strings</h2>

<p>Any literal string can use <code>$varname</code> to reference variables in the current scope. In fact, even expressions can be evaluated eg <code>println("sum of $a and $b is ${a + b}")</code>.</p>

<p>Literal strings do replace “escape chars” with their equivalents (eg <code>\n</code> with a LF). They are also terminated by the first unescaped quote, and must fit on a single line.</p>

<p>A “raw string” delimited by triple-quotes does not process escape-chars, are terminated only by a triple-quote, and can span multiple lines. However they still are treated as string-templates, ie <code>$var</code> or <code>${expr}</code> is still evaluated.</p>

<h2 id="map-access">Map Access</h2>

<p>The Kotlin standard library provides two different interfaces to the standard Java HashMap: a mutable interface and a read-only interface.</p>

<p>Due to operator-overloading, maps can be accessed as if they were arrays:</p>

<pre><code>map[key] = value  // invokes map.set(key, value)
</code></pre>

<p>Key/value pairs are often created using infix-function <code>Tuple.to</code> eg <code>name to "Mary"</code>; this returns an instance of type Pair which the Map factory-method <code>mapOf</code> accepts:</p>

<pre><code>val opposites = mapOf("left" to "right", "up" to "down")
println(opposites)
</code></pre>

<h2 id="access-control">Access Control</h2>

<p>Scope keywords <code>public</code> and <code>protected</code> have the same meaning as in Java.</p>

<p>Keyword <code>private</code> is expanded slightly; access is allowed from any code in the same <em>file</em>, not just the same class.</p>

<p>Unlike Java, <code>public</code> is the default visibility, and therefore does not need to be used in most cases. However when generating a <em>library</em> rather than an <em>application</em>, it is strongly recommended that every declaration have an explicit access-scope, including <code>public</code> where appropriate. This coding convention is intended to reduce the number of “accidentally public” declarations.</p>

<p>Scope keyword <code>internal</code> has no equivalent in Java; it grants access to “the set of all source-code files fed to a compiler as a batch”. When compiling using the Kotlin plugin for Gradle or Maven, this is all source-code in the project. When compiling using the Kotlin support in the IDEA compiler, it is similar: the set of files in an IDE “module”.</p>

<p>There is no “package-scope”; classes that need to interact can be defined in the same file and use private scope, or in different files and use scope <code>internal</code>.</p>

<p>Scope <code>internal</code> is intended to solve a problem with Java’s package-scope. When implementing a library, it is common to need code in one package to call code in another package. Unfortunately in Java that can only be done by making the callee public - at which point the code also becomes visible to users of the library. <a href="http://moi.vonos.net/java/osgi-classloaders/">OSGi</a> solves this for Java by having each library explicitly declare which packages are part of the public API; code in other packages is not visible to users even when the classes/methods are public. However OSGi is not widely used.</p>

<p>As the JVM has no concept of scope <code>internal</code>, the JVM bytecode generated by the Kotlin compiler for internal classes and methods is marked as public. However the method-names are modified so that they are not easily called from code outside the module. The exact algorithm is an internal implementation detail and could change with new Kotlin releases, but the current implementation appears to:</p>

<ul>
  <li>leave class names unchanged</li>
  <li>leave constructors unchanged</li>
  <li>but rename every method to <code>{originalMethodName}${modulename}</code>
</li>
</ul>

<p>And of course the “backing fields” for properties already have auto-generated names, so are not easy to access.</p>

<p>Just as a side-note: Java 11 introduces the concept of <a href="https://www.baeldung.com/java-nest-based-access-control">nests</a> to the JVM, where one class can (at bytecode level) declare a list of other classes which can access its private fields and methods. This feature was introduced primarily to allow inner-classes to access fields of their enclosing class. However nests do not seem to be useful for implementing “internal scope” - ie the current “name-mangling” implementation appears to be a long-term solution.</p>

<h2 id="function-declarations">Function Declarations</h2>

<p>An abstract function is declared via</p>

<ul>
  <li><code>fun {name}({params}) : return-type</code></li>
</ul>

<p>A concrete function is declared via</p>

<ul>
  <li><code>fun {name}({params}) : return-type {...}</code></li>
</ul>

<p>When a function consists of just a single expression then it can be written as:</p>

<ul>
  <li><code>fun {name}({params}) [: return-type] = ..expr..</code></li>
</ul>

<p>A function with a block body is required to use the <code>return</code> keyword unless its return-type is <code>Unit</code>. The single-expression form of function definition does not require the keyword <code>return</code> and the return-type can be omitted as it can be inferred from the body. An abstract function declaration must always include the return-type.</p>

<p>Function parameters can have default values; such params usually follow all params without default values.</p>

<p>Functions can be invoked using “named arguments”, eg <code>somefun(a=1, b=2)</code></p>

<p>Functions with two params can be declared as infix, and then used as <code>lhs {funcname} rhs</code>.</p>

<p>Function declarations can be nested, ie a function can have a “local helper function” that only it can see/access.</p>

<p>Type <code>Unit</code> is equivalent to Java <code>void</code>.</p>

<h2 id="higher-order-functions-and-function-types">Higher Order Functions and Function Types</h2>

<p>A function can be represented as an object, and passed around by reference.</p>

<p>The function type <code>(Int, Int) -&gt; String</code> is equivalent to a declaration of form:</p>

<pre><code>interface IntIntToString {
  fun invoke(i:Int, j:Int) : String
}
</code></pre>

<p>Functions can accept references to other functions as parameters:</p>

<pre><code>fun useHigherFunction(fn: (Int, Int) -&gt; String) {
  println(fn(1,2))
}

fun intCombiner(i: Int, j:Int) : String {
  return "$i and $j"
}

useHigherFunction(::intCombiner)
useHigherFunction { i, j -&gt; "lambda of $i and $j" }
# and other options possible
</code></pre>

<p>A function-type <code>(Int, Int) -&gt; String</code> can also be written as <code>Int.(Int) -&gt; String</code>. When declared in this form, it can be called in either of two ways:</p>

<ul>
  <li>
<code>fn(1, 2)</code> or</li>
  <li><code>1.fn(2)</code></li>
</ul>

<p>In either case, within the function implementation, keyword <code>this</code> refers to the first parameter (1 in our example).</p>

<p>Java also supports “higher order functions”; it just lacks a syntax for inline function type declarations, instead requiring explicit definition of a <em>Single Applicable Method</em> interface:</p>

<pre><code>// Java
public interface IIS { String apply(int i1, int i2); }
String higherOrderDemo(int v1, int v2, IIS fn) { return "result: " + fn.apply(v1, v2); }

IIS fn = (i, j) -&gt; String.format("i1=%d, i2=%d", i, j);
String result = higherOrderDemo(12, 13, fn);

// Kotlin
fun higherOrderDemo(v1:Int, v2:Int, fn:(Int,Int)-&gt;String) = "result: " + fn(v1, v2)

val fn = { i:Int, j:Int -&gt; "i1=$i, i2=$j" }
val result = higherOrderDemo(12, 13, fn)
</code></pre>

<h2 id="generics">Generics</h2>

<p>These are reasonably similar to Java. Like Java, angle-brackets are used for type-parameters, eg <code>List&lt;Int&gt;</code>.</p>

<p>Unlike Java, “type inference” is used for generic type parameters, ie <code>List&lt;Int&gt;</code> can be written as just <code>List</code> if the fact that the element-type is Int can be determined by the compiler from context.</p>

<p>Kotlin has a different solution for <em>variance</em>, ie Java’s <code>&lt;? extends T&gt;</code> and <code>&lt;? super T&gt;</code> syntax. Here, Kotlin basically uses the same approach as C#: <code>&lt;in T&gt;</code> and <code>&lt;out T&gt;</code>. Kotlin also has “star projections” which look like <code>SomeGenericType&lt;*&gt;</code> and are roughly equivalent to Java’s “raw types” while still staying within the generic type-checking system. The details are somewhat complex; see the official docs for the full explanation.</p>

<h2 id="packages-and-imports">Packages and imports</h2>

<p>Kotlin packages are similar to Java packages.</p>

<p>Code imports types from packages in a similar way too. A Kotlin file does import many more packages by default (Java only imports <code>java.lang.*</code>):</p>

<ul>
  <li><code>kotlin.*, kotlin.annotation.*, kotlin.collections.*, kotlin.comparisons.*, kotlin.io.*, kotlin.ranges.*, kotlin.sequences.*, kotlin.text.*, java.lang.*, kotlin.jvm.*</code></li>
</ul>

<p>The Kotlin standard libraries must therefore be in the classpath of any Kotlin program. Fortunately they are not particularly large - certainly smaller than those of Scala.</p>

<h2 id="top-level-declarations">Top-Level Declarations</h2>

<p>Unlike Java, a Kotlin file can contain package-level property-declarations and function-declarations as well as class-declarations and object-declarations - ie declarations can be placed following the package-declaration and outside of any <code>class Foo {..}</code> scope. And in fact, a “main-method” that provides the entry-point to a Kotlin program must be declared in this way.</p>

<p>The ability to define properties and functions directly within packages supports traditional functional-programming style; a Kotlin program can be written with just DTOs (data classes), variables and functions without any object-oriented features at all (though IO is done via the Java standard libraries and thus requires at least a minimum of object-oriented code).</p>

<p>When a file contains package-level declarations which are not classes, Kotlin creates a JVM class with name <code>{filename}Kt</code> with package-level function-declarations from the package implemented as static functions, and backing-fields for properties implemented as static members. This default class-name can be overridden with annotation <code>@file:JvmName({desiredClassName})</code>.</p>

<h2 id="destructuring-declarations">Destructuring Declarations</h2>

<p>The fields of a data-class can be extracted in a simple assignment, eg:</p>

<ul>
  <li><code>val (name, age) = someuser</code></li>
  <li><code>val (ret1, _, ret3) = somefunction()</code></li>
</ul>

<p>where the type of someuser has methods that supply the necessary data. Actually, any type can be used on the right-hand-side of a destructuring expression as long as it provides methods with signature <code>operator fun component{N}() : &lt;T&gt;</code> where an N is available for each target variable on the LHS of the expression, and <code>&lt;T&gt;</code> matches the type of the target variable. Kotlin data-classes provide such methods automatically; they can be implemented for other types either via normal methods or via extension-functions.</p>

<p>The standard library provides classes <code>Pair</code> and <code>Triple</code>, which makes it elegant to implement and invoke functions that return 2 or 3 values. For more complex return-types, dedicated data-classes should be defined; “data classes” have a very compact syntax and so there is little reason to return plain tuples.</p>

<p>Instances of <code>Pair</code> are usually created by infix function <code>Tuples.to</code>, eg <code>1 to 2</code>.</p>

<p>The Kotlin standard library provides extension-functions <code>component1()</code> and <code>component2()</code> for standard Java type <code>Map.Entry</code>, allowing <code>for ((key, value) in map) ...</code>.</p>

<p>An underscore can be used if you don’t need the value of a specific “component”.</p>

<p>Destructuring is also useful for lambda-parameters:</p>

<ul>
  <li><code>map.mapValues { (key, value) -&gt; ... }</code></li>
</ul>

<p>Kotlin does not have the more extensive destructuring/pattern-matching features of Scala.</p>

<h2 id="extension-functions">Extension Functions</h2>

<p>Functions can be added to an existing class:</p>

<ul>
  <li><code>fun {sometype}.{funcname}(..) {..}</code></li>
</ul>

<p>These functions are available anywhere that the extension-function-declaration is visible (ie has been imported). The functions are not actually part of the class; they are simply syntactic sugar for</p>

<ul>
  <li>
<code>fun {funcname}(this: sometype, ...) {..}</code>.</li>
</ul>

<p>When invoking such a function, <code>someobj.{funcname}(..)</code> becomes <code>{funcname}(someobj, ..)</code>.</p>

<p>By convention, extension functions used or provided by a package are declared at the top of the file, ie right after the package declaration. However for extension-functions used only in one class, they can be declared in the scope of that class.</p>

<p>Interestingly, this can also be used to add extension properties to the target class via syntax:</p>

<ul>
  <li><code>val {sometype}.{propname}: {proptype} get() {..}</code></li>
</ul>

<p>However an “extension property” cannot have a backing-field.</p>

<p>Extension functions are dispatched based on the static type of the expression they are invoked on, not its runtime type. This means that an extension function can even be invoked on a <code>null</code> instance of a type:</p>

<pre><code>fun MyType?.myfunc() = if (this == null) println("isnull") else println("notnull")

val myobj : MyType? = null
myobj.myfunc()  // prints "isnull"
</code></pre>

<h2 id="the-use-function">The Use Function</h2>

<p>Any class which implements <code>java.io.Closeable</code> automatically gets an <em>extension function</em> named <code>use</code> which invokes a lambda then closes the resource (whether an exception occurred or not). This is Kotlin’s equivalent of Java’s try-with-resources. Example:</p>

<pre><code>val stream = Files.newInputStream(Paths.get("/some/file.txt"))
// method use runs the lambda then invokes `close` on the reader (even on exception)
stream.buffered().reader().use { reader -&gt; println(reader.readText()) }
</code></pre>

<h2 id="annotations">Annotations</h2>

<p>Annotations are very similar in Kotlin and Java.</p>

<p>One significant difference is for array-typed properties; Java uses array-initialisation syntax <code>prop = {a, b, c}</code> while Kotlin uses <code>prop = [a, b, c]</code>. Both Java and Kotlin allow the default “value” property to use var-args format instead.</p>

<p>In addition, Java has special-case handling for annotation attributes whose value is an array; a single element can be passed directly. Kotlin does not support this; an array-typed annotation property must always be given an array-typed value even when it only contains one element.</p>

<h2 id="varargs-parameters">Varargs Parameters</h2>

<p>Varargs-methods use keyword <code>vararg</code> rather than Java’s <code>...</code>. An array can be passed to a varargs method by prefixing it with the “spread operator” <code>*</code>:</p>

<pre><code>fun varargsTest(vararg items: String) {
}

varargsTest("alpha", "beta")

var stringArray = arrayOf("first", "second")
varargsTest(*stringArray)
</code></pre>

<h1 id="classes">Classes</h1>

<p>Like Java (and unlike Scala), Kotlin is single-inheritance. Mixins are not supported directly, though the <code>by</code> keyword can be used to produce a similar effect.</p>

<h2 id="simple-class-declarations">Simple Class Declarations</h2>

<p>Somewhat like Scala, the signature for the “primary constructor” of a class is listed in the class declaration. The primary constructor does not have a “function body” in the traditional sense; any “body logic” for the primary constructor must be defined either via <code>init {..}</code> blocks in the class body, or via a secondary constructor.</p>

<p>The parent-class (if any) follows the constructor; any parameters must be provided immediately.</p>

<p>And implemented interfaces follow the parent-class.</p>

<p>Example:</p>

<pre><code>class Foo constructor(id: Int, name: String) : ParentClass(id), Interface1, Interface2 {...}
</code></pre>

<p>Annotations and visibility-modifiers may be placed before keyword <code>constructor</code>.</p>

<p>As a special case, if there are no annotations and visibility-modifiers on the constructor then keyword <code>constructor</code> can be omitted.</p>

<p>A secondary constructor looks a lot more like a Java constructor. However it must first delegate to the primary constructor, and then may run additional code - like this() or super() in Java, except mandatory.</p>

<pre><code>class Person(val name: String) {
  init { logic associated with the primary constructor }

  // secondary constructor
  constructor(name: String, ...) : this(name) {
    // some body logic (in a style more familiar to java developers)...
  }
}
</code></pre>

<p>Methods on a class are <code>final</code> by default; they must be prefixed with modifier <code>open</code> to make them overridable. And in the subclass, Java annotation <code>@Override</code> is replaced by keyword <code>override</code> which is mandatory.</p>

<p>A class is also implicitly <code>final</code> unless explicitly declared as <code>open class {name}</code>…</p>

<h2 id="class-properties">Class Properties</h2>

<h3 id="property-declarations-getters-setters-and-backing-fields">Property Declarations, Getters, Setters, and Backing Fields</h3>

<p>A <code>val</code> or <code>var</code> declaration at package-level or in a <em>class body</em> declares a <em>property</em>, which is a somewhat abstract concept. The same keywords in a function-body simply declare a variable, not a property.</p>

<p>A property declaration with an explicit initialisation value is given an implicit getter-method (and an implicit setter-method when using var). The declaration can be followed by explicit getter or setter method declarations which replace the default implementations. Kotlin allocates a “backing field” for the property if the property uses the default getter or the default setter, or references the backing field via keyword <code>field</code> in a custom getter or setter. This “backing field” has an auto-allocated name and cannot be directly accessed except by keyword <code>field</code> from within the getter/setter implementation.</p>

<p>A private property with default getter/setter is optimised, being effectively the same as Java field access.</p>

<p>A declaration without an explicit initialisation value (a “virtual property”) must be followed by a getter-method declaration and optionally a setter-method declaration.</p>

<p>Like methods, a property can be overridden in a subclass (if it is declared open) - though this is rarer than overriding normal methods.</p>

<p>Primary-constructor parameters which are marked <code>var</code> or <code>val</code> automatically declare properties which are initialised from the value passed to the constructor (yay - no more boring Java constructors). Parameters that are not marked as either var or val are accessible from within variable-initialisation expressions and init-blocks within the class body, but are not properties. Keywords var/val are not permitted in the parameter-list of secondary constructors.</p>

<pre><code>package foo

private var myPackageProperty = "someprop"

class Foo(val name: String) { // name becomes a public read-only property of Foo
  val PI = 3.141 // read-only property

  var autoincrementer = 0 // read-write property
    get() {
      return ++field // increments the property each time get is called
    }
}
</code></pre>

<p>A property which is initialised with the return-value of a Java method (including code from the Java standard library) cannot use type-inference, as the return value is a “platform type” whose nullable/not-nullable state is not known.</p>

<h3 id="const-declarations">Const Declarations</h3>

<p>The modifier “const” can be applied to a <code>val</code> declaration at package-level or within an <code>object</code> (singleton); it is not allowed at class-level or function-level. Compilation will fail unless the initialisation-expression can be evaluated at compile-time. A const property cannot have a custom getter (and no setter at all) and thus acts more like a plain variable than a property.</p>

<h3 id="property-access-syntax">Property Access Syntax</h3>

<p>Properties can be accessed via syntax <code>val foo = instance.property</code>, ie with what looks like Java field-access syntax. All such accesses are compiled to JVM bytecode as calls to the getter. Setters work similarly.</p>

<p>Kotlin code can invoke getters and setters in pure Java classes with the field-access-like syntax.</p>

<p>Java code can access properties from a Kotlin class using methods <code>get{name}()</code> and <code>set{name}(val)</code>.</p>

<h3 id="accessibility-of-properties">Accessibility of Properties</h3>

<p>The accessibility of the property getter/setter (ie whether public, protected, private or internal) can be set in a few ways:</p>

<pre><code>var prop1 = "prop1"  // public getter and setter
protected val prop2 = 2 // protected getter, no setter
var prop3 = true; protected set // public getter, protected setter
</code></pre>

<h3 id="initialising-properties-from-constructor-parameters">Initialising Properties from Constructor Parameters</h3>

<p>As alternative to declaring properties in the constructor-params, properties can be declared in the class body and initialised to the value of constructor-params. Variable references within the class body resolve first to parameters then to properties, which makes the syntax quite nice. This approach allows the property-name to be different from the param-name, allows more control over accessibility, and supports custom getters and setters for the property.</p>

<pre><code>class Item(desc: String, count: Int) {
  val itemDescription = desc  // property name differs from constructor-param-name
  var count = count; private set // property has different accessibility for getter and setter
}
</code></pre>

<h3 id="lateinit">Lateinit</h3>

<p>A property can be marked “lateinit” in which case it does not need to be initialised with a value on the same line as the declaration; this is effectively like declaring the property nullable and initialising it with null but <em>promising</em> that the value will be set to a non-null value before it is used; if code does access it before initialisation then an exception is thrown. This keyword is particularly useful with dependency-injection frameworks which do not fully support initialisation of instances via the class constructor (Spring for example). The property must be mutable (var not val).</p>

<p>Because lateinit properties need to be <code>var</code>, it can be useful to reduce the accessibility of the setter method.</p>

<pre><code>// silly example of lateinit usage
class MyLateInitDemo {
  lateinit var myLateValue: String; private set // Non-nullable and not initialised!

  @PostConstruct
  fun postConstruct() {
    myLateValue = "defined"
  }
}
</code></pre>

<h2 id="data-classes">Data Classes</h2>

<p>Kotlin “data classes” make it easy to define DTO-like types - and are similar to those in Scala, Java’s <code>record</code> type (since Java 15), or Java’s Lombok utility.</p>

<pre><code>data class Customer(val name: String, var email: String) { ... }
</code></pre>

<p>The primary-constructor-parameters are usually marked with var/val to make them <em>properties</em>. A data-class often needs no body (in which case the braces can be omitted).</p>

<p>Unlike regular class-declarations, appropriate equals/hashcode/tostring methods are auto-generated.</p>

<p>A <code>copy</code> method is also generated which allows creating a new instance of the type with identical values except for the fields listed in the copy-method named arguments eg <code>somedataobj.copy(name=foo, length=17)</code>. This is particularly useful for a data-class that has only val-properties (and is thus immutable). If you have a complex structure of immutable objects nested within immutable objects and wish to create a copy with some new values for deeply-nested properties then you may wish to look at the <em>lenses</em> feature of the <a href="https://arrow-kt.io/">arrow</a> library.</p>

<p>A data-class cannot be declared <code>open</code> - ie it is equivalent to a Java “final class”.</p>

<p>The parameters of a data-class may have default values.</p>

<p>A data class may also declare properties in its class-body. These are not included in the auto-generated equals/hashcode/tostring/other methods.</p>

<p>Libraries which instantiate a type with no parameters initially (eg JPA) may require data-classes to define a default-value for every parameter - or see the standard Kotlin compiler plugins which can help with this.</p>

<h2 id="sealed-classes">Sealed Classes</h2>

<p>In Java, a class can either be final (no subclasses allowed) or not (infinite subclasses allowed). A Kotlin sealed class sits between: subclasses can only be declared in the same file.</p>

<p>A class-declaration marked as sealed is implicitly abstract, ie cannot be instantiated directly; only its subclasses may be instantiated.</p>

<p>These are very useful in when-clauses (like Java switch-statements) which test the type of an object as there is no need for an <code>else</code> clause; the compiler knows when all possibilities have been checked.</p>

<p>A sealed class is known in functional-programming literature as a Sum Type (a subtype of Algebraic Data Types) - because the set of possible values for a value of the base type is the sum (union) of the set of possible values for each of the subclasses.</p>

<h2 id="object-declarations">Object Declarations</h2>

<p>Singleton types are declared with syntax</p>

<ul>
  <li>
<code>object SomeType {..}</code> or</li>
  <li><code>object OtherType : BaseClass(), Interface1, Interface2 {..}</code></li>
</ul>

<p>This declares a type similar to using the “class” keyword. It also causes a singleton instance of that type to be created when it is first referenced (lazy initalisation). This singleton instance can then be accessed via the typename, eg <code>SomeType.someFunction()</code> or <code>SomeType.SOME_CONSTANT</code>.</p>

<p>Kotlin does not have the Java keyword <code>static</code>; things that would be static in Java are instead best placed on a singleton. There are significant benefits to this; it is far more elegant than static!</p>

<p>As an alternative to using singleton objects, properties and functions that have no associated object can be declared directly within a package, ie not within a class or object declaration. However using an <code>object</code> makes it possible to pass sets of properties/functions around via a single reference to the enclosing object.</p>

<h2 id="companion-objects">Companion Objects</h2>

<p>An object declaration nested within a class that is marked with qualifier <code>companion</code> has additional behaviour.</p>

<p>Variable and function references from the associated class are first resolved against the class itself, and if not found then against the companion-object.</p>

<p>A class can have only one companion object; it can have other nested object-declarations but their methods are NOT automatically in the resolution-path.</p>

<p>When the typename is omitted for the companion-object then its name is <code>{parentType}.Companion</code>.</p>

<p>Example:</p>

<pre><code>class Foo {
  companion object {
    const val MAX = 20
    fun doSomething(value: int) { .. }
  }

  object OtherNestedObject {
    fun doSomethingElse(value: int) { .. }
  }

  fun fooFunction() {
    doSomething(MAX) // finds the method and constant on the companion
    OtherNestedObject.doSomethingElse(17)
  }
}
</code></pre>

<p>A companion object’s singleton instance is initialised when the enclosing class is loaded into memory.</p>

<p>Methods and members of the companion objects can be accessed from outside of the enclosing class simply via the enclosing class name, eg</p>

<ul>
  <li><code>Foo.doSomething(Foo.MAX)</code></li>
</ul>

<p>or more explicitly via:</p>

<ul>
  <li><code>Foo.Companion.doSomething(Foo.Companion.MAX)</code></li>
</ul>

<h2 id="object-expressions-anonymous-objects">Object Expressions (anonymous objects)</h2>

<p>Anonymous classes are declared with keyword <code>object</code>. What in Java would be <code>new SomeType() {..}</code> is in Kotlin <code>object : SomeType() {..}</code>.</p>

<p>This effectively creates a type when executed, and an instance of that type; no more instances of the type can be created as the type has no name.</p>

<p>The object acts as a closure, ie the body can reference variables in the enclosing scope.</p>

<h2 id="delegation">Delegation</h2>

<p>This is a very useful feature that has no real equivalent in Java.</p>

<p>Given a class declaration</p>

<pre><code>class Derived(b: Base) : Base by b;
</code></pre>

<p>Then instances of <code>Derived</code> also implement interface <code>Base</code>, and by default those inherited methods simply forward calls onto the same method on the object passed to the constructor.</p>

<p>Type <code>Derived</code> can override methods defined in <code>Base</code> to easily implement AOP-style “around advices”.</p>

<p>A different kind of delegation can be applied to properties:</p>

<pre><code>val someprop by somedelegate
</code></pre>

<p>Here, “somedelegate” is an object that must provide a function <code>getValue</code> and for var-properties also a function <code>setValue</code>. Reads and writes to the property are then forwarded to the associated delegate-object.</p>

<p>Usually, the delegate object is created via a function-call. Here is an example using the standard-library function <code>lazy</code> which accepts a lambda as parameter and returns a delegate object:</p>

<pre><code>val memoizedFoo by lazy {...}
</code></pre>

<p>The delegate-object returns by function <code>lazy</code> invokes the lambda on first call to <code>getValue()</code> and caches the returned value.</p>

<p>See the Kotlin docs for more details.</p>

<h2 id="nested-classes">Nested Classes</h2>

<p>Classes can be nested as in Java. However nested classes are static by default; keyword <code>inner</code> is required in order for the nested class to get an implicit reference to its parent.</p>

<h1 id="kotlin-libraries">Kotlin Libraries</h1>

<p>If you’ve used Scala, you’re aware that Scala comes with a huge standard library of its own.</p>

<p>Kotlin also provides its own libraries, but somewhat smaller and less complicated. The most significant part is the collections api, and the most important feature is that proper read-only interfaces are made available for the standard Java collections.</p>

<p>The Kotlin standard library does <em>not</em> implement its own collection types; instead it just provides new interfaces for the standard Java collection types. And most importantly, many of these interfaces are <em>read-only</em>, ie lack methods such as put/add. Because these  interfaces only have “output values” they are able to be covariant, eg a <code>List&lt;String&gt;</code> can be passed around as a <code>List&lt;Any&gt;</code>. Java collections can’t be covariant because all standard interfaces include <em>write</em> APIs, and putting an <code>Any</code> into the list would be bad for obvious reasons.</p>

<p>Because Kotlin just provides new interfaces for existing collection types, integration of Java standard collection types and Kotlin standard collection types is basically transparent; there is no need to call methods to convert from one to the other.</p>

<p>WARNING: these read-only collections are backed by the standard Java <em>mutable</em> implementations; they are just being passed around using an interface that has no mutation methods. The underlying data for a reference of read-only type can change if:</p>

<ul>
  <li>code calls a mutation method on the original (mutable) object</li>
  <li>the read-only-typed reference is forcibly cast to the mutable type</li>
  <li>the reference is passed to a Java method which then mutates the object</li>
</ul>

<p>This is why the Kotlin documentation calls these interfaces read-only and not immutable!</p>

<p>Functional programming often uses immutable collections, ie creates new collections by starting with an existing collection and logically cloning it. Functional languages therefore often use specialized implementations of collections that make this efficient; the new collection internally <em>references</em> the original one and contains just the changes. Sadly because Kotlin uses the Java collections, functional-style use of collections in Kotlin is far less efficient than in other functional languages - the underlying collection is often <em>truly</em> cloned. That’s a trade-off that the Kotlin developers chose in order to simplify Kotlin/Java interactions.</p>

<p>The collections library is imported by default, so many functions are available without specifying a package-prefix.  Examples: <code>listOf(1, 2, 3)</code> and <code>mutableListof(1, 2, 3)</code>.</p>

<p>The collections library defines a large number of functional-style operators (map, flatMap, filter, etc) which are available directly on the collection types without the indirection of “streams” and “collectors” that Java requires.</p>

<p>While the Kotlin standard libraries are required to be in the classpath of any Kotlin program, there are additional libraries:</p>

<ul>
  <li>
<code>kotlin-reflect</code> provides classes in package <code>kotlin.reflect</code> for introspecting types at runtime</li>
  <li>various official-but-optional libraries providing sub-packages of <code>kotlinx.*</code> (analogous to Java’s <code>javax.*</code> packages)</li>
</ul>

<h1 id="reflection">Reflection</h1>

<p>The class-object associated with a Kotlin class is retrieved like: <code>val fooKClass : KClass&lt;*&gt; = Foo::class</code>. Note that the type is <code>KClass&lt;*&gt;</code> not <code>Class&lt;?&gt;</code>; the KClass provides method <code>.java</code> to convert it to a traditional Java class object.</p>

<p>As noted above, Kotlin does not include reflection APIs in the standard library; they are included in optional library <code>kotlin.reflect</code>.</p>

<h1 id="builders">Builders</h1>

<p>The lambda-related features of Kotlin, when used with some carefully-defined functions, make it possible to use valid Kotlin code to build hierarchical data structures while having that code look more like declarations than procedural code.</p>

<p>Kotlin is not quite as elegant at this as Groovy (with Gradle files being the best example), but it does a reasonable job.</p>

<p>An HTML builder library is available in Kotlin standard extension library <code>kotlinx.html</code>. Libraries for building other hierarchical structures are available from third-parties.</p>

<p>Gradle supports build-files defined via Kotlin-based builders instead of Groovy-based builders.</p>

<h1 id="coroutines">Coroutines</h1>

<p>Kotlin standard extension library <code>kotlinx.coroutines</code> provides <a href="https://en.wikipedia.org/wiki/Coroutine">coroutine</a> support for Kotlin - lightweight userspace cooperative threading.</p>

<p>Core Concepts:</p>

<ul>
  <li>CoroutineScope - an object through which coroutines can be registered via the following methods:
    <ul>
      <li>launch(lambda) - schedules the lambda to run sometime, and returns a Job object representing the task; the Job supports join and cancel.</li>
      <li>async(lambda) - returns a <code>Deferred&lt;T&gt;</code> which is a subtype of Job which has an <code>await</code> method that blocks the caller until the lambda has computed its return-value (similar to a <code>future</code>)</li>
      <li>actor(lambda) - returns a “channel” object through which messages can be sent to the lambda</li>
      <li>broadcast/produce/promise - yet more variants</li>
    </ul>
  </li>
  <li>Dispatcher - actually executes a coroutine in some thread</li>
</ul>

<p>See the documentation on coroutines for more information.</p>

<h1 id="minor-notes">Minor notes</h1>

<h2 id="slf4j">SLF4J</h2>

<p>When using SLF4j or Log4j, a logger is usually obtained by passing the enclosing class, eg:</p>

<pre><code>public class Foo {
  private static final Logger logger = LoggerFactory.getLogger(Foo.class)
}
</code></pre>

<p>In Kotlin the equivalent is:</p>

<pre><code>class Foo {
  companion object {
    val logger = LoggerFactory.getLogger(Foo::class.java)
  }
}
</code></pre>

<h2 id="java-streams">Java Streams</h2>

<p>The following code is fairly normal in Java:</p>

<pre><code>SomeCollection results = collection.stream().map(..).collect(..)  
</code></pre>

<p>The Kotlin equivalent is simpler:</p>

<pre><code>val results = collection.map {...}
</code></pre>

<p>Note that the lambda does not need to be inside the map-function parameter list (this is just syntactic sugar), and (more importantly) neither method <code>stream()</code> nor method <code>collect</code> is needed.</p>

<h2 id="java-incompatibilities">Java Incompatibilities</h2>

<p>When mixing Kotlin and Java code, watch out for the following…</p>

<p>Invoking Kotlin functions with default parameter values from Java is not supported; the values must be explicitly provided - or annotation @JvmOverloads applied, which implicitly generates variants of the function with differing numbers of parameters.</p>

<p>Kotlin object-references must be explicitly declared as nullable or non-nullable, meaning that null-pointer exceptions are less common at runtime. Every Java method returning an object technically returns a nullable reference, ie theoretically every variable to which a Java returned value is assigned should have <code>?</code> as a modifier. However this would make code very ugly; it is therefore allowed to omit the suffix - and this is commonly done when the programmer <em>believes</em> that the return-value is never null. This does mean that what looks like a non-nullable variable can potentially throw NullPointerException at runtime if an unexpected null was returned. The full story is somewhat complicated; see documentation on “Platform Types” for more details.</p>

<p>A comparison of Kotlin vs Java can be found <a href="https://kotlinlang.org/docs/reference/comparison-to-java.html">in the docs</a>. Far more detail can be found in the <a href="https://kotlinlang.org/docs/kotlin-docs.pdf">full reference docs</a> under section “Java Interop”.</p>

<h1 id="kotlin-vs-scala">Kotlin vs Scala</h1>

<p>Here are some things that Scala has which Kotlin does not..</p>

<h2 id="tuples">Tuples</h2>

<p>There is limited Tuple support in Kotlin - just Pair and Triple. Data classes can in some ways be considered a tuple with named fields, as destructuring-assignment can be used with them.</p>

<h2 id="custom-operators">Custom Operators</h2>

<p>In Scala, just about any sequence of characters can be used as a prefix, postfix or infix operator. Kotlin allows reusing the standard operators (about a dozen), but more cannot be defined. Kotlin also provides no ability to modify left/right associativity, precedence, etc.</p>

<p>This also means that the Lisp-derived syntax for building lists that Scala provides (<code>val list = 1 :: 2 :: 3 :: Nil</code>) is not possible in Kotlin.</p>

<h2 id="powerful-generics">Powerful Generics</h2>

<p>Kotlin’s generics are no more or less powerful than Java’s generics - just easier to understand.</p>

<p>Scala has far more powerful generic types - but at the cost of a lot of complexity that programmers need to understand.</p>

<p>Scala works around the JVM’s “type erasure” problem by supporting Manifests for generic types; this allows a method called on a generic type to know the types associated with its parent. This feature can be very useful but unfortunately has no equivalent in Kotlin. Kotlin does support keyword <code>reified</code> which does something similar to manifests, but that only works for “inline” functions.</p>

<h2 id="pattern-matching-and-destructuring">Pattern Matching and Destructuring</h2>

<p>Kotlin has very basic destructuring-assignments, and its when-statements provide very limited pattern-matching.</p>

<p>Scala’s features are far more powerful, but also more complex to learn. Its approach to destructuring also creates intermediate arrays, ie is not quite as efficient at runtime.</p>

<h2 id="implicit-conversions">Implicit Conversions</h2>

<p>Scala provides “implicit conversions”; when an object of type T is used where a different type is expected, the compiler checks all imports to see if an “implicit conversion” is defined that can wrap type T to produce the necessary target type. Similarly, when a method M is invoked on a type that has no such method, then the compiler looks for implicit conversions that would produce a type that does have such a method.</p>

<p>This is extremely powerful, but:</p>

<ul>
  <li>can make code almost impossible to read, and</li>
  <li>makes compilation extremely slow</li>
</ul>

<p>Scala’s support for this means that external libraries can feel like a built-in feature of the language. Kotlin libraries cannot integrate so elegantly - but Java has even less support for extending classes, and is still successful.</p>

<h2 id="implicit-parameters">Implicit Parameters</h2>

<p>A Scala method can declare a parameter as “implicit”; when the caller does not provide a value for it then the compiler searches for an implicit value of the same type and passes that as the value.</p>

<p>This allows libraries to define very extensible APIs - but at the cost of difficult-to-read and difficult-to-compile code.</p>

<h2 id="mixins">Mixins</h2>

<p>Scala allows <em>traits</em> (similar to interfaces) to declare member variables. This is not quite “multiple inheritance” but close; Scala’s “linearization” allows the definition of “mixin classes” which provide “cross-cutting” functionality that can be usefully added to wide varieties of classes. Linearization also supports an effect similar to AOP “interceptors” by inheriting from a trait that overrides an inherited method. However this concept does introduce significant complexity into the Scala language, and can lead to the compiler producing an unexpectedly large number of JVM classes from a single input class.</p>

<p>Kotlin provides nothing similar to Scala’s linearization. It does provide <em>delegation</em> which might solve some of the same use-cases.</p>

<h2 id="exception-handling-with-try">Exception-handling with Try</h2>

<p>Scala’s standard library provides function <code>Try</code> which executes a block of code, and returns a wrapper-object holding either the result or the thrown exception. This allows error-handling code to use return-checks rather than exception-checks.</p>

<p>Kotlin’s <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/result.md">Result</a> type can be used to invoke functions which may throw exceptions, though its style is a little different. The <a href="https://arrow-kt.io/">arrow</a> library does provide Try - though it recommends using other approaches instead.</p>

<h2 id="factory-methods-on-companion-objects">Factory Methods on Companion Objects</h2>

<p>Scala code can use an elegant syntax to provide a factory-method for instances of a type: define an “apply-method” on the companion object. Simply using the enclosing type-name as a function then invokes the factory, eg <code>val x = List(1, 2, 3)</code>. Kotlin uses this syntax to invoke the built-in object construction logic (invoke the class constructor), so a factory-method has to look something like <code>listOf(..)</code>.</p>

<h2 id="partial-function-application-and-currying">Partial Function Application and Currying</h2>

<p>Not sure how this is done in Kotlin; it certainly is not as integrated into the language as Scala.</p>

<h2 id="function-composition">Function Composition</h2>

<p>Kotlin does not have methods for function-composition in its standard library; you will need some third-party library for that (eg <a href="https://arrow-kt.io/">Arrow</a>).</p>

<h1 id="build-systems">Build Systems</h1>

<p>It seems that the Kotlin world generally prefers Gradle over Maven.</p>

<p>Interestingly, the Gradle project also now supports defining build-scripts <a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/">using a Kotlin-based DSL</a> rather than a groovy-based one.</p>

<h1 id="conciseness">Conciseness</h1>

<p>I recently converted a demo spring/jpa program from Java to Kotlin.</p>

<ul>
  <li>Java SLOC: 1368</li>
  <li>Kotlin SLOC: 1075</li>
</ul>

<p>Change: (1075 - 1368)/1368 = 21% fewer lines of code</p>

<p>That’s not world-changing, but definitely worth having.</p>

<h1 id="useful-references">Useful References</h1>

<ul>
  <li>
<a href="https://kotlin.link/">Kotlin is Awesome</a> - community site</li>
  <li>
<a href="https://kotlinlang.org/docs/kotlin-docs.pdf">Kotlin Official Language Documentation</a> - More detailed walkthrough of the language in PDF form</li>
  <li><a href="https://github.com/kotlintest/kotlintest">Kotlin Test</a></li>
</ul>

    </article>
  </div>
    
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'mineofinformation'; // mineofinformation (disqus site id)
      var disqus_pageid = '/java/kotlin/'; // /relative/path/to/article/dir

      var disqus_config = function () {
        this.page.identifier = disqus_pageid;
        this.page.url = 'https://moi.vonos.net' + disqus_pageid;
      };
      (function() {
        var d = document, s = d.createElement('script');
        s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  



      </section>
    </div>
    <section id="footer">
      <p>Copyright &copy; 2025 - Simon Kitching</p>
    </section>
  </body>
</html>

