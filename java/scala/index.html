<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Mine of Information - Basic Scala Syntax for Java Programmers</title>
    <link rel="stylesheet" type="text/css" href="/assets/css/coderay.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/stylesheet.css">
    <link type="application/atom+xml" title="Mine of Information" rel="alternate" href="/atom.xml"> 

    <meta name="generator" content="nanoc 4.12.15"> 
    <meta name="author" content="Simon Kitching"> 
  </head>
  <body>
    <section id="header">
      <span class='title'>The Mine of Information</span> <span class='desc'>(Nuggets of Programming and Linux)</span>
    </section>
    <div id="main">
      <section id='navpane'>
        <section>
  <ul id="navicons">
      <li class="nav">
      <a href="/" title="Home"><img src="/assets/images/Home.png"></a>
      <a href="/archives/" title="Archives"><img src="/assets/images/Calendar.png"></a>
      <a href="/site/welcome" title="E-Mail"><img src="/assets/images/Envelope.png"></a>
      <a href="/atom.xml" title="Subscribe Feed"><img src="/assets/images/RSS.png"></a>
      </li>
  </ul>
</section>

<section>
  <h1>About</h1>
  <ul id="about">
    <li>
      <a href="/site/welcome">Welcome</a>
    </li>
  </ul>
</section>

<section>
<h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2023/12/monorepos/">Monorepos and Polyrepos</a>
      </li>
    
      <li class="post">
        <a href="/2023/12/httpapis/">HTTP APIs, REST APIs, and Others</a>
      </li>
    
      <li class="post">
        <a href="/2023/09/biden/">Biden on Democracy</a>
      </li>
    
      <li class="post">
        <a href="/2023/09/tech-breadth/">Maintaining Technical Depth</a>
      </li>
    
      <li class="post">
        <a href="/2023/08/vpns/">The Uselessness of Consumer VPNs</a>
      </li>
    
      <li class="post">
        <a href="/2023/06/microservices/">Some Aspects of Implementing Microservices..</a>
      </li>
    
      <li class="post">
        <a href="/2023/06/dtest-evolution-scrum-monad/">DDD, Architecture patterns, and More..</a>
      </li>
    
      <li class="post">
        <a href="/2023/05/testing/">Should Unit Tests Verify Requirements Only?</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Categories</h1>
  <ul id="categories">
    
      <li class="catlink">
        <a href='/category/Architecture/'>Architecture</a>
      </li>
    
      <li class="catlink">
        <a href='/category/BigData/'>BigData</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Cloud/'>Cloud</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Cryptography/'>Cryptography</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Git/'>Git</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Infrastructure/'>Infrastructure</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Java/'>Java</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Links/'>Links</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Linux/'>Linux</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Network/'>Network</a>
      </li>
    
      <li class="catlink">
        <a href='/category/OSGi/'>OSGi</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Off-topic/'>Off-topic</a>
      </li>
    
      <li class="catlink">
        <a href='/category/OpenWRT/'>OpenWRT</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Programming/'>Programming</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Security/'>Security</a>
      </li>
    
      <li class="catlink">
        <a href='/category/Site/'>Site</a>
      </li>
    
  </ul>
</section>


      </section>
  
      <section id='content'>
        
  <div class='page'>
    <h1>Basic Scala Syntax for Java Programmers</h1>
    <aside>First published on: August 19, 2017</aside>
    
    <article>
    <p>Categories: <a href='/category/Java/'>Java</a></p>
      
<h1 class="no_toc" id="introduction">Introduction</h1>

<p>This page contains a quick summary of the syntax of the Scala programming language. These are mostly notes I made from an online Scala tutorial, a Scala book, and a Scala introductory video course; they have been posted here mostly as a reference for myself, and are not expected to be of particular use to anyone else. If you are learning Scala, then I would recommend reading the online tutorial yourself, and making your own notes!</p>

<p>Learning any language requires mastering two parts: the syntax and the patterns-of-use. This applies to human and computer-programming languages. These notes really only address the syntax part, but might make it possible to read Scala code sufficiently to get a general idea of what it is doing. Maybe.</p>

<p>The <a href="http://scala-lang.org">home page</a> for the Scala programming language contains an excellent <a href="http://docs.scala-lang.org/tutorials/tour/tour-of-scala.html">introduction</a> from which some of these notes come. I can also recommend the book “Programming Scala Second Edition”. The <a href="https://en.wikipedia.org/wiki/Scala_(programming_language)">wikipedia page on Scala</a> also provides a good overview for Java developers.</p>

<p>Scala is a big complicated language, with both OO and Functional options; this is the price paid for having an “easy upgrade path” from Java, and the ability to use existing Java libraries. Having two choices makes <em>writing</em> code easier - the programmer can choose whichever style they are most familiar with. But it makes <em>reading</em> code harder - you need to know both styles in order to understand existing programs. I think this language with a small experienced team may be good, and with inexperienced programmers it would be hell. The Scala video course I watched did have some useful tips for starting with Scala; in particular the presenter recommended aiming for “functional in the small, OO in the large”. In other words, developers familiar with OO languages should not try to take on the most advanced “philosophies” of Scala immediately (eg the Scalaz library), but instead use the OO features of Scala at the component-level. At the class or method level, it is however useful to make use of immutable structures, lambdas, etc.</p>

<p>Guidelines for functional vs object styles: program in the small with functional, program in the large with OO. The concept of interfaces works really well for decoupling code. However mutability and a multiplicity of classes can lead to bugs and overcomplex/verbose code at lower levels - where the functional approach shines. OO programs are also a good fit for GUI frameworks.</p>

<h1 class="no_toc" id="table-of-contents">Table of Contents</h1>

<ul id="markdown-toc">
  <li><a href="#why-use-scala" id="markdown-toc-why-use-scala">Why Use Scala?</a></li>
  <li><a href="#the-scala-implementation" id="markdown-toc-the-scala-implementation">The Scala Implementation</a></li>
  <li><a href="#the-scala-environment" id="markdown-toc-the-scala-environment">The Scala Environment</a></li>
  <li><a href="#basic-application-structure" id="markdown-toc-basic-application-structure">Basic Application Structure</a></li>
  <li><a href="#basic-code-syntax" id="markdown-toc-basic-code-syntax">Basic Code Syntax</a></li>
  <li><a href="#the-scala-type-hierarchy-value-types-and-java-primitive-types" id="markdown-toc-the-scala-type-hierarchy-value-types-and-java-primitive-types">The Scala Type Hierarchy, Value Types and Java Primitive Types</a></li>
  <li><a href="#typecasts-and-type-aliases" id="markdown-toc-typecasts-and-type-aliases">Typecasts and Type Aliases</a></li>
  <li>
<a href="#variables" id="markdown-toc-variables">Variables</a>    <ul>
      <li><a href="#vals-and-vars" id="markdown-toc-vals-and-vars">Vals and Vars</a></li>
      <li><a href="#variable-declaration-syntax" id="markdown-toc-variable-declaration-syntax">Variable Declaration Syntax</a></li>
      <li><a href="#almost-everything-is-an-expression" id="markdown-toc-almost-everything-is-an-expression">Almost Everything is an Expression</a></li>
    </ul>
  </li>
  <li>
<a href="#methods" id="markdown-toc-methods">Methods</a>    <ul>
      <li><a href="#functions-closures-and-methods" id="markdown-toc-functions-closures-and-methods">Functions, Closures and Methods</a></li>
      <li><a href="#basic-method-declarations" id="markdown-toc-basic-method-declarations">Basic Method Declarations</a></li>
      <li><a href="#implicitexplicit-typing" id="markdown-toc-implicitexplicit-typing">Implicit/Explicit Typing</a></li>
      <li><a href="#more-on-method-declarations" id="markdown-toc-more-on-method-declarations">More on Method Declarations</a></li>
      <li><a href="#multiple-parameter-groups" id="markdown-toc-multiple-parameter-groups">Multiple Parameter Groups</a></li>
      <li><a href="#method-invocation---named-parameters" id="markdown-toc-method-invocation---named-parameters">Method Invocation - Named Parameters</a></li>
      <li><a href="#method-invocation---infix-form" id="markdown-toc-method-invocation---infix-form">Method Invocation - Infix Form</a></li>
      <li><a href="#operator-precedence" id="markdown-toc-operator-precedence">Operator Precedence</a></li>
      <li><a href="#operator-associativity" id="markdown-toc-operator-associativity">Operator Associativity</a></li>
      <li><a href="#operator-binding-and-the-colon-character" id="markdown-toc-operator-binding-and-the-colon-character">Operator Binding and the Colon Character</a></li>
      <li><a href="#point-free-style" id="markdown-toc-point-free-style">Point-free Style</a></li>
    </ul>
  </li>
  <li><a href="#tuples" id="markdown-toc-tuples">Tuples</a></li>
  <li>
<a href="#classes" id="markdown-toc-classes">Classes</a>    <ul>
      <li><a href="#basic-class-declarations" id="markdown-toc-basic-class-declarations">Basic Class Declarations</a></li>
      <li><a href="#more-on-class-constructors" id="markdown-toc-more-on-class-constructors">More on Class Constructors</a></li>
      <li><a href="#case-classes" id="markdown-toc-case-classes">Case Classes</a></li>
    </ul>
  </li>
  <li>
<a href="#object-declarations-singletons-and-companion-objects" id="markdown-toc-object-declarations-singletons-and-companion-objects">Object Declarations (Singletons and Companion Objects)</a>    <ul>
      <li><a href="#the-apply-method-as-factory" id="markdown-toc-the-apply-method-as-factory">The Apply Method as Factory</a></li>
    </ul>
  </li>
  <li><a href="#traits-interfaces" id="markdown-toc-traits-interfaces">Traits (interfaces)</a></li>
  <li><a href="#inheritance" id="markdown-toc-inheritance">Inheritance</a></li>
  <li><a href="#linearization-of-traits" id="markdown-toc-linearization-of-traits">Linearization of Traits</a></li>
  <li><a href="#anonymous-subclasses" id="markdown-toc-anonymous-subclasses">Anonymous Subclasses</a></li>
  <li><a href="#sealed-classes-and-traits" id="markdown-toc-sealed-classes-and-traits">Sealed Classes and Traits</a></li>
  <li>
<a href="#the-implicit-keyword" id="markdown-toc-the-implicit-keyword">The Implicit Keyword</a>    <ul>
      <li><a href="#implicit-type-conversions" id="markdown-toc-implicit-type-conversions">Implicit Type Conversions</a></li>
      <li><a href="#implicit-methods" id="markdown-toc-implicit-methods">Implicit Methods</a></li>
      <li><a href="#implicit-parameters" id="markdown-toc-implicit-parameters">Implicit Parameters</a></li>
      <li><a href="#type-classes-adding-functionality-to-classes" id="markdown-toc-type-classes-adding-functionality-to-classes">Type Classes (adding functionality to classes)</a></li>
    </ul>
  </li>
  <li><a href="#structural-typing" id="markdown-toc-structural-typing">Structural Typing</a></li>
  <li>
<a href="#packages-and-import-statements" id="markdown-toc-packages-and-import-statements">Packages and Import Statements</a>    <ul>
      <li><a href="#declaring-packages" id="markdown-toc-declaring-packages">Declaring Packages</a></li>
      <li><a href="#importing-stuff" id="markdown-toc-importing-stuff">Importing Stuff</a></li>
      <li><a href="#package-objects" id="markdown-toc-package-objects">Package Objects</a></li>
    </ul>
  </li>
  <li><a href="#access-control" id="markdown-toc-access-control">Access Control</a></li>
  <li>
<a href="#generics" id="markdown-toc-generics">Generics</a>    <ul>
      <li><a href="#generic-types" id="markdown-toc-generic-types">Generic Types</a></li>
      <li><a href="#covariance-contravariance-and-type-bounds" id="markdown-toc-covariance-contravariance-and-type-bounds">Covariance, Contravariance and Type Bounds</a></li>
      <li><a href="#generic-type-parameters-via-abstract-type-declarations" id="markdown-toc-generic-type-parameters-via-abstract-type-declarations">Generic Type Parameters via Abstract Type Declarations</a></li>
      <li><a href="#variance" id="markdown-toc-variance">Variance</a></li>
      <li><a href="#generic-self-types" id="markdown-toc-generic-self-types">Generic Self Types</a></li>
    </ul>
  </li>
  <li><a href="#pattern-matching" id="markdown-toc-pattern-matching">Pattern Matching</a></li>
  <li><a href="#destructuring-bindings" id="markdown-toc-destructuring-bindings">Destructuring Bindings</a></li>
  <li>
<a href="#functions-and-lambdas" id="markdown-toc-functions-and-lambdas">Functions and Lambdas</a>    <ul>
      <li><a href="#anonymous-function-declaration" id="markdown-toc-anonymous-function-declaration">Anonymous Function Declaration</a></li>
      <li><a href="#declaring-methods-which-take-a-function-as-parameter" id="markdown-toc-declaring-methods-which-take-a-function-as-parameter">Declaring Methods Which Take a Function as Parameter</a></li>
      <li><a href="#partial-function-application-aka-currying" id="markdown-toc-partial-function-application-aka-currying">Partial Function Application aka Currying</a></li>
      <li><a href="#explicitly-using-the-function-classes" id="markdown-toc-explicitly-using-the-function-classes">Explicitly using the Function Classes</a></li>
      <li><a href="#methods-vs-functions" id="markdown-toc-methods-vs-functions">Methods vs Functions</a></li>
      <li><a href="#lazy-call-by-name-parameters" id="markdown-toc-lazy-call-by-name-parameters">Lazy (call-by-name) Parameters</a></li>
    </ul>
  </li>
  <li><a href="#dynamic-types" id="markdown-toc-dynamic-types">Dynamic Types</a></li>
  <li><a href="#loops" id="markdown-toc-loops">Loops</a></li>
  <li>
<a href="#standard-library" id="markdown-toc-standard-library">Standard Library</a>    <ul>
      <li><a href="#collections-sequences-and-lists" id="markdown-toc-collections-sequences-and-lists">Collections, Sequences and Lists</a></li>
      <li><a href="#arrays" id="markdown-toc-arrays">Arrays</a></li>
      <li><a href="#the-option-type" id="markdown-toc-the-option-type">The Option Type</a></li>
    </ul>
  </li>
  <li>
<a href="#exceptions" id="markdown-toc-exceptions">Exceptions</a>    <ul>
      <li><a href="#java-style-exceptions" id="markdown-toc-java-style-exceptions">Java Style Exceptions</a></li>
      <li><a href="#the-try-type" id="markdown-toc-the-try-type">The Try Type</a></li>
      <li><a href="#try-with-resources" id="markdown-toc-try-with-resources">Try-with-resources</a></li>
    </ul>
  </li>
  <li><a href="#list-efficiency" id="markdown-toc-list-efficiency">List Efficiency</a></li>
  <li>
<a href="#special-methods" id="markdown-toc-special-methods">Special Methods</a>    <ul>
      <li><a href="#apply-method-overview" id="markdown-toc-apply-method-overview">Apply-method Overview</a></li>
      <li><a href="#map-like-access-with-apply-and-update" id="markdown-toc-map-like-access-with-apply-and-update">Map-like Access with Apply and Update</a></li>
    </ul>
  </li>
  <li><a href="#standard-functions-map-filter-withfilter-flatmap" id="markdown-toc-standard-functions-map-filter-withfilter-flatmap">Standard Functions map, filter, withFilter, flatMap</a></li>
  <li><a href="#standard-functions-fold-and-reduce" id="markdown-toc-standard-functions-fold-and-reduce">Standard Functions fold and reduce</a></li>
  <li><a href="#for-comprehensions" id="markdown-toc-for-comprehensions">For-comprehensions</a></li>
  <li><a href="#annotations" id="markdown-toc-annotations">Annotations</a></li>
  <li><a href="#tail-recursion" id="markdown-toc-tail-recursion">Tail Recursion</a></li>
  <li><a href="#algebraic-data-types" id="markdown-toc-algebraic-data-types">Algebraic Data Types</a></li>
  <li><a href="#nested-inner-classes-and-path-dependent-types" id="markdown-toc-nested-inner-classes-and-path-dependent-types">Nested (Inner) Classes and Path-dependent Types</a></li>
  <li><a href="#multithreading" id="markdown-toc-multithreading">Multithreading</a></li>
  <li><a href="#lazy-variables" id="markdown-toc-lazy-variables">Lazy Variables</a></li>
  <li><a href="#partial-functions" id="markdown-toc-partial-functions">Partial Functions</a></li>
  <li><a href="#manifests" id="markdown-toc-manifests">Manifests</a></li>
  <li><a href="#other-minor-features" id="markdown-toc-other-minor-features">Other Minor Features</a></li>
  <li><a href="#ecosystem" id="markdown-toc-ecosystem">Ecosystem</a></li>
  <li><a href="#ides" id="markdown-toc-ides">IDEs</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<h1 id="why-use-scala">Why Use Scala?</h1>

<p>In comparison to Java, Scala code provides a whole bunch of things which replace verbose Java usage with more compact sourcecode and remove annoying Java limitations:</p>

<ul>
  <li>Gets rid of constructor code which just copies params to fields</li>
  <li>Automatically generates field accessors (getters/setters) where relevant (var/val constructor params)</li>
  <li>Automatically generates sensible toString/equals/hashcode methods for <a href="https://en.wikipedia.org/wiki/Data_transfer_object">DTO</a>-like data structures (case classes)</li>
  <li>Fields of an object can be accessed in sourcecode using property-like syntax but this is compiled to a call to a getter/setter (and can be overridden in the called code if desired)</li>
  <li>Has type inference, to get rid of complicated type-declarations for variables/fields</li>
  <li>Has tuples - saves a lot of trivial class definitions, and in particular makes it easy for a method to return multiple values</li>
  <li>Semicolons usually optional (except in complicated cases)</li>
  <li>Return keyword optional in most cases</li>
  <li>Can omit braces around body of single-line methods (see example below)</li>
  <li>Supports operator overloading (eg defining a method named “+” for a custom class)</li>
  <li>Keyword “new” often not needed (technically, not a language feature but companion objects typically provide factory methods)</li>
  <li>Operator “==” is equivalent to “.equals” ie usually does value-comparison, not identity comparison. Identity comparison is available as “obj1.eq(obj2)”.</li>
  <li>Any method can be invoked with “named parameters”, ie params can be passed in any order. Example: swap(op2=12, op1=17)</li>
  <li>Methods can have default-values for parameters.</li>
  <li>If-statements are expressions which return a value, eg “val x = if (expr) 1 else 2”</li>
  <li>Import statements can define an alias-name for the imported type(s)</li>
  <li>Import statements can occur anywhere in source-code, not just at the top of a file (and they are lexically scoped)</li>
  <li>Local aliases can be defined for complicated type-definitions</li>
  <li>Triple-quoted strings are multi-line strings, allowing literal json, xml, etc to be easily expressed. In addition, backslashes are not interpreted in such strings, making it easy to write literal regexes and similar things.</li>
  <li>Interpolated strings like <code>s"my name is $name"</code> are a more compact alternative to <code>String.format</code>.</li>
</ul>

<p>The standard library provides a lot of functional-programming-style features if you wish to go that way. In particular, the immutable collection types make scalable multi-threaded applications easier to develop.</p>

<p>Support in Scala for generic types is significantly better than in Java, ie code can be expressed in a more type-safe way - fewer casts and nasty workarounds.</p>

<p>Using Scala also “opens a window” into the functional programming world while being more accessible than simply jumping into Haskell or similar, eg:</p>

<ul>
  <li>Pattern Matching (deconstruction-based switches)</li>
  <li>Currying</li>
  <li>Tuples</li>
  <li>Explicit Tail Call Optimisation</li>
  <li>Support for passing closures as parameters (more concise and flexible than Java8 Lambdas)</li>
</ul>

<p>There are many external libraries for Scala which provide interesting functionality in functional-programming-style, including Akka and Play.</p>

<p>The primary disadvantages of Scala relative to Java are:</p>

<ul>
  <li>Much slower compilation times (particularly annoying within IDEs which try to provide as-you-type feedback - the experience is much less pleasant than Java where compile-times are faster)</li>
  <li>Poorer binary compatibility (often code compiled with Scala is only compatible with code compiled with exactly the same release of Scala)</li>
  <li>Calling Java code can be clumsy</li>
  <li>Not as widely known as Java (ie finding other developers and advice is more challenging)</li>
  <li>A more complex language than Java (more features, more syntax, and thus harder to learn)</li>
  <li>Some libraries overuse Scala features, in particular implicit conversions and operator-chars-as-method-names, making code hard to read</li>
  <li>For code distributed as a “fat jar”, the Scala standard libraries need to be included - and they are quite large. In other words, simple tool-like apps in Scala are huge in comparison to their Java equivalents.</li>
</ul>

<h1 id="the-scala-implementation">The Scala Implementation</h1>

<p>The Scala compiler, libraries, and tools are licensed under a “bsd-like” license; the code can be downloaded from an SVN repo. Development appears to happen on open lists, which is good.</p>

<h1 id="the-scala-environment">The Scala Environment</h1>

<p>Scala 2.12.0 and later runs on any JVM v1.8 or later (ie Scala code compiles to Java bytecode); earlier versions of Scala required only Java 1.6. Scala code can call Java libraries (though sometimes some workarounds are needed, eg converting a Scala collection-type into its <code>java.util.*</code> equivalent before passing it as a parameter to a Java method).</p>

<p>The standard Scala distribution previously had support for compiling Scala code to the CLR environment, ie Microsoft <code>.Net</code> runtime. However this support was removed in Scala v2.11 (2014).</p>

<p>There are good Scala plugins for Eclipse, Intellij and NetBeans IDEs.</p>

<p>Scala applications can be built with standard Java build-tools (eg Maven) or with the Scala-specific SBT (Scala Build Tool).</p>

<p>As with many languages, the standard Scala toolset provides a REPL (Read Eval Print Loop) tool for experimenting with Scala code; fragments of code can be entered and immediately executed. Methods defined via the REPL are added to a special “global class”.</p>

<h1 id="basic-application-structure">Basic Application Structure</h1>

<p>Scala code ist stored in plain text files, using UTF8 encoding. The standard file suffix is “.scala”. Scala code does not have to follow Java’s one-file-per-class approach; a single file can contain multiple definitions. Nevertheless, the recommended convention is that a separate file is used for each class, and the filename matches the classname except:</p>

<ul>
  <li>a class and its companion object must be in the same file</li>
  <li>an ADT sum type (a sealed trait and its implementations) must have all component types in the same file</li>
  <li>nested (inner) classes are obviously in the same file as their enclosing type</li>
  <li>when code maintenance is improved by grouping types - in which case the filename should start with a lowercase letter.</li>
</ul>

<p>The primary “structural” components are packages, classes, traits and objects:</p>

<ul>
  <li>
    <p>Packages are similar to those in Java. However Scala code often names packages following conventions common in languages like C++, Python or Ruby rather than Java’s widely-spread “reverse domain name” structure. Package naming hierarchies are thus often “shallower” than in Java.</p>
  </li>
  <li>
    <p>Classes are roughly similar to classes in Java. The “case class” is a variant of class that acts more like a “struct” or <a href="https://en.wikipedia.org/wiki/Data_transfer_object">DTO</a> (Data Transfer Object).</p>
  </li>
  <li>
    <p>Traits are roughly similar to interfaces in Java.</p>
  </li>
  <li>
    <p>Objects are somewhat like “singleton instances” in Java, ie are like declaring a class and applying the <a href="https://www.tutorialspoint.com/design_pattern/singleton_pattern.htm">static singleton design pattern</a>. An object-declaration in the same file as a class-declaration and using the same name as the class is called a “companion object” for the class and has access to the private members and methods of that class.</p>
  </li>
</ul>

<p>The primary <em>structural</em> difference between Scala and Java is that Scala supports <a href="https://en.wikipedia.org/wiki/First-class_function">functions as first-class citizens</a>, ie references to functions can be created and passed around as easily as references to other types. Functions can be partially-applied, and composed in the usual ways supported by other <em>functional languages</em>.</p>

<h1 id="basic-code-syntax">Basic Code Syntax</h1>

<p>Source code blocks are delimited by braces, as with Java (not indentation-based as with Python). However semicolons are optional in most cases, and the conventional style is to omit them except in the rare situations where they really are required.</p>

<p>By convention, types start with upper-case letters while methods and variables start with lower-case letters, as in Java. Multi-word names use CamelCase. Constants are usually named like types, ie camelcase starting with an uppercase letter (unlike Java where constants are usually written in <code>ALL_UPPER_CASE</code>).</p>

<p>Packages, classes and traits (like interfaces) are declared reasonably similarly to Java. Singleton types can also be declared in a manner similar to classes, using the “object” keyword.</p>

<p>Methods are declared using keyword “def”. When an “= ..fnbody..” follows the declaration, then this is a concrete method; when no function body follows the declaration then the method is abstract.</p>

<p>Variables are declared using either “val” (immutable; roughly equivalent to Java <code>final</code>) or “var” (mutable).</p>

<p>Type inference may be used in variable and member declarations, ie declarations do not need to include an explicit type - the compiler can usually figure it out from the context. Method return types may also be omitted when they can be inferred by the compiler. However method parameter types must always be explicitly defined. Type inference does not make Scala radically different from Java, it is just a nice way to reduce clutter. Note that Java has a little bit of type inference itself: the “<code>&lt;&gt;</code>” syntax.</p>

<p>When types are present, they usually follow the name of some element rather than precede it, eg “<code>var foo: String</code>” rather than Java’s “<code>String foo;</code>”.</p>

<p>Generics in Scala is a bit different than Java, but roughly “<code>[T]</code>” means “<code>&lt;T&gt;</code>”.</p>

<p>Java’s primitive types are replaced by Scala “value types” which are accessed like objects, but can potentially be as efficient as the Java primitive equivalents. These types are named Byte, Int, Long, etc. Note that Scala does not provide its own reference types for the basic heap-allocated equivalents - it just reuses <code>java.lang.Integer</code>, <code>java.lang.Byte</code> etc. As with Java, primitives are boxed (copied to storage on the heap) automatically when needed (eg when adding a primitive to a collection).</p>

<p>Arrays in Scala do not use square-brackets for declaration or indexing. Arrays are real objects with methods, and creating an array and reading/writing its elements is done via <em>methods</em> not special-case syntax as in Java. Reading/writing is actually done via a special “apply” method which can be invoked without the method-name; thus copying an element from one array to another looks like “<code>dest(i) = src(j)</code>”.</p>

<p>Scala allows nested function definitions, ie functions within functions.</p>

<p>Scala code can include inline xml (no escaping required).</p>

<p>Scala has no static fields or methods. The primary purpose of Java static fields and methods is to provide a single instance of a variable or constant, or a single implementation of a method. Scala singleton objects are “types with a single instance”, so provide a suitable home for such fields and methods.</p>

<p>Scala has no checked exceptions - only unchecked ones. Otherwise, exceptions work similarly to Java, with throw and catch keywords. Exceptions are used slightly less often in Scala than Java, given standard-library types such as Option and Either which make it easier to return error-indicating objects on failure. Catching of exceptions is also often done via the library-function <code>Try</code> (note the capital first letter) which converts an exception into a return-value.</p>

<h1 id="the-scala-type-hierarchy-value-types-and-java-primitive-types">The Scala Type Hierarchy, Value Types and Java Primitive Types</h1>

<p>Every type in Scala is a subytpe of <code>scala.Any</code>. This has two subtypes:</p>

<ul>
  <li>
<code>scala.AnyVal</code> is the parent of all “value types”</li>
  <li>
<code>scala.AnyRef</code> is the parent of all “reference types”</li>
</ul>

<p>Value-types are the kinds of things allocated “on the stack” or embedded inline into other objects, and so <em>garbage collection</em> is not relevant for them. They have no <em>identity</em>, only a value. Equality comparisons therefore always are value-comparisons, and never identity-comparisons. Specifically, methods on the type-definition are not permitted to do anything that would require a “new” operation (ie heap allocation) at runtime. This ensures the methods can be compiled down to a set of <em>helper functions</em> rather than requiring real objects. The result is code that looks object-oriented but which is as efficient as procedural code.  The Scala wrappers for the primitive Java types (int, double, char, etc) are all of this kind (called “value classes”), removing the clumsy Java distinction between primitives and objects without a performance hit. It is also allowed (and useful) for users to define their own “value classes” as no-overhead wrappers for their own datatypes.</p>

<p>Reference-types are the kinds of things allocated “on the heap”. Local stack-frames and other objects may hold references (pointers) to them, but they are not “embedded” into other objects, and may be garbage-collected if no references to them remain.</p>

<p>Just about every type in Scala subclasses <code>scala.AnyRef</code>, and act much like Java classes.</p>

<p>The kinds of methods found on java.lang.Object (ie those common to every object instance) are spread between Any and AnyRef.</p>

<p>When primitives are embedded into a collection (eg <code>List[Int]</code>) then they are “boxed” ie converted to on-heap objects just as in Java.</p>

<p>Type “Unit” is the equivalent of Java “void”, and the single value of this type is written “<code>()</code>”. The keyword “null” is also used - but is not related to Unit.</p>

<h1 id="typecasts-and-type-aliases">Typecasts and Type Aliases</h1>

<p>Typecasts are done via a method defined on a base Scala type (ie available on any object):</p>

<pre><code>  var x = myref.asInstanceof[Int]
</code></pre>

<p>On a similar subject, the equivalent of Java’s <code>Foo.class</code> is <code>classOf[Foo]</code>.</p>

<p>Alternative names (“type aliases”) can be defined for existing types, just for convenience:</p>

<pre><code>type BarList = List[Bar]   # defines a "type alias"
</code></pre>

<h1 id="variables">Variables</h1>

<h2 id="vals-and-vars">Vals and Vars</h2>

<p>Scala provides keyword “val” to declare references that cannot change. But the object pointed to can still change internally - unless the type is designed with no mutation methods. In short: just like a Java final field. Unlike Java, Scala developers tend to use vals very frequently.</p>

<p>When a variable is declared with <code>var</code> then it can be rebound to some other reference, as in Java.</p>

<h2 id="variable-declaration-syntax">Variable Declaration Syntax</h2>

<p>Scala puts the variable-name before the type, eg</p>

<pre><code>  val foo: Int = 3
  var bar: String = "hello" // initialized but mutable
  var baz: String // uninitialized
</code></pre>

<p>instead of</p>

<pre><code>  final int foo = 3;
  String bar = "hello"; // initialized but mutable
  String baz;  // uninitialized
</code></pre>

<p>Type inference often allows the explicit type declaration to be omitted:</p>

<pre><code>  val pi = 3.14     // implicitly Double
  val foo = 3       // implicitly Int
  var bar = "hello" // implicitly String
  var baz: String
</code></pre>

<p>The Scala var/type ordering works better with type inference. I rather like it, as it mimics natural language better: “foo is an integer”.</p>

<p>A val declaration must be initialised, like final variables in Java. Obviously it makes no sense to have an uninitialised immutable reference (except when it is an abstract field definition in an an abstract class).</p>

<p>A val or var declaration can be initialised with a code-block containing multiple statements (which is run immediately). The code-block acts like a function (ie the variable is set to the value of the last expression in the code-block):</p>

<pre><code>  val myfunc = {.....}
</code></pre>

<p>A string written as <code>s"..."</code> is an interpolated-string; any <code>$name</code> or <code>${expression}</code> text in the string will be expanded.</p>

<p>Instances of classes are created with “new” (as in Java). However it is very common to define a <em>factory method</em> on a “companion object”; this is described in more detail later but means that calls to <code>new</code> are less commonly seen when reading Scala code. As an example: <code>val mylist = List(1,2,3)</code> is using the “default apply method” on the List companion object to instantiate a new list, ie that method acts as a factory.</p>

<h2 id="almost-everything-is-an-expression">Almost Everything is an Expression</h2>

<p>Almost every code-structure that can be used within a method returns a <em>value</em>. In Java, things like if/for/while/switch are <em>statements</em> without return-value; in Scala:</p>

<ul>
  <li>
<code>if/else</code> is an expression, ie returns a value</li>
  <li>
<code>for..yield</code> is an expression</li>
  <li>
<code>match</code> (similar to switch) is an expression</li>
  <li>
<code>try/catch</code> is an expression</li>
  <li>but <code>for</code> (without yield), <code>while</code>, and <code>do..while</code> are statements (have no return value)</li>
</ul>

<p>The fact that “if/else” returns a value is great, and makes the <code>?:</code> “ternary operator” unnecessary (Scala does not have a ternary operator):</p>

<pre><code>  val x = if (a&gt;0) a else b;
</code></pre>

<h1 id="methods">Methods</h1>

<h2 id="functions-closures-and-methods">Functions, Closures and Methods</h2>

<p>All these names refer to very similar things:</p>

<ul>
  <li>A function is a block of logic which takes zero or more parameters.</li>
  <li>A closure is a function with associated “captured variables”.</li>
  <li>A method is a function associated with an object instance.</li>
</ul>

<p>Because a singleton object instance can always be found without needing a parameter or “captured” reference to it, a method defined on a singleton object type can effectively be used as a function.</p>

<p>More information on functions, closures and methods is provided later.</p>

<h2 id="basic-method-declarations">Basic Method Declarations</h2>

<p>Method declarations are permitted within class, trait and object declarations.</p>

<p>Methods are declared like:</p>

<pre><code>   def helloTo(who: String, greeting: String): String = {return greeting + ", " + who}
</code></pre>

<p>This syntax mimics natural language nicer than Java: “helloTo returns String”, and puts the important fact (method name) earlier than the subordinate fact (returns String).</p>

<p>The “signature” of this method is <code>(String,String) =&gt; String</code> - see later for passing methods and functions as parameters.</p>

<p>Often the method return type can be deduced (see “type inference” above), in which case the explicit return-type declaration can be omitted:</p>

<pre><code>   def helloTo(who: String, greeting: String) = {return greeting + ", " + who}

   // Inferred return type is Int...
   def min(op1: Int, op2: Int) = {
     if (op1 &lt;= op2)
       return op1 // Int returned
     else
       return op2 // Int returned
   }
</code></pre>

<p>By default, the return-value of any method is the result of the last expression evaluated in that method, ie the “return” keyword is often unnecessary:</p>

<pre><code>   def helloTo(who: String, greeting: String) = {greeting + ", " + who}

   def min(op1: Int, op2: Int) = {
     // an "if/else" is actually an expression which evaluates to one of its branches..
     if (op1 &lt;= op2)
       op1
     else
       op2
   }
</code></pre>

<p>And when the method body is just one line, the braces can be omitted:</p>

<pre><code>   def helloTo(who: String, greeting: String) = greeting + ", " + who
   def min(op1: Int, op2: Int) = if (op1 &lt;= op2) op1 else op2
</code></pre>

<p>A method with no parameters may be defined without parentheses, in which case it must be invoked without parentheses. When defined <em>with</em> parentheses it may be invoked with or without them (inconsistency due to compatibility with Java). Convention: only methods without side-effects (pure functions) are written without parentheses. Example:</p>

<pre><code>  def age = { currentYear - this.yearOfBirth }
</code></pre>

<p>An <em>abstract method declaration</em> uses the same form as above, but without the “=” sign and the body. In an abstract method declaration, the return-type must always be explicitly declared (obviously, it cannot be deduced from the method body as there is none).</p>

<p>When a method is declared as “<code>def name(params) {...}</code>” without a return type and without equals then the return-type is implicitly <code>Unit</code> (like Java’s void) - and any expression at the end of the method body will thus be ignored. This usage is not recommended; it is better style to use the equals and let Scala’s type inference figure out that no value is being returned from the method - or explicitly declare a return-type of Unit. A method returning Unit is also known as a <em>procedure</em>.</p>

<p>Declaring a method with a return-type and then forgetting the equals leads to a compilation failure - the Scala compiler sees an abstract method declaration whose return-type is being defined as an inline subclass (the method body is seen as subtyping the previous type-name). Inline subclasses are not allowed in declarations, so this is an error - but currently a rather confusing one.</p>

<p>One exception to the def-requires-equals rule is when defining <em>secondary constructors</em> for a class; these are created with <code>def this(...) {this(..)}</code> and do not have an equals before the body.</p>

<h2 id="implicitexplicit-typing">Implicit/Explicit Typing</h2>

<p>The fact that variable declarations <em>inside</em> a method are inferred, but that methods must have explicit param types seems a good compromise. It removes pointless text while keeping confusion manageable.</p>

<p>Having strict typing is great for refactoring and understanding existing code - mandatory for large projects.</p>

<h2 id="more-on-method-declarations">More on Method Declarations</h2>

<p>Method-names can use, or be exclusively formed from, punctuation chars. Such methods can be overridden in subclasses just like any other method. Example:</p>

<pre><code>   def &lt;&lt;(x:Int) = {...}
</code></pre>

<p>Such method names are not limited to a predefined set of operators - sequences of punctuation chars may be used as a method-name. These methods are usually called “operators”, even if they don’t mirror traditional operator-names such as “<code>+</code>” or “<code>&lt;&lt;</code>”.  Just about any character can be used in a method or variable name, except quote/apostrophe/backtick/comma/semicolon/dot and those that come in pairs, ie “<code>()[]{}</code>”. A name which begins with an “operator character” must contain only operator characters. A name which begins with an alphabetic character must include an underscore before any operator chars, eg “<code>do_++</code>”.</p>

<p>Absolutely any sequence of characters can be used as a method name when they are surrounded by backticks - even reserved-words from the language such as <code>if</code>.</p>

<p>Methods with variable numbers of parameters (varargs) are supported as with Java, but with a different syntax:</p>

<pre><code>  def add(operands: Int*) = ...
</code></pre>

<p>As in Java, a varargs-method can be invoked with a sequence of literal args, or an array. Unlike Java, it is possible to pass an arbitrary collection (sequence) to a varargs method, but a special syntax is needed: <code>add(mylist:_*)</code>. The strange syntax is actually a kind of inline “type cast” (type ascription) of variable <code>mylist</code> to type “<code>_*</code>”.</p>

<p>Methods have public access by default (see later for more info on access control).</p>

<p>Method params can be given default values:</p>

<pre><code>  def foo(reqdParam: String, optParam: String = "") = ...
</code></pre>

<h2 id="multiple-parameter-groups">Multiple Parameter Groups</h2>

<p>A method (or function) can be declared with multiple groups of parameters:</p>

<pre><code>  def myMethod(i: Int, s:String)(s:String):Float = {...}
</code></pre>

<p>Such a method can be invoked in various ways; the simplest is <code>myMethod(1,"hello")("world")</code>. See later for information on <em>implicit parameters</em>, <em>partial function application</em> and <em>lazy parameters</em>.</p>

<p>The “signature” of such a method looks like <code>(Int,String)=&gt;String=&gt;Float</code> (see later for information on passing functions as parameters).</p>

<h2 id="method-invocation---named-parameters">Method Invocation - Named Parameters</h2>

<p>Methods can be invoked using “named parameters”; given a standard method-declaration like:</p>

<pre><code>  def swap(op1: Int, op2: Int)
</code></pre>

<p>it can be invoked as</p>

<pre><code>  swap(op2=17, op1=12)
</code></pre>

<p>There is another feature with a similar name but quite different functionality: “call-by-name parameters”. These are described later.</p>

<h2 id="method-invocation---infix-form">Method Invocation - Infix Form</h2>

<p>The dot can be omitted when calling a method on an object. And you can omit parentheses when invoking any method with one parameter. So instead of this:</p>

<pre><code>  foo.bar(12)
  fix.fox(13,14)
</code></pre>

<p>you can write this:</p>

<pre><code>  foo bar 12
  fix fox(13,14)
</code></pre>

<p>This is particularly useful when overriding operators:</p>

<pre><code>  foo.+(13)   // invoke the method named "+" on object foo
  foo + 13    // same as above
</code></pre>

<p>Combining this with the ability to define method-names consisting of punctuation characters can lead to elegant-looking APIs, or simply unreadable ones. The widely-used Akka library uses this to allow code like “<code>sender ! Response(errMsg)</code>” - meaning invoke the method named “<code>!</code>” on object “sender” passing the return value of (special) method <code>Response.apply(errMsg)</code> method as a parameter.</p>

<p>Interestingly, the source-code for standard class “scala.Int” includes this declaration:</p>

<pre><code>   def +(x:Int): Int
</code></pre>

<p>which is what allows us to write</p>

<pre><code>  val sum = 1 + 4
</code></pre>

<h2 id="operator-precedence">Operator Precedence</h2>

<p>When invoking a series of methods using <em>infix form</em>, the question of <a href="https://en.wikipedia.org/wiki/Order_of_operations">precedence</a> arises, eg:</p>

<pre><code>  val x1 = 1 + 3 * 8                        // traditional example
  val x2 = foo +- bar *^ baz                // some infix methods with non-ascii names
  val x3 = foo plusminus bar starcarat baz  // some infix methods with ascii names
</code></pre>

<p>Mathematical operators have well-known precedence: multiplication has higher precendence than addition, so the first example is interpreted as <code>1 + (3 * 8)</code>.</p>

<p>In Scala, there is a standard set of operator-characters which have a fixed precedence (eg <code>+-</code>); the programmer cannot override these precedences. A method-name which starts with such a character has the fixed precedence value of that character, ie a method’s precedence is set by the <em>first</em> character of its name. While this is a loss of flexibility, making precedence dynamic (ie allowing functions to declare operator precedence) would probably lead to totally unreadable code.</p>

<p>Method names used in infix-form which do not start with a recognised operator-character all have the same precedence.</p>

<p>The first two of the above examples are therefore equivalent to:</p>

<pre><code>  val x1 = 1 + (3 * 8)
  val x2 = foo.+-(bar.*^(baz))
</code></pre>

<p>In the third example, methods “plusminus” and “starcarat” have the same precedence, so the question of <em>associativity</em> arises - see below.</p>

<h2 id="operator-associativity">Operator Associativity</h2>

<p>When invoking a series of methods using <em>infix form</em>, and the methods have the same precedence, then the question of <a href="https://en.wikipedia.org/wiki/Operator_associativity">associativity</a> arises, eg:</p>

<pre><code>  val x1 = 1 + 3 + 5                        // traditional example
  val x2 = foo +- bar +- baz                // some infix methods with non-ascii names
  val x3 = foo plusminus bar starcarat baz  // some infix methods with ascii names
</code></pre>

<p>Mathematical operators have well-known associations: they almost all associate left-to-right, so the first example is interpreted as <code>(1+3)+5</code>.</p>

<p>In Scala, each standard operator-character has a fixed associativity; the programmer cannot override it. When used in infix-form, a method’s associativity is set by the <em>last</em> character of its name. Methods used in infix-form which do not end with a recognised operator-character all have left-to-right associativity.</p>

<p>The above examples are therefore equivalent to:</p>

<pre><code>  val x1 = (1 + 3) + 5
  val x2 = (foo.+-(bar)).+-(baz)
  val x3 = (foo.plusminus(bar)).starcarat(baz)
</code></pre>

<h2 id="operator-binding-and-the-colon-character">Operator Binding and the Colon Character</h2>

<p>One particularly important operator in Scala is <code>::</code> which means “concatenation”. The standard linked-list type provides a method with this name for building lists, and if you are familiar with functional programming you will know how often linked lists are used. Interestingly, <code>::</code> is right-associative (ie different from most other operators). Actually, what is done in Scala is to define character <code>:</code> as right-associative, meaning any method ending in a colon (including <code>::</code>) is right-associative.</p>

<p>In addition, for any method ending in a colon, the “binding” is reversed. Above, it was mentioned that “<code>a op b</code>” is equivalent to “<code>a.op(b)</code>”. However for any method-name ending with a colon, “<code>a op b</code>” is instead equivalent to “<code>b.op(a)</code>”. In particular, lists are commonly built like “<code>1 :: 2 :: Nil</code>” which is equivalent to “<code>List.Nil.::(2).::(1)</code>”.</p>

<p>Thus:</p>

<pre><code>   val l1 = 1 :: 2 :: Nil;  // creates (1,2)  -- and equivalent to "val t1 = Nil.`::`(2); val l1 = t1.`::`(1);"
   val l1a = 0 :: l1;       // creates (0,1,2)
   val l2 = 3 :: 4:: Nil;   // creates (3,4)
   val all = l1 ::: l2;     // triple-colon is "flattening concatenation" which creates (1,2,3,4)
</code></pre>

<p>While this is something of an advanced topic, Nil possibly needs a little explanation. The object Nil is a singleton of type <code>List[Nothing]</code>, ie the generic List type with a type-parameter of the special Nothing type which can be cast to any other type (is a subtype of any type). The List class has a method <code>::(b B): List[B]</code> ie a method which takes an object of any type B and returns a list of that type. However there is a type-constraint on B: a list of type A can only be passed a B if A is covariant with B. Type Nothing is covarient with every type; a <code>List[Nothing]</code> can therefore take a parameter of any type (eg an Integer or String), and returns a list of that new type. From that point on, the new list object has a type <code>List[B]</code> which is probably <em>not</em> covariant with other types, and therefore the <code>::</code> operator will only accept new objects of the same type B. The result is that Nil can be used as the starting-point for lists of any type; the compiler infers the type of the list from the call <code>b :: Nil</code> to be whatever type b has. Scala’s type-inference has already been mentioned, and its support for type-parameters (generics) is discussed later.</p>

<h2 id="point-free-style">Point-free Style</h2>

<p>Taken to extreme, this ability to use “infix” form for methods taking one parameter leads to something called “point free style”. For example:</p>

<pre><code>  List(1,2,3,4) filter isEven foreach println
</code></pre>

<p>is equivalent to</p>

<pre><code>  val input = List(1,2,3,4)
  input.filter(isEven).foreach(println)
</code></pre>

<p>In the above code, type List has a method filter which returns an object of type Seq which has a method foreach which takes a function-reference.</p>

<h1 id="tuples">Tuples</h1>

<p>A tuple is somewhere between an array and a datastructure. Like an array, it is a fixed-size sequence of references to other objects. Unlike an array, each reference can have a different type. Tuples are defined simply like <code>("hello", 123, 12.45, "world")</code>. The values in a tuple are usually accessed via <em>pattern matching</em> aka “destructuring” (see later). However the fields can also be accessed with <code>sometuple._1</code>, <code>sometuple._2</code> etc, or by method <code>sometuple.productElement(i)</code>. The total number of fields is available via method <code>tuple.productArity</code>.</p>

<p>The operator <code>-&gt;</code> builds tuples of two objects, eg <code>1-&gt;2</code> returns a tuple of two integers (ie a single object containing two subobjects).</p>

<p>Advanced topic: operator <code>-&gt;</code> is actually defined on a type named <code>ArrowAssoc</code> which also defines an implicit conversion method from any type to itself. When the compiler sees <code>x -&gt; y</code> it can therefore generate the equivalent code <code>ArrowAssoc(x).-&gt;(y))</code> which returns a tuple. Implicit conversions are powerful and elegant - but finding the full set of such impicit conversions is not trivial for the compiler, and is possibly one of the reasons why the Scala compiler is so slow. It can also be very difficult when reading the code to figure out exactly what is going on.</p>

<p>Some quick tips:</p>

<ul>
  <li>a tuple can be converted to a string (for debugging) via: <code>("hello", 2, "world").toString</code>
</li>
  <li>a tuple can be converted to a string (more controlled) via: <code>("hello", 2, "world").productIterator.mkString(",")</code>
</li>
</ul>

<h1 id="classes">Classes</h1>

<h2 id="basic-class-declarations">Basic Class Declarations</h2>

<p>A Scala “class” declaration is roughly like a Java class declaration. However parameters to what is named the “primary constructor” are kind of squashed into the class declaration header, and the variable-declarations and inline anonymous code-blocks within the class body form the “body” of the primary constructor:</p>

<pre><code>  class User(val id: Int, var name: String, private val yearOfBirth: Int, comment: String = "no comment") {
    var isActive = false
    private var foo = "something"

    println("in User constructor")

    def printme() = println(name + ":" + comment)
  }
</code></pre>

<p>Any “class parameters” which are prefixed with val or var are simultaneously constructor-parameters and members of the class; the members are automatically initialized to whatever the caller provided (saving the often boring boilerplate found in many Java class constructors). Parameters without val or var are available only during the execution of the constructor - but they can be used to initialise regular members, or “captured” as shown in the definition of method <code>printme</code>.</p>

<p>The primary constructor can be made private just like a Java constructor can be made private, via <code>class User private (...) {..}</code>.</p>

<p>The modifier on class-parameter id is “val”, so this becomes an immutable member with a public getter. The modifier on “name” is var, so this becomes a mutable member with auto-generated public getter and setter. There is no modifier on comment, so it is not stored on the class - but is “captured” by method <code>printme</code> so a reference to <code>comment</code> <em>is</em> effectively part of the class. As shown by parameter <code>yearOfBirth</code>, class-parameters can be explicitly declared “private var” or “private val” if desired.</p>

<p>As with method parameters, constructor-parameters can have default values.</p>

<p>The Scala compiler generates regular Java “.class” files as output, and running a Java decompiler on the classfile will show that Scala generates a Java class for each Scala class. The class has a constructor matching the parameters in the Scala class-definition, and getters/setters for those params and members declared with val/var.</p>

<p>Overriding the getter or setter for a member is not directly possible. Instead, you define the member as private, then define a read and/or write method which returns the private value:</p>

<pre><code>  class Foo(private var idInternal: Int) {
    // Getter method usable like "var x = foo.id". Note that the method is declared with _no parameters_ (not even an empty-list).
    def id = {
      println("Getting id")
      idInternal
    }

    // Setter method callable like "foo.id = 12"
    def id_=(value: Int) = {
      println("Setting id")
      idInternal = value;
    }
  }
</code></pre>

<p>If defining a setter in this way, it is mandatory to also explicitly define a getter.</p>

<p>The setter method has an underscore between the name and the equals-sign because of the Scala rules on var/method names: a name may only include chars outside the ones allowed by Java if it (a) purely consists of such symbols (eg <code>::</code>) or if the special chars are preceded by an underscore. Allowing things like “id=” or “id++” to be a valid variable or method name would obviously make additional whitespace mandatory in many places, which would be very inconvenient. The “special char is part of the name if-and-only-if preceded by underscore” is a reasonable compromise. In this case, though, it does force the <code>id_=</code> syntax which is a little odd.</p>

<p>A member which is declared without an initial value is “abstract” (obvious for immutables vals; not so obvious for vars). Null may be used as an initialization value.</p>

<p>There are several special method-names that can be defined on a class: apply, unapply, unapplySeq and update. See “special methods” later.</p>

<p>Traits (interfaces) and inheritance are discussed later.</p>

<h2 id="more-on-class-constructors">More on Class Constructors</h2>

<p>Here is an example of a class with some constructor-parameters and constructor logic:</p>

<pre><code>  class User(val id: Int, var name: String, comment: String) {
    println("Primary constructor: running..")

    println("Primary constructor: Initialising internal var isActive")
    var isActive = false

    println("Primary constructor: Initialising internal var foo")
    private var foo = "something"

    // secondary (alternate) constructor
    def this(id: Int) {
      // delegate to the primary constructor above
      this(id, "unknown", "no comment")
    }

    def printme() = println(name + ":" + comment)

    println("Primary constructor: still running...")
  }
</code></pre>

<p>Note that the codeblock after the “class .. “ declaration is actually a kind of method-body, containing code. However variables declared in this method-body are also <em>members</em> of the class, and continue to exist after the constructor completes. This will feel somewhat familiar to Javascript developers, where a “constructor” actually creates variables and defines methods by storing data in the associated map. Scala is of course more statically-typed, but there are some similarities.</p>

<p>The above demonstrates a secondary constructor, which is declared as a method with name “this”. Note that there is no “=” between declaration and implementation. The implementation <em>must</em> itself call “this” to delegate to another constructor (eg the primary).  Of course this particular secondary constructor, which just sets default values for parameters, can instead be implemented by defining default values directly in the primary constructor params..</p>

<p>The primary constructor may be made private via</p>

<pre><code>  class User private (....) {..}
</code></pre>

<p>in which case instances can only be created via secondary constructors, or via factory-methods on a companion object (see later).</p>

<h2 id="case-classes">Case Classes</h2>

<p>Scala has “case classes”, which are effectively a tuple with named elements. They are simple “data representation objects” or “data transfer objects” used for holding a bunch of related data.</p>

<p>A case-class instance is immutable, ie all its members are read-only. It cannot be subclassed (is “final” in Java terms).</p>

<p>It automatically has a public field for each constructor param, as usual for Scala classes - but “private” fields are not supported.  Standard functions equals and toString are auto-generated, as is a <code>copy</code> method (which supports named params to change just specific fields). If there is no existing <code>object</code> declaration with the same name as the case-class, then one is also auto-generated which provides an <code>apply</code> method for creating new instances of that type (factory method) and an <code>unapply</code> method for use with pattern-matching. This all saves a lot of boilerplate code!</p>

<p>A case-class can extend existing classes as long as they have no abstract methods. Constructor params for the parent type(s) are passed along from the case-class constructor as usual in inheritance (see later).</p>

<p>You can define methods on a case-class, and can also define them on the companion object.</p>

<p>Creating an instance of a case-class <em>can</em> be done with the “new” keyword, but is usually done via a factory method on the <em>companion object</em> (which is auto-generated if not defined by the developer); see below. The default <code>copy</code> method can then be used similarly to the builder-pattern if desired to create variants of the original object.</p>

<h1 id="object-declarations-singletons-and-companion-objects">Object Declarations (Singletons and Companion Objects)</h1>

<p>A Scala “object” declaration defines a type of which there will be only one instance at runtime. On application startup, the singleton instance is automatically created; it is not possible to create more instances. The instance can be referenced via its “object name”.</p>

<pre><code>  object MySingleton {
    val PI = 3.14       // declare members as usual
    def foo(...) = ...  // declare methods as usual
  }

  // Call it using its "object name" as the "instance"
  MySingleton.foo()
</code></pre>

<p>Such singleton objects can be used to do the kind of things which Java developers implement as static variables and static methods. It also replaces all use of the (old-fashioned) static-singleton-pattern from Java.</p>

<p>Singleton objects can extend a base class and have traits; they have a proper type after all (unlike Java statics). By default the base class is <code>AnyRef</code> (similar to Java’s Object base type) but the base class can be anything - what is special about an <code>object</code> is not its type, but the fact that there is only one instance of it.</p>

<p>Declaring an object also effectively declares a variable of the same name which points to the singleton instance. Given an object declaration like above, the name “MySingleton” is simply an immutable reference to the singleton instance, just like any other reference variable.</p>

<p>The “main” method of an application (which is static in Java) must be defined on a Scala singleton object as a method named “<code>main(args: Array[String]): Unit</code>”.</p>

<p>When an object-declaration has the same name as a Class definition, and is in the same file, then it is called a “companion object” to the class. A Scala class may call private methods of its companion object, and a companion object may call private methods on its companion class (including private constructors). Because of this, a companion object is commonly used to define <em>factory methods</em> for the type with the same name:</p>

<pre><code>  // class with no public constructor
  class User private (val id: Int, var name: String, comment: String) {...}

  // companion object
  object User {

    // trivial factory method (but not following usual conventions; see below for info on the apply method)
    def create(id: Int, name: String, comment: String) = new User(id, name, comment)
  }

  // Use the factory-method
  var user1 = User.create(1, "fred", "no comment")
</code></pre>

<p>The example above defines a factory-method with name <code>create</code> that returns an instance of the (non-singleton) User class. However in practice, such factory-methods are usually defined as an <code>apply</code> method; see the following section for a quick overview and later for more complete information on <code>apply</code> methods.</p>

<p>If you use a Java decompiler on the generated code for a class with a “companion object”, you will see that the class has a method which returns the “companion object” instance. The implementation of this method returns the value of a static field on the JVM class of the companion object, rather in the way the static-singleton-pattern is traditionally implemented in Java.</p>

<p>The type of a singleton object and its companion non-singleton type are not related in any way - the only link between them is that they happen to share a common name at the Scala sourcecode level and that they have access to each other’s private methods and attributes.</p>

<p>When the compiler is searching for <em>implicit methods and classes</em> related to some class C then the companion object for class C is included in the list of places checked for such definitions. This means that the companion object is a convenient place to define implicit methods for type-casting and other interesting behaviour. See later for a discussion of implicit typecasts and implicit methods.</p>

<p>Scala object-types should not be overused. Statics are a pain when testing in Java; it is far nicer when a class under test has a “provider object” injected into it during construction. In production Java code, the object injected can be a singleton while in testing it can be a mock. The same approach should be taken in Scala, ie if you may need to mock instances for testing then don’t make them singleton “objects”.</p>

<p>When programming in Scala in a truly functional style, an application may have few or no class-declarations at all; instead case-classes are used for declaring data-structures and then methods on <code>object</code> declarations are used to manipulate those datastructures, with higher-order functions (functions as parameters) used for structuring dataflows rather than object-oriented interface/class relations.</p>

<h2 id="the-apply-method-as-factory">The Apply Method as Factory</h2>

<p>A method named “<code>apply</code>” on a class or singleton-object acts as a “default method” which can be invoked without specifying its name. If a class named Foo has a method named apply, then it can be invoked on an instance of Foo like <code>someFoo.apply(12)</code> or simply <code>someFoo(12)</code>. As seen in the first example above, methods on an object-declaration SomeObject are invoked as <code>SomeObject.method(..)</code>; thus an apply-method can be invoked simply as <code>SomeObject(...)</code>. This makes the <code>apply</code> method a nicer way to provide factory methods for the class of the same name than the “create” method approach shown above:</p>

<pre><code>  // class with no public constructor
  class User private (val id: Int, var name: String, comment: String) {...}

  // companion object
  object User {
    def apply(id: Int, name: String, comment: String) = new User(id, name, comment)
  }

  // Use the factory-method: invokes singleton-object-method User.apply(...)
  var user1 = User(1, "fred", "no comment")
</code></pre>

<p>This factory-pattern (companion with apply-method) can be found often in Scala, eg the standard List type: “<code>val mylist = List(....)</code>” invokes <code>List.apply(...)</code> on “object List”.</p>

<p>Quite often the companion object for an <em>abstract class</em> will define an apply-method which acts as a factory for the <em>default implementation</em> of that type.  Example: <code>Seq(1,2)</code> returns a List (List of course is a subtype of Seq) - though maybe that is not the best possible example as that specific code-path is somewhat indirect:</p>

<ul>
  <li>Companion object Seq extends SeqFactory which extends GenSeqFactory which extends GenTraversableFactory which extends GenericCompanion</li>
  <li>Method <code>GenericCompanion.apply</code> calls back into <code>SeqFactory.newBuilder</code> which returns <code>new mutable.ListBuffer</code>
</li>
  <li>Calling <code>.result</code> on the ListBuffer then returns an immutable list.</li>
</ul>

<p>See later in this article for more information on <code>apply</code> methods.</p>

<h1 id="traits-interfaces">Traits (interfaces)</h1>

<p>Scala’s equivalent of Java interfaces is the <em>trait</em>. It works similarly to interfaces, and is pretty obvious.</p>

<p>A trait is meant to be used to define behaviour that is relevant to many different unrelated types, eg “serializable” could be a good trait, or “closeable”:</p>

<pre><code>  trait Closeable {
    def close(): Unit
  }
</code></pre>

<p>Traits may (obviously) have abstract method definitions. Like class-based abstract methods, the return-type must be explicitly defined.</p>

<p>Like Java8 interfaces, traits may also have concrete method definitions - methods with bodies.</p>

<p>Unlike interfaces, traits can also declare members:</p>

<ul>
  <li>
    <p>When the member is abstract (not initialised with a value) then any class which implements that trait <em>must itself declare</em> a member with that name. A similar effect can be obtained in Java by having the interface define abstract getter/setter methods and then use these in a concrete method implementation on the interface.</p>
  </li>
  <li>
    <p>When the trait member is initialised then all classes which inherit from the trait automatically get a member of that name. This isn’t quite the same as inheriting a member from an ancestor class, ie this isn’t full “multiple inheritance”; see “linearization” below.</p>
  </li>
</ul>

<p>Traits do not have constructors.</p>

<p>Traits which declare members (whether abstract or not) are often refered to as <em>mixins</em>.</p>

<p>To support traits with members (which are not allowed in Java interfaces), each Scala <code>trait</code> actually generates JVM bytecode for both an interface (named in the usual manner) and an abstract class named <code>{traitname}$class</code>. This is normally irrelevant in pure Scala code, but can be useful to know when interacting with Scala libraries from Java code.</p>

<h1 id="inheritance">Inheritance</h1>

<p>Scala inheritance works reasonably similarly to Java, but the syntax is a little different:</p>

<pre><code>    class Derived (val arg1: Int, arg2: String)
      extends Base(arg2) with Closeable with Serializable {
      ...
    }
</code></pre>

<p>At most one base class may be specified, but multiple traits are permitted. The first ancestor type is indicated using “extends” and subsequent ones are indicated using “with”.</p>

<p>Any parameters required by the base-class must simply be mapped 1:1 from constructor-params of the subclass; if the param to a base class needs to be computed somehow, then the constructor can be made private and that logic can be done in a factory method. Neither “val” nor “var” can be specified on arguments being forwarded to the base-class; that would imply the subclass having a field duplicating one from the base class which doesn’t make sense.</p>

<p>Traits do not have constructors, so a class never needs to pass arguments to a trait it implements.</p>

<p>A problem with multiple-inheritance of traits or interfaces is what to do when the same method (or field in the case of traits) is defined in multiple ancestor types. In Scala, the <em>order</em> in which traits are listed in the “with” clause is significant in resolving these conflicts (see “linearization” later). Java8 simply reports a compiler-error in this case.</p>

<p>A trait may extend a <em>class</em> as well as another trait - as long as the ancestor class has a constructor with no arguments. In this case, the trait may use “super” in its method-definitions to call methods on the base class. When a concrete class mixes in multiple traits which extend the same base type and override the same method, then overridden methods in traits are invoked somewhat like a chain of superclasses - in the order in which the concrete class declares the mixins.</p>

<p>When a subclass reimplements a concrete method defined in an ancestor type, the Scala keyword “override” must be added to the “def” statement (similar to Java’s @Override annotation, but mandatory). As in Java, keyword “super” is used to invoke methods in the base class.</p>

<p>When a class does not declare an ancestor type then its default ancestor type is standard type AnyRef (similar to Java’s Object type).</p>

<p>Guidelines for subclassing:</p>

<ul>
  <li>never derive an abstract class from another abstract class</li>
  <li>never derive a concrete class from a concrete class except to add mixins (pure logic without fields)</li>
  <li>when a problem seems to require one of the above, try to use the <em>adapter</em> pattern.</li>
</ul>

<h1 id="linearization-of-traits">Linearization of Traits</h1>

<p>When the Scala compiler encounters a class which inherits from a trait, it actually uses the trait as a  kind of “template” from which a new abstract class is generated.</p>

<p>For a class declared as “<code>class Foo extends Base with Trait1 with Trait2</code>” the compiler generates an abstract class C which extends Base and “pastes in” any non-abstract contents of Trait1, then another abstract class D which extends C and “pastes in” any non-abstract contents of Trait2. Class Foo then extends class D. The generated classes implement the JVM-level interfaces corresponding to each trait, but the implementations (methods and members) are “specialized” for the class which extends them.</p>

<p>This process is called “linearization”; obviously it does increase the number of classes in the classpath (runtime overhead) but this approach allows traits to have non-abstract members without the problems of full multiple-inheritance. Linearization provides some additional advantages over interfaces; in particular, a trait can <em>override</em> a method inherited from an ancestor class; this allows effects similar to AOP (aspect-oriented programming) method interceptors.</p>

<h1 id="anonymous-subclasses">Anonymous Subclasses</h1>

<p>The syntax “<code>new Foo with Bar</code>” creates a new instance of an anonymous class which is a subclass of Foo and implements Bar. Any custom code in the new anonymous class can reference methods defined in the “with” mixin. All code in the same scope also sees the variable as the anonymous subtype, ie can call the mixin methods. Obviously if the instance is passed into some other function or returned then it is only accessable as the specified param-type or return-type.</p>

<h1 id="sealed-classes-and-traits">Sealed Classes and Traits</h1>

<p>A class or trait declared as “sealed” can only be subtyped <em>in the same file</em>. This allows the developer/compiler to know the <em>full set of subtypes</em> is fixed. This is particularly useful in pattern-matching statements (similar to Java switch-statements) where the compiler can determine whether a “default” clause is required or not.</p>

<p>Sealed traits are a very common pattern in the functional-programming community and are called “sum types” (a kind of Algebraic Data Type aka ADT). A trait (interface) is declared, and then the complete set of implementations of that interface are declared in the same file.</p>

<p>As with Java, the keyword <code>final</code> prevents classes from being subclassed at all.</p>

<h1 id="the-implicit-keyword">The Implicit Keyword</h1>

<p>Here is a brief summary of the three kinds of functionality which use the ‘implicit’ keyword. For more information on implicits, see <a href="https://docs.scala-lang.org/tour/implicit-conversions.html">the official reference</a>.</p>

<p>All kinds of implicit behaviour should be used sparingly - it can make the code flow hard to read.</p>

<h2 id="implicit-type-conversions">Implicit Type Conversions</h2>

<p>When an object of type T is passed as a parameter to a method which expects a parameter of type Q, and T does not inherit from Q then the compiler does not just give up, as would be the case in Java. Instead, the compiler looks for an implicit wrapper class or an implicit wrapper method which takes an instance of T and returns an instance of Q; if one is found then the necessary call to convert the T to a Q is inserted automatically.</p>

<p>A wrapper class can be defined as <code>implicit class SomeName(arg:T) extends Q ...</code> ie a class whose constructor takes a single instance of the type to be converted from, and which implements the target type.</p>

<p>Alternatively, a wrapper method can be defined as <code>implicit def someName(t:T): Q = ..</code>.</p>

<p>The class or method can be declared locally, or be brought into scope via an <code>import</code> statement.</p>

<p>One limitation is that this does not work well for objects being passed around as some abstract type. The lookup of the implicit conversion method/class is done on the <em>declared type</em> of the variable, not its runtime type.</p>

<h2 id="implicit-methods">Implicit Methods</h2>

<p>When a method M is invoked on a type T which does not have any such method, the compiler searches for an implicit type conversion (see above) which converts T to a type which <em>does</em> have method M.</p>

<p>Interestingly, this effectively allows “adapters” to be defined for a type transparently, which is basically equivalent to adding methods to a type without modifying the definition of that type. This is similar to a Haskell “type class” or C# “extension methods”. Given some interface (trait), an implicit class can be defined that takes an instance of some type T and returns an adapter which implements that trait for that type.</p>

<p>These implicit conversions are used to handle mixed-type arithmetic, eg adding ints and longs. In most cases, the implicit-method-invocations are inlined in the generated code.</p>

<p>The standard-library type <code>Option</code> can be implicitly converted to a list of 0 or 1 items; this allows using an Option in a list-comprehension, ie “dynamically” makes all List operations also available on Option instances, as Option instances can be <em>converted</em> to instances of List.</p>

<p>Some plain Java types (eg String) have implicit conversions to Scala wrappers which provide additional related methods. The primitive Java types have implicit conversions to “objectify” them, (ie a Java integer can be treated as a scala.lang.Int).</p>

<p>There is a Scala standard package which provides implicit converters for Java collection types, transparently mapping them directly to Scala standard library equivalents. However this package is no longer recommended; the Scala standard library also offers a different package which provides implicit conversions to various wrapper types each of which offers a method “<code>asScala</code>” - ie these types are not <em>directly</em> converted to a Scala collection, but instead converted to an intermediate form that provides the <em>option</em> to elegantly but explicitly convert to the Scala equivalent.</p>

<h2 id="implicit-parameters">Implicit Parameters</h2>

<p>A method can include the keyword “implicit” once at any point in its parameter-list; all parameters declared after that point are implicit-parameters. An example is <code>def foo(i:Int, implicit w:Widget) = ..</code>. When such a method is invoked the caller can specify a value for implicit parameters, just like normal parameters. However if the caller does not specify a value (passes fewer arguments to the method than declared) then the compiler looks for a declaration of an implicit value of the appropriate type somewhere in the current lexical scope, and passes that value automatically as the parameter.</p>

<p>The exact rules for where the compiler looks for “suitable declarations” are a little complex, but the following are among the options:</p>

<ul>
  <li>
<code>implicit val someobj = ...</code>  in the local method</li>
  <li>
<code>implicit val  ..</code> on some type specified in an import-statement</li>
  <li>
<code>implicit val ...</code> on the companion object of the object on which the method is being invoked.</li>
  <li>
<code>implicit object ...</code> somewhere in scope; declaring an object-type effectively declares a variable of the same name, ie a <code>val</code> referencing the singleton instance of that type, and is thus conceptually the same as the previous options. Remember that singleton objects can implement traits…</li>
</ul>

<p>The companion-object lookup is particularly useful when subclassing a type or trait which defines a method with an implicit param; the subtype can define an appropriate implicit object to use as a parameter for all instances of that subtype (when not overridden by the caller via a local implicit val or an imported implicit val).</p>

<h2 id="type-classes-adding-functionality-to-classes">Type Classes (adding functionality to classes)</h2>

<p>The ability to require an implicit parameter for a method provides an indirect, but very powerful, way to extend the functionality of existing classes without “wrapping” it as described in the sections on implicit type conversions and implicit methods.</p>

<p>The design pattern is as follows:</p>

<ul>
  <li>design a trait that could potentially be used with many different types of object</li>
  <li>when defining methods which operate on objects of this trait, do not constrain the input parameter to be of a specific type - instead require an implicit parameter that implements that trait for the input argument type.</li>
  <li>and in the method implementation, use methods on the implicit parameter to manipulate the parameter object(s) rather than invoking methods directly on the parameters (ie program in functional-style rather than object-oriented-style).</li>
</ul>

<p>This looks something like the following:</p>

<pre><code>trait WantedTrait[T] ...
  
def someMethod[P](obj:P)(implicit WantedTrait[P] operations) = {
   operations.doSomething(obj)
}
</code></pre>

<p>The code <code>someMethod(arg)</code> will compile when arg has type SomeType if (and only if) there is an implicit object in scope which implements <code>WantedTrait[SomeType]</code>. Or in other words, someMethod can be used on any type X by defining a suitable implicit implementation of <code>WantedTrait[X]</code>. That makes someMethod extensible to handling any type - as long as a sensible implementation of WantedTrait can be defined for it. This is the essence of the “type class” concept from the Haskell functional language. And importantly, it requires instantiating no wrapper classes around the parameter at runtime - the implementation of <code>WantedTrait[X]</code> for any X should be a singleton, ie the implicit method call just passes a reference to an already-existing and stateless object.</p>

<p>Scala has a “shortcut syntax” for this pattern: <code>def someMethod[T: WantedTrait](obj:P)</code> is eauivalent the the longer definition above.</p>

<p>A more detailed explanation of the concept can be found <a href="http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html">here</a>.</p>

<p>It is unlikely that a Scala beginner will implement such code, but this pattern is found sometimes in external libraries - and even in the standard Scala library, so it is good to be able to recognise what it is doing.</p>

<h1 id="structural-typing">Structural Typing</h1>

<p>Scala allows class-generic-types and method-parameter-types to be defined “inline”; such a declaration is called a <em>structural type</em>. It is then possible to use any type which has the appropriate properties.</p>

<p>Because the following method uses a structural type for its parameter, any object with a no-args method called “name” may be passed here:</p>

<pre><code>  def onAnyNamedObject( target: { def name:String }) = {
    println(target.name)
  }
</code></pre>

<p>Structural typing is only available when an inline type is explicitly specified; it doesn’t mean that an instance of some class T1 can be cast to a different class T2 just because T1 is a superset of the properties/methods of T2.</p>

<p>Structural type usage is checked at compile-time for correctness. However at runtime, this is currently implemented via reflection - ie this has a performance impact.</p>

<h1 id="packages-and-import-statements">Packages and Import Statements</h1>

<h2 id="declaring-packages">Declaring Packages</h2>

<p>Scala code is grouped into packages as with Java; a Scala sourcefile should start with a package-declaration like:</p>

<pre><code>  package foo
</code></pre>

<p>All declarations following that line is within package foo. There is no absolute requirement on the directory-name in which the file is stored (Scala tools <em>can</em> work with any desired structure). However some tools do assume that Scala code in package X is in a directory with the same name, so that layout is still recommended.</p>

<p>Scala code often does not follow the Java package-naming convention of “reverse internet domain names” (eg com.example.projectname.componentname); instead much “flatter” structures are often used. The Scala standard libraries are usually just under package “scala”.</p>

<p>Packages can be defined with nested syntax:</p>

<pre><code>   package foo
   package bar // nested inside foo, ie foo.bar
</code></pre>

<h2 id="importing-stuff">Importing Stuff</h2>

<p>Imports work similarly to Java, ie provide a short alias for the full name of something. However there are a few special things about imports in Scala.</p>

<p>Wildcard imports use the “<code>_</code>” character rather than “<code>*</code>” (because “<code>*</code>” is a valid name in Scala).  A single “<code>_</code>” is a reserved word and thus not a valid type or function-name.</p>

<p>The import statement can be used to enable certain Scala language features; an import starting with “scala.language.” is not a real package but rather an indication that the specified feature should be enabled for the following code.</p>

<p>An import-statement can define a local “alias” for an imported type to avoid name clashes.</p>

<p>An import-statement can import multiple types via <code>import com.example.{Type1, Type2}</code>.</p>

<p>An import-statement can be used to import the <em>methods and members</em> of a type (usually an object-declaration), making its members and methods accessible without a dot; <code>import com.example.Widget._</code> where Widget is a singleton object will make all the methods of Widget available without needing <code>Widget.</code> as a prefix.</p>

<p>Unlike in Java, an import statement can be placed anywhere in a Scala file, and it is <em>scoped</em> exactly like variable declarations. When a type is used only in one function, the corresponding import statement can be placed in only that function.</p>

<p>The compiler first tries to resolve an imported package relative to previous imports in the same file. Given:</p>

<pre><code>import com.example.foo
import com.example2.bar
import foo.baz
</code></pre>

<p>the compiler resolves the last import as <code>com.example.foo.baz</code>.</p>

<h2 id="package-objects">Package Objects</h2>

<p>Java supports a single file literally name <code>package-info.java</code> in each package (filesystem directory). However in Java, the only things such a file can contain is the package declaration, with attached annotations and javadoc.</p>

<p>Scala similarly supports a single file in each package literally named <code>package.scala</code>. For a package <code>com.example.foo</code>, this file should contain:</p>

<pre><code>package com.foo

package object foo {
}
</code></pre>

<p>Scaladoc (javadoc-like documentation) and annotations be attached to the “package object”, as in Java. However the package object can also define types, constants, and methods which are useful for all code in the package. The contents of the “package object” are implicitly imported into every other file in the package.</p>

<h1 id="access-control">Access Control</h1>

<p>Scala supports modifiers to control access to classes (and methods):</p>

<ul>
  <li>Modifier “public” works just like Java - but is seldom seen as it is the default in Scala.</li>
  <li>Modifier “protected” is similar to Java (grant access to subclasses) but unlike Java it does not grant access from code in the same package</li>
  <li>Modifier “private” is similar to Java, but does not apply to any “companion object” in the same file.</li>
  <li>Modifier “implicit” is complicated; see the dedicated section on this.</li>
  <li>There is no “package scope” modifier (and omitting a modifier implies public). Instead package-access is granted via an attached “scope”; see below.</li>
</ul>

<p>It feels a little strange for things to be public by default, but (a) Scala uses immutable variables and pure functions much more than Java, making it less dangerous and (b) what looks like direct access to a public field in Scala is actually a method-call with zero parameters, allowing an accessor method to be defined later if desired without breaking calling code.</p>

<p>The Java modifier “abstract” is not needed on methods in Scala; any method without a body is abstract. The abstract modifier can be applied to classes.</p>

<p>A modifier can have a “scope” applied to it, eg <code>private[com.example.widgets]</code>; this example makes the class private (ie it can only be accessed by the class itself, or a companion object) but then grants access to all code within the specified package, and its sub-packages. The specified package can be absolute, or be a component of the current package eg when the current package is <code>com.example.acme.widgets</code> then <code>private[acme]</code> is valid.</p>

<h1 id="generics">Generics</h1>

<h2 id="generic-types">Generic Types</h2>

<p>Scala has generics somewhat similar to Java, though more powerful and with a different syntax. Type-params are specified in square brackets (“<code>[]</code>”).</p>

<p>To declare an instance of a generic type:</p>

<pre><code>  val myStrings = new List[String]
</code></pre>

<p>To declare a parameter of a generic type:</p>

<pre><code>  def printAll(items: List[String]) = ...
</code></pre>

<h2 id="covariance-contravariance-and-type-bounds">Covariance, Contravariance and Type Bounds</h2>

<p>The tricky Java-generics “covariants” and “contravariants” support (“<code>&lt;T extends P&gt;</code>” and “<code>&lt;T super P&gt;</code>”) is replaced by expressions like:</p>

<pre><code>  class Stack[+A] {
    def push[B &gt;: A](b: B): Stack[B] = ...
  }
</code></pre>

<p>More obvious? No, not obviously. However it is more powerful. The above declarations mean that given a stack which holds objects of type A or its subtypes, method push takes a parameter which must be a subtype of A.</p>

<p>The equivalent of the Java generic “?” is Scala’s “Any” type. All Scala types are subtypes of Any (including Int, Boolean, etc). The wildcard “<code>_</code>” can also be used.</p>

<ul>
  <li>
    <p>“<code>A&lt;:B</code>” is an “upper type bound” (A must be an ancestor of B). This is equivalent to Java “<code>&lt;? extends B&gt;</code>”. Defines “out” types, useful to constrain types <em>returned</em> from methods.</p>
  </li>
  <li>
    <p>Syntax “<code>B&gt;:A</code>” is a “lower type bound” (B must extend A). This is equivalent to Java “<code>&lt;? super B&gt;</code>”. Defines “in” types, useful to specify types <em>passed</em> to methods.</p>
  </li>
  <li>
    <p>“<code>List[_]</code>” is equivalent to Java “<code>List&lt;?&gt;</code>”</p>
  </li>
</ul>

<h2 id="generic-type-parameters-via-abstract-type-declarations">Generic Type Parameters via Abstract Type Declarations</h2>

<p>The simplest way to define a generic type is like <code>class Foo[A] ....</code>.</p>

<p>An alternative way to express generic type parameters is to embed the types within the class body.  An abstract class can include definition “type T” which is equivalent to Java generic syntax “<code>&lt;T&gt;</code>”. Some subclass then declares “<code>type T = sometype</code>” to complete the definition. As example:</p>

<pre><code>  class MyGenericClass {
    abstract type Foo
    abstract Foo templateFn()
  }
</code></pre>

<p>The above approach does require that a subclass be declared. The alternative syntax <code>class Foo[T]</code> does not; a declaration can be made inline eg <code>val foo: MyGenericClass[Integer]</code>. However the abstract type syntax can be clearer in some cases.</p>

<ul>
  <li>adding upper-bounds or lower-bounds to a type-decl makes it more restrictive</li>
  <li>adding variance declarations makes it less restrictive (since the default is invariance)</li>
</ul>

<h2 id="variance">Variance</h2>

<p>Given that B is a subtype of A, what is the relationship between <code>List&lt;A&gt;</code> and <code>List&lt;B&gt;</code>?</p>

<ul>
  <li>invariant: no relation, incompatible</li>
  <li>covariant: <code>List&lt;B&gt;</code> can be cast to <code>List&lt;A&gt;</code>, ie someListOfA = someListOfB</li>
  <li>contravariant: <code>List&lt;A&gt;</code> can be cast to <code>List&lt;B&gt;</code>, ie someListOfB = someListOfA.</li>
</ul>

<p>In general, covariance is useful when <em>reading</em> values of the generic type, while contravariance is useful when <em>writing</em> values of the generic type. Or in other words:</p>

<ul>
  <li>when a type is declared as covariant (with +A) it can be used as a return-type for methods (out), but not a param-type (in).</li>
  <li>when a type is declared as contravariant (with -A) it can be used as a param-type (in) but not a return-type (out).</li>
</ul>

<p>Java classes are always invariant, except in two special cases: arrays and method-return-types.</p>

<p>An example of Java array covariance:</p>

<pre><code>// Create a "view" of the underlying string array as a different type
Object[] objarray = new String[]{"s1", "s2"};

// Same principle as above, this time with a parameter instead of a variable
void methodTakingArray(Object[] data) {...}
methodTakingArray(new String[]{"p1", "p2"});

// Negative side of array covariance: covariance is good for _reading_ but bad for _writing_..
objarray[0] = Boolean.TRUE; // this write-operation compiles but throws exception at runtime!
</code></pre>

<p>And in Java, given a parent type defining a method returning A, a subtype can override the method and return a subtype of A.</p>

<p>Scala has very sophisticated facilities for expressing generic variance constraints, including:</p>

<ul>
  <li>
<code>List[+A]</code> (covariance)</li>
  <li>
<code>List[-A]</code> (contravariance)</li>
</ul>

<p>Immutable collections are “read only” and therefore can be safely declared as covariant on the datatype they contain; Scala’s standard immutable types do this.</p>

<h2 id="generic-self-types">Generic Self Types</h2>

<p>A trait can declare “<code>this: sometype =&gt;</code>” which requires that any type extending that trait must be a subtype of sometype. Method implementations on the trait can then access methods defined on the specified type-bound. Example uses are traits which can only be used together with types that are “serializable” (have a write method) or “ordered” (have a compare method).</p>

<h1 id="pattern-matching">Pattern Matching</h1>

<p>Patttern-matching is like a “super switch statement”:</p>

<pre><code>  val result = somevar match {
     case pattern1|pattern2 =&gt; val1
     case pattern3 =&gt; val3
     case _ =&gt; defaultval
  }
</code></pre>

<p>Most of the built-in types support pattern-matching. Case-classes automatically support pattern-matching. Custom classes are useable with pattern-matching when some class defines an “unapply” method which takes an instance of the custom type and returns a tuple representing the object’s matchable state; this method is often defined on the “companion object” for a type.</p>

<p>A statement of form “<code>x match { case Foo(p1,p2) ..}</code>” will result in a call to “<code>Foo.unapply(x):Option[sometuple]</code>”. When no such method exists, or the method returns “None”, then the case is considered not to match, otherwise the values in the returned tuple are compared to or bound to p1,p2,etc.</p>

<p>There is an “isInstanceOf” method defined on a base Scala type (and thus available on every object). However it is considered better style in Scala to use pattern-matching when the type is not known. Expression <code>case val: SomeType =&gt; ..</code> matches only if val is of the specified type.</p>

<p>The full details of pattern-matching are too complex to be described here. I have written a separate <a href="/java/scala-match">article dedicated to Scala pattern-matching</a>.</p>

<h1 id="destructuring-bindings">Destructuring Bindings</h1>

<p>A <em>destructuring binding statement</em> (also known as <em>destructuring assignment</em>) can extract values from a tuple:</p>

<pre><code>val mytuple = (2, "hello", List(1,2,3))
val (a, b, _) = mytuple // a=2, b="hello"
</code></pre>

<p>An assignment statement can also extract values from a case-class (or other type for which an unapply method exists):</p>

<pre><code>val myWidget = MyWidget(2, "hello", List(1,2,3))
val MyWidget(a, b, _) = myWidget // a=2, b="hello" - assuming MyWidget.unapply(..) is implemented in the usual manner..
</code></pre>

<p>The same destructuring-based access to fields within a tuple or case-class can be used in a map-function:</p>

<pre><code>// below, variables "s" and "i" are assigned to components of the tuple as each is processed..
List(("tuple1", 45), ("tuple2", 67)).map { case (s, i) =&gt; "" + i + s }.foreach(println)
</code></pre>

<h1 id="functions-and-lambdas">Functions and Lambdas</h1>

<h2 id="anonymous-function-declaration">Anonymous Function Declaration</h2>

<p>Method declarations use the “def” keyword and are statements; they have a side-effect and return no result. They are also “compile-time-only” structures.</p>

<p>Function definitions instead return a result that must be stored in a variable or passed as a parameter. They are partly compile-time; the compiler checks the syntax and generates code for them. However because they “return a result”, they are also have runtime behaviour. Functions are also called <em>anonymous functions</em>, <em>closures</em>, or <em>lambdas</em>.</p>

<p>Function declaration syntax is <em>similar to</em> method-declaration syntax. However it:</p>

<ul>
  <li>does not use “def”</li>
  <li>puts the args before a “=&gt;” operator</li>
</ul>

<p>The full syntax is:</p>

<pre><code>   val f1 = (x:Int, y:Int):Int =&gt; {return 0}
</code></pre>

<p>Often the return type can be deduced:</p>

<pre><code>   val f1 = (x:Int,y:Int) =&gt; {return 0}
</code></pre>

<p>The return-statement can usually be omitted. And when the body is just one line, the braces can be omitted:</p>

<pre><code>   val f1 = (x:Int, y:Int) =&gt; 0
</code></pre>

<p>More examples of anonymous function definitions:</p>

<pre><code>  var f1 = (x: Int) =&gt; x + 1
  var f2 = (x: Int, y:String) =&gt; {...}
  var f3 = () =&gt; println("Hello, World")
</code></pre>

<p>As with method declarations, braces are optional when the body only has one line, and the “return” keyword is optional (and usually omitted).</p>

<p>Because the “this” reference associated with a method defined on a Scala “singleton object” is always uniquely identifiable, methods on singleton objects can also be used as functions:</p>

<pre><code>  var pln = scala.Predef.println
</code></pre>

<p>This is similar to the way Java can use static methods as lambdas via syntax like “System::println”. Methods of a singleton object can actually be <em>imported</em> via an import-statement, making them callable without needing the name of the singleton object type - and all methods of <code>scala.Predef</code> are imported by default, thus “println” can simply be written directly.</p>

<p>Lambdas are sometimes called functions or anonymous functions.</p>

<p>The (formal params) part can be left out; the code can then refer to the parameters using “<code>_</code>”, eg the following are equivalent:</p>

<pre><code>  var f1a = (msg: String) =&gt; println(msg)
  var f1b = println(_)
</code></pre>

<p>In f1b, the compiler detects that the right-hand-side of an expression contains an underscore, and realizes that this expression is not a simple method-call but instead an anonymous function definition. This allows the function to be defined without the leading <code>(..) =&gt;</code> syntax. The compiler can deduce that the type of the input parameter to this function is whatever type function <code>println</code> takes as parameter.</p>

<p>Some more examples:</p>

<pre><code>  var f2a = (x:Int, y:Int) =&gt; x + y
  var f2b = (_ + _)  // Question: how are the types determined here?

  var f3a = list map { x =&gt; sqrt(x) }
  var f3b = list map { sqrt(_) }
  var f3c = list map sqrt
</code></pre>

<p>In f2b, there are two underscores, so the function assigned to f2b will have two parameters. The type of the arguments is ?? (try the REPL to find out..)</p>

<p>Anonymous functions can “capture” referenced variables in their context (ie the function body refers to a value which is in scope but not a parameter), in which case they are called <em>closures</em>.</p>

<p>I personally find the “<code>_</code>” syntax rather ugly - something like “$1” might have been nicer. However using underscores for param-placeholders has a long tradition in functional programming languages.</p>

<h2 id="declaring-methods-which-take-a-function-as-parameter">Declaring Methods Which Take a Function as Parameter</h2>

<p>When defining a method which takes a function as a parameter, the syntax looks like:</p>

<pre><code>   // first param is a function with one Int parameter and a String return value
   def high1(f: Int =&gt; String): String = ....`

   // first param is a function with two Int parameters and a Double return value
   def high2(f: (Int, Int) =&gt; Double): String = ....`

   // second param is a function with no parameters and a Long return value
   def high3(a: String,  f: () =&gt; Long): () = ....`
</code></pre>

<h2 id="partial-function-application-aka-currying">Partial Function Application aka Currying</h2>

<p>Scala supports partial function application in several ways. The general concept of partial function application is that a function which has N parameters may be converted into a new function which has N-1 parameters with the other parameter now being bound to a fixed value. This is also called <code>currying</code>.</p>

<p>In one approach, method parameters are declared in multiple parameter-groups eg “<code>SomeMethod(f:ftype)(g:gtype)</code>”. Invoking <code>SomeMethod(p1)</code> returns a reference to something that now takes just a gtype parameter. Both calls can be immediately invoked via something like “<code>SomeMethod(p1)(p2)</code>”. As described in the previous section, Scala allows a method with just one parameter to be given a <em>code block outside of the arguments parentheses</em>; defining SomeMethod with two parameter-groups therefore allows it to be invoked like <code>SomeMethod(f1){..}</code> which would not be the case if SomeMethod had just been defined with one parameter-group containing f and g. Writing a code-block in this way is just syntactic sugar - but it can make code look elegant.</p>

<p>When executing code like <code>val lhs = rhs</code> with rhs being a function-type then Scala’s type-inference assumes that lhs has a type which is the return-type of rhs, and thus rhs is invoked. If lhs should instead be a <em>reference to function rhs</em> then either lhs must be given a type (eg <code>val lhs: ()=&gt;Unit = rhs</code>) or rhs must be given a wildcard parameter-list (<code>val lhs = rhs _</code>) to make it clear to the compiler what is desired. Unfortunately in this case, Scala’s support for invoking a function without a parameter list, together with its type-inference, makes this additional underscore necessary.</p>

<p>A function with multiple parameters can be curried with syntax like <code>val multiplyBy3 = multiply(3, _:Int)</code>, which returns a function taking one parameter that delegates to the underlying function <code>multiply</code>.</p>

<p>Alternatively, a function defined with multiple parameters can be explicitly converted to curried-form via syntax “<code>(fname _).curried</code>”, after which it can be “partially applied” as desired.</p>

<pre><code>  def runme(arg0: String)(arg1: String) = {   // curryable method with more than one argument-lists
    println(s"runme: $arg0, $arg1")
  }

  // arg1 is a normal param, not call-by-name, so the following code-block is evaluated
  // eagerly before runme is invoked.
  runme("hello") {
    "big" + " world"
  }
</code></pre>

<p>When a code-block is specified where a parameter is expected, and the parameter has a normal type, then the code-block is evaluated eagerly and the result is passed to the invoked function. When the parameter is marked as “call-by-name” then the code-block is passed as a closure; see later for call-by-name aka lazy parameters.</p>

<h2 id="explicitly-using-the-function-classes">Explicitly using the Function Classes</h2>

<p>References to functions are actually represented as references to instances of one of the <code>Function*</code> types from the Scala standard library.</p>

<p>Type <code>Function1[Arg1, Out]</code> represents all functions which take one parameter; the second generic type in the signature is the return-type. Similar types are defined for functions with more parameters.</p>

<p>The following are equivalent:</p>

<pre><code>val succ = (x:Int) =&gt; x + 1

val succFunction = new Function1[Int,Int] {
  def apply(x:Int): Int = x + 1
}
</code></pre>

<p>Here succFunction is an instance of an inline-defined anonymous subclass of Function1, and that subclass defines the “function logic” in the default “apply” method of that anonymous subclass. It isn’t usual to deal with <code>Function*</code> types directly in Scala sourcecode but they sometimes appear in stacktraces etc.</p>

<h2 id="methods-vs-functions">Methods vs Functions</h2>

<p>Methods are logic that must be invoked in the context of an explicit object instance, ie <code>instance.method(args)</code>. Functions are logic that have no explicit context: it has parameters only: <code>function(args)</code>. However the two are interchangeable.</p>

<p>A method has an obvious functional equivalent: <code>def somefn(obj, args) =&gt; obj.method(args)</code>.</p>

<p>And in the section on currying/partial-function-application above, we have discussed how to take a function with N args and bind the first arg to a fixed value, resulting in a function with N-1 args. So applying that approach to the function above:</p>

<pre><code>val obj = new SomeObject()
val somefn = (obj, args) =&gt; obj.somemethod(args)
val somefn2 = somefn(obj, _) // bind only the first arg

// and now method obj.somemethod has been converted to a function...
somefn(args)
</code></pre>

<p>The function somefn2 has some “hidden context” - the object on which the method will be invoked. However this is not visible to the caller, who can treat somefn2 just like any other function with the same argument list.</p>

<p>The same effect can be achieved more directly:</p>

<pre><code>val obj = new SomeObject()
val somefn2 = (args) =&gt; obj.somemethod(args)  // returns a closure capturing a reference to obj
</code></pre>

<p>or even more directly via:</p>

<pre><code>val obj = new SomeObject()
val somefn3 = obj.somemethod _
</code></pre>

<h2 id="lazy-call-by-name-parameters">Lazy (call-by-name) Parameters</h2>

<p>A method can be defined to take a <em>block of code</em> as a parameter (also known as a “call-by-name argument” or “thunk”):</p>

<pre><code>  def printme(prefix: String, f: =&gt; String) = {
    println("in printme")
    println(prefix)
    val fval = f // triggers evaluation of the codeblock associated with f
    println(fval)
  }
</code></pre>

<p>Note that f looks somewhat like the examples in the previous section which take a function as a parameter - except that here no input-types are specified for the function f, not even an empty list.</p>

<p>Such a method can be invoked as:</p>

<pre><code>  printme("someprefix", {println("evaluating lazy param"); "value-to-print"})
</code></pre>

<p>The code in braces here is not evaluated immediately; instead it forms a <em>closure</em> which is passed to method <code>printme</code>. In effect, param f is <em>lazy</em>.</p>

<p>If method <code>printme</code> had been declared like <code>def printme(prefix:String, f:String)</code> (ie just remove “<code>=&gt;</code>”) then the calling code above would still compile - but the codeblock would be evaluated eagerly.</p>

<p>When the invoked method takes only one parameter, then the parentheses can be dropped (as already described above for normal non-lazy params):</p>

<pre><code>  def printme(f: =&gt; String) = {
    println("in printme")
    println(f)
  }

  printme {
    println("evaluating lazy param")
    "value-to-print"
  }
</code></pre>

<p>A method taking multiple params can be made usable in the above manner by either rewriting the method to use <em>multiple parameter groups</em> where the last group has a single lazy parameter, or by <em>currying</em> (partially applying) the multi-param method to convert it to a single-param method (ie binding all other params to fixed values).</p>

<p>Do NOT write a lazy param block as <code>{return "value-to-print"}</code>; the return executes in the context of the calling method ie returns from the caller!</p>

<h1 id="dynamic-types">Dynamic Types</h1>

<p>A class which “extends Dynamic” can be invoked with any method at all. When the compiler sees that source-code is invoking a method which is not defined at compile-time, and the target type implements Dynamic, then the compiler instead produces code that invokes a suitable generic method on the class; for example invoking a simple no-params “getter” such as <code>obj.fieldname()</code> triggers a call to “<code>obj.selectDynamic(fieldname)</code>”.</p>

<h1 id="loops">Loops</h1>

<p>There is a for-loop that is similar to Java, though the syntax is slightly different:</p>

<pre><code>   for(item &lt;- list) { ...  }
</code></pre>

<p>which is equivalent to</p>

<pre><code>  list.foreach(...)
</code></pre>

<p>Integers are objects, and have a method “to” which return a Range object, which is iterable. This allows things like:</p>

<pre><code>   for(i &lt;- 0 to 9) ..
</code></pre>

<p>which is equivalent to</p>

<pre><code>  (0 to 9).foreach(....)
</code></pre>

<p>The for-loop structure can actually be quite complex, supporting multiple nested expressions with embedded ifs, can be followed by a “yield” statement and other options. And for-loops are actually just “syntactical sugar” for calls to methods flatMap/filter/foreach/map. A more complete discussion of for-loops can be found in the section “for comprehensions” later, after the discussion on flatMap/filter/etc.</p>

<p>While and do-while loops are similar to Java.</p>

<h1 id="standard-library">Standard Library</h1>

<h2 id="collections-sequences-and-lists">Collections, Sequences and Lists</h2>

<p>Scala provides a collections library which has a selection of both immutable and mutable types. The immutable ones should be used where possible. Java’s standard library is also available for communicating with Java code.</p>

<p>This library has helper methods for converting to and from Java’s collection types (for interacting with standard Java libraries).
Collection types support typical functional operations such as foreach, map, flatMap:</p>

<pre><code>   val mylist = List("a","b","c") // use factory method on List companion object to instantiate an immutable list
   mylist.foreach(value =&gt; println(value)) // function aka lambda
   mylist.foreach(println) // method reference (identical behaviour to previous line)
</code></pre>

<p>The standard List type is immutable. Like lisp lists, <em>prepending</em> to such a list is efficient, creating a new list that has new elements at the start then points to the original list as its tail. Syntax: “val foo = newelement :: origlist”, which invokes method “origlist.::”</p>

<p>The Scala List type is a “strict” collection. Its transform methods (eg map, filter) immediately process the input list and produce another list. The Scala View and Stream collections are instead “on-demand” (pipeline or lazy) collections. Their transform methods (map,filter,etc) return <em>closures</em> which pull data from the original collection only as-needed (similar to Haskell). Method <code>List.view</code> produces a view over a list.</p>

<p>A stream is an algorithmically-generated sequence where elements are only produced as needed. However once produced they are retained by the stream (not discarded) - so using a stream to generate 10,000 elements will result in an object which uses lots of memory.</p>

<p>The various standard collection types generally provide a public constructor. Usually they also have a companion-object which provides factory methods. Most also provide a <code>builder API</code>, eg <code>Set.newBuilder()</code> which allows objects to be added one at a time, and then a builder method returns the final immutable datastructure.</p>

<p>The standard mutable datastructures provided by Scala, eg <code>MutableBuffer</code> also have methods to return their contents as an immutable collection. However if the point is simply to create an immutable collection then the builder APIs are considered preferable to creating a temporary mutable collection - and are more typesafe.</p>

<h2 id="arrays">Arrays</h2>

<p>Arrays use () for access, because square-brackets are used for generic-types:</p>

<pre><code>  val foo: Array[String] = Array("hello", "world")
  val hello = foo(0)
  foo(0) = "hi"
  println(foo.mkString(","))
</code></pre>

<p>An Array is an unusual type which is immutable in size but mutable in content (like Java arrays). The <code>Vector</code> type is immutable in both length and content while still providing order(1) access to any element like an array does.</p>

<h2 id="the-option-type">The Option Type</h2>

<p>Standard library type <code>Option</code> can hold either a reference to an object or null - ie represents an “optional value”.</p>

<p>It provides not just a wapper but also a way of saying “skip this value” when applying a function. Chains of calls like <code>summarize(compute(getFoo()))</code> can be tricky in Java when <code>getFoo</code> might return a null, or when compute might return null for a valid input. However <code>Option(getFoo()).map(compute).map(summarize).getOrElse(default)</code> works fine regardless of whether getFoo returned null; the other methods do not need to be option-aware.</p>

<p>Using Option like this is actually related to the functional concept of <code>Monads</code> - though understanding monads is not needed just to take advantage of option’s ability to skip transformations when the wrapped value is null.</p>

<p>Tip: Applying method <code>flatMap</code> to a list of Option objects returns a list of all the <em>defined</em> values, and discards all the None values (each Option is converted to a list of one value or an empty list, and these lists are then flattened).</p>

<p>There is an excellent article on Scala’s Option type <a href="http://danielwestheide.com/blog/2012/12/19/the-neophytes-guide-to-scala-part-5-the-option-type.html">here</a>.</p>

<h1 id="exceptions">Exceptions</h1>

<h2 id="java-style-exceptions">Java Style Exceptions</h2>

<p>Scala has no checked exceptions (all are runtime exceptions). Otherwise, similar to Java.</p>

<p>When calling Java libraries that throw checked exceptions, these are converted to runtime exceptions.</p>

<p>A try/catch block in Scala is almost identical to Java. Only difference is in the catch clause, which uses a match-expression:</p>

<pre><code>   try {
     --
   } catch {
      case expr1: ...
   }
</code></pre>

<p>Because Scala does not check exceptions, there is no equivalent of Java’s “throws” clause on method declarations. This can cause problems if writing Scala code that is intended to be called from Java; the Java compiler will not complain about uncaught exceptions propagating from a Scala method. For Java compatibility, Scala methods can be annotated with <code>@throws</code> annotations; a Java compiler will then treat that method just like an equivalent Java method with a “throws” clause.</p>

<h2 id="the-try-type">The Try Type</h2>

<p>While Scala supports a try/catch syntax for exceptions very similar to Java’s, it is generally considered better style to write methods that return objects representing value-or-error, eg Option, Try or Either, rather than throw exceptions. When invoking a method that does throw exceptions, the standard <code>Try</code> type can be used to handle that method as if it returned (value-or-exception).</p>

<p>Note the difference between <code>try</code> (built-in mechanism, similar to Java) and <code>Try</code> (a standard library type with an apply method which accepts a closure, executes it and maps any exception to a returned value)!</p>

<pre><code>val result = Try {...}
if (result.isSuccess) {...} else {...}
</code></pre>

<p>Rather than simply using <code>isSuccess</code>, a number of possibilities exist, including:</p>

<ul>
  <li>using <code>match</code> with case-clauses for subtypes Success or Failure,</li>
  <li>using <code>getOrElse</code>
</li>
  <li>using method map.</li>
</ul>

<p>As described for the Option type above, invoking monadic methods like map on the result of Try will cause them to be run if the method returned success, and to be skipped if the method threw an exception.</p>

<p>There is an excellent article on using Try <a href="http://danielwestheide.com/blog/2012/12/26/the-neophytes-guide-to-scala-part-6-error-handling-with-try.html">here</a></p>

<h2 id="try-with-resources">Try-with-resources</h2>

<p>While discussing exception-handling and the <code>try</code> operator, there is a related feature in Java: try-with-resources. Scala does not have this syntax - it must be either implemented manually with a try/finally block or a helper method must be used. Fortunately, Scala’s first-class functions makes this easy. See <a href="https://stackoverflow.com/questions/25634455/simple-scala-pattern-for-using-try-with-resources-automatic-resource-manageme">the discussions here</a> for more information.</p>

<p>For the common case of handling just one resource, this solution appealed to me best:</p>

<pre><code> def autoClose[A &lt;: AutoCloseable, B](resource: A)(code: A ⇒ B): Try[B] = {
    val tryResult = Try {code(resource)}
    resource.close()
    tryResult
  }
</code></pre>

<h1 id="list-efficiency">List Efficiency</h1>

<p>In order to support head/tail operations efficiently on lists, they really do need to be singly-linked-lists. It would be possible to have an array-type implementation plus offset; however freeing no-longer-needed head objects is then not possible.</p>

<p>At first glance, such linked lists look inefficient compared to things like Java’s ArrayList - it seems that they would generate lots of heap allocations and deallocations and make a lot of work for the garbage collector.</p>

<p>Fortunately, each list node is always of a fixed size (two pointers, being “item” and “nextnode”). Therefore managing reusable pools of these nodes is pretty easy; just allocate an array of 5000 of them at a time. And freed nodes can go back on the head of the list, so “cache hotness” will work well. The Scala runtime does this automatically, and therefore the memory-management overhead is really not too bad - it is certainly not a generic malloc/free (or garbage-collection operation) for each discarded head node.</p>

<p>Note that although <em>lists</em> are immutable, the elements in the list may be mutable objects.</p>

<h1 id="special-methods">Special Methods</h1>

<p>There are several special method-names in Scala: apply, unapply, unapplySeq and update.</p>

<p>Methods unapply and unapplySeq are used with pattern-matching; see the section on pattern-matching for more information.</p>

<h2 id="apply-method-overview">Apply-method Overview</h2>

<p>If a class defines a method named “apply”, then that method can be called without writing “.apply”. This can be considered “the default method” for the class:</p>

<pre><code>   class User .. {
     def apply(prefix: String) {
     }
   }

   val user = new User()
   user.apply("hello, ")  // normal method invocation
   user("hello, ")  // same as above - but looks like a "function call" not a method-call.
</code></pre>

<p>There can be multiple apply methods with different parameter-lists.</p>

<p>Apply-methods are used in several ways; the two most common are:</p>

<ul>
  <li>defining an apply-method on a class to allow it to act as a “keyed collection” (discussed below)</li>
  <li>defining an apply-method on a companion-object to provide a factory for the corresponding class (already discussed above)</li>
</ul>

<h2 id="map-like-access-with-apply-and-update">Map-like Access with Apply and Update</h2>

<p>The <code>apply</code> method can be used to provide elegant read-access for a class acting as a “keyed collection”. Similarly, magic method <code>update</code> can be used to also provide write-access:</p>

<pre><code>  val i = a(somekey);   // read: compiler converts this to "i = a.apply(somekey)"
  a(somekey) = 1;       // write: compiler converts this to "a.update(somekey, 1)"
</code></pre>

<p>The standard Array class itself uses <code>apply</code> and <code>update</code>:</p>

<pre><code>   val items = new Array("first", "second")
   val item = items(1)  // actually calls Array.apply(Int)
</code></pre>

<p>The standard Map class also uses apply and update to provide access to the values it holds.</p>

<h1 id="standard-functions-map-filter-withfilter-flatmap">Standard Functions map, filter, withFilter, flatMap</h1>

<p>The methods map, filter, and flatMap are common operations in functional languages, and Scala both supports them and uses them widely.</p>

<p>An iterator is an object or function which provides a series of objects one after another. A sequence is an object which can be iterated over (ie can provide an iterator which returns its contents). Collections such as lists are sequences, and thus are iterable. The Scala iterator type provides methods map, filter, withFilter and flatMap.</p>

<p>Iterator method <code>map</code> takes every element provided by the iterator and applies a caller-specified method to transform that element into another object. The result is a collection containing 1 element for every element provided by the iterator - never more or less (unless the mapping function throws an exception).</p>

<p>Iterator method <code>filter</code> takes every element provided by the iterator, and applies a caller-specified boolean method to decide whether to “accept” the object or not. The result is a collection containing a subset of the elements provided by the iterator.</p>

<p>Note that <code>map</code> cannot filter out elements - everything is mapped 1:1. And <code>filter</code> cannot modify elements - they are either accepted or not. In fact, both of these methods are based on a more general one - <code>flatMap</code>. Flatmap works something like <code>map</code> but instead of being limited to 1:1 conversions it supports 1:N. The function that flatMap applies to each element takes one element as input and returns a list:</p>

<ul>
  <li>when the list is empty then the effect is like <code>filter</code> removing an object</li>
  <li>when the list contains exactly one element then the effect is like <code>map</code>
</li>
  <li>and the list can also contain multiple elements if desired (something not possible with map or filter)</li>
</ul>

<p>When invoked on standard collection types such as List, these methods are <em>immediate</em> (aka <em>eager</em>); they read all elements from the input iterator and write the results into memory. This is different from lazy-based languages such as Haskell, in which map/filter/flatMap are <em>lazy</em> and only take effect when data is needed.</p>

<p>Method <code>withFilter</code> is an <em>always lazy</em> version of filter; when invoked on an iterator it just returns another iterator. When an object is fetched from this second iterator, it repeatedly fetches elements from the underlying iterator until one is found which matches the filter condition. The effect from the caller viewpoint is identical: whether filter or withFilter is invoked, the set of objects returned from the iterator is just those for which the filter condition matches. However the lazy version can be more efficient - particularly if the entire sequence is not being consumed (eg when doing a <em>find</em> type operation that terminates when the first match is encountered).</p>

<p>Lazy versions of map, flatMap, etc are available via <code>streams</code> and <code>views</code> (eg <code>List.view.map(...)</code>)</p>

<p>Two other methods based on flatMap are <code>collect</code> and <code>partition</code>:</p>

<ul>
  <li>
<code>partition</code> works like <code>filter</code> except that it returns two lists - the “accepted” objects and the “rejected” objects. Method <code>filter</code> can be seen as a special case of <code>partition</code> where the rejected list is thrown away.</li>
  <li>
<code>collect</code> works like <code>filter</code> but the condition is defined via a <code>partial function</code> (eg case-clauses) rather than a boolean expression; which is more elegant is a matter of taste.</li>
</ul>

<h1 id="standard-functions-fold-and-reduce">Standard Functions fold and reduce</h1>

<p>The flatMap-related functions always treat each element in the input individually and unrelated to the others.</p>

<p>The <code>fold</code> family of functions are instead useful when the desired result requires interaction between the elements provided by the input iterator, eg summing a list of integers or finding the longest string in a list of strings. Method <code>reduce</code> is a special case of <code>fold</code>.</p>

<h1 id="for-comprehensions">For-comprehensions</h1>

<p>As noted earlier, for-loops can include multiple expressions (nested looping), embedded if-statements, and can optionally be followed by the <code>yield</code> keyword.</p>

<p>A for-loop without yield is equivalent to a sequence of calls to flatMap (the expressions), withFilter (the if-statements) and a final foreach. A for-loop with yield is equivalent to a sequence of calls to flatMap (the expressions), withFilter (the if-statements) and a final map.</p>

<p>Although for-loops and flatMap/filter/foreach/map are equivalent, complicated for-loops with multiple nested expressions and ifs are often easier to read than their function-based equivalents. However which to use is purely a matter of taste.</p>

<p>A simple loop without yield is effectively a “foreach” call; the following are identical:</p>

<pre><code>  for(i &lt;- 0 to 5; if (i % 2 == 0)) {println s"i is $i"}
  (0 to 5).withFilter(i =&gt; i % 2 == 0).foreach {i =&gt; println s"i is $i"}
</code></pre>

<p>A simple loop with yield is effectively a “map” call; the following are identical:</p>

<pre><code>  for(i &lt;- 0 to 5) yield i*2
  (0 to 5).map(i =&gt; i*2)
</code></pre>

<p>A for-loop can also be specified with curly-braces instead of parentheses; the syntax is very similar but the rules about using semicolons when specifying multiple expressions and if-statements are slightly different.</p>

<p>This <a href="https://stackoverflow.com/questions/1052476/what-is-scalas-yield">stackoverflow answer</a> has an excellent discussion on for-loops.</p>

<h1 id="annotations">Annotations</h1>

<p>Scala has annotations which resemble Java annotations. Some <a href="https://www.scala-lang.org/files/archive/spec/2.11/11-annotations.html">standard annotations</a> include:</p>

<ul>
  <li>
<code>@transient</code>, <code>@volatile</code>
</li>
  <li>
<code>@scala.beans.BeanProperty</code> - can be added to any member of a class, and triggers generation of a <code>getX</code> method; mutable members also get a <code>setX</code> method.</li>
  <li>
<code>@tailrec</code> - requires the compiler to report an error if the annotated method cannot be compiled with “tail recursion optimisation”</li>
</ul>

<p>Custom annotations are simply defined as traits which extend <code>scala.Annotation</code> or one of its subtypes.</p>

<p>Annotation types start with a lower-case letter by convention (unlike Java).</p>

<h1 id="tail-recursion">Tail Recursion</h1>

<p>Functional programming style uses recursive code definitions more often than traditional OO programming styles do. When a recursive function is implemented correctly, and the compiler implements “tail recursion optimisation” then recursive calls can compile to code just as efficient as an imperative loop. The Scala compiler does implement tail recursion optimisation.</p>

<p>Unfortunately, a slightly different recursive function may be impossible to apply “tail recursion optimisation” to; the code is then much less inefficient and potentially leads to stack-overflow errors. To catch such errors, a recursive function may be annotated with <code>@tailrec</code>; the compiler will then report an error if tail recursion optimisation is not possible.</p>

<h1 id="algebraic-data-types">Algebraic Data Types</h1>

<p>An ADT is either a “product type” or “sum type”.</p>

<p>Product types are familiar to OO developers - basically tuples and standard classes.</p>

<p>A Sum type is a finite set of classes implementing the same interface. If an instance of some “interface” type is known to be implemented by concrete type A or B or C, then together they form a sum type. Or in other words, the type is a <em>union</em> of a finite set of concrete implementations.</p>

<p>In OO terminology, different types can be told apart at runtime via “is instance”. In non-OO functional languages, specific instances of a sum type are described as having a “type tag” - the name of the concrete variant of the base interface.</p>

<h1 id="nested-inner-classes-and-path-dependent-types">Nested (Inner) Classes and Path-dependent Types</h1>

<p>In Java, a class can be declared within another class. When the nested (aka inner) class is declared “static” then this nesting simply affects the <em>name</em> of the nested class (namespacing). When the nested class is not declared “static” then it includes an implicit member which is a reference to a “parent instance”; an instance of the nested type can only be created via a parent instance.</p>

<p>Scala allows classes to be nested within <em>object</em> declarations. These act like Java’s “static inner classes” - they can be instantiated like “<code>new OuterType.InnerType</code>”.</p>

<p>Scala also allow classes to be declared within <em>classes</em>. These can be instantiated either:</p>

<ul>
  <li>from outside the enclosing class via syntax “<code>new someref.InnerType</code>”</li>
  <li>from within a method of the enclosing class via the normal syntax “<code>new InnerType</code>”.</li>
</ul>

<p>In both cases, this returns an object with an internal reference to the outer <em>instance</em> whose type is <code>OuterType#InnerType</code>. Classes nested within classes therefore act like Java non-static inner classes.</p>

<p>When a method of class <code>OuterType</code> returns (or exposes in any way) an instance of <code>InnerType</code> to a caller, and the caller invoked that method via a <em>val</em> (constant) reference then the compiler creates a kind of “type alias” for that returned object, of form <code>refname.InnerType</code>.</p>

<p>Two references to the nested type created via two different constant references are <em>not type-compatible at compile-time</em>.  When creating a generic collection (eg a list), adding the first element to that collection implicitly sets the type of that collection, and thereafter instances of the same nested class which are associated with different parents cannot be added to the list - a compile-time failure occurs.</p>

<p>These alias types are called “path-dependent types”. A reference of this type can always be “upcast” to the actual underlying type (<code>OuterType#InnerType</code>).</p>

<p>When the method returning an inner type is invoked via a <code>var</code> (mutable) reference then the returntype is not <code>refname.InnerType</code> but the underlying type <code>OuterType#InnerType</code> as the refname is not a stable value.</p>

<p>Nested types generated through two different references <code>ref1</code> and <code>ref2</code> are different (<code>ref1.InnerType</code> and <code>ref2.InnerType</code>) even if <code>ref1</code> and <code>ref2</code> point to the same object.</p>

<p>The most useful feature of dependent types is that when using a <em>val</em> reference to invoke a method on <code>OuterType</code> which takes an instance of <code>InnerType</code> as a parameter, the input parameter type is treated as <code>refname.InnerType</code> and therefore the compiler will only accept instances of <code>InnerType</code> which were obtained via the same <em>val</em> reference. Each instance of <code>OuterType</code> thus acts as a “closed system” that only accepts objects from its caller which are guaranteed to have been provided to the caller from <em>the same OuterType instance</em> (and in fact via the same constant reference to that instance).</p>

<p>Path-dependent types can sometimes be useful in preventing bugs (making incorrect combinations of objects impossible at sourcecode time), but are not widely used.</p>

<p>See the <a href="http://docs.scala-lang.org/tour/inner-classes.html">Scala Tour</a> for some examples.</p>

<h1 id="multithreading">Multithreading</h1>

<p>Standard class <code>scala.concurrent.Future</code> can be used to spawn threads almost explicitly:</p>

<pre><code>    import scala.concurrent.ExecutionContext.Implicits.global
    val future = scala.concurrent.Future { Thread.sleep(5000); "hi"}
    println(scala.concurrent.Await.result(future, Duration(10, TimeUnit.SECONDS)))
</code></pre>

<p>However in general, multithreaded applications should instead be built using the Actor pattern. Since v2.10, the Akka library is part of the Scala standard distribution, and provides an Actor-based library which also supports distributed processing.</p>

<p>Further information on futures can be found <a href="http://danielwestheide.com/blog/2013/01/09/the-neophytes-guide-to-scala-part-8-welcome-to-the-future.html">here</a>.</p>

<p>The standard library also includes “parallel collections” - most standard types provide a “par” method which returns an object which offers map/flatMap methods which apply an anonymous function in parallel over the collection using a global threadpool managed by the standard library.</p>

<p>When using multi-threading, synchronized access to shared data is of course needed. The equivalent of a Java synchronized method <code>synchronized void foo()</code> is <code>def foo(..) = synchronized {..}</code>.</p>

<h1 id="lazy-variables">Lazy Variables</h1>

<p>A variable may be marked as lazy in which case the initialization-expression is only evaluated when the variable is first read, eg</p>

<pre><code> lazy val foo = util.Random.nextInt
</code></pre>

<h1 id="partial-functions">Partial Functions</h1>

<p>A partial function is a function which is only defined for some inputs. Think of:</p>

<pre><code>def partial1(i: Int): String = {
  if (i==0) "zero"
  else if (i=1) "one"
  else if (i==2) "two"
}
</code></pre>

<p>Clearly there are many parameter values for which no return value is defined.</p>

<p>When a “partial” expression is executed with a value which is not handled, what happens depends upon the context. It might trigger an exception, or the return value might be defaulted to None (ie an Option wrapping), or might be defaulted to false.</p>

<p>Partial functions are often written in the form of a sequence of case-statements (without the surrounding match):</p>

<pre><code>  somelist.collect {
    case 1 | 2 =&gt; true
  }
</code></pre>

<h1 id="manifests">Manifests</h1>

<p>When a Java class that uses another generic class is compiled, the type-parameter used with that other generic class is lost; this is called “type erasure”. As an example:</p>

<pre><code>  class Foo {
    private List&lt;String&gt; mystrings = new List&lt;&gt;();
  }
</code></pre>

<p>just compiles to</p>

<pre><code>  class Foo {
    private List mystrings = new List();
  }
</code></pre>

<p>Inspecting object mystrings at runtime will provide no information about the type of object within the list.</p>

<p>This is actually a limitation of the JVM, and therefore Scala code has the same limitation. However Scala works around the issue by using parameters of type <code>Manifest[T]</code>. For any generic type, a manifest can be generated if requested. The usual way to request a manifest is for a generic function (or method on a generic type) to declare an implicit parameter of type Manifest; at each call-site the compiler will then ensure that a Manifest object is passed as part of the function call, describing the real type of the parameter (as known to the compiler at that callsite). Example:</p>

<pre><code>  def foo[A](someParam:A)(implicit mf: Manifest[A]) = {..}
</code></pre>

<p>At each location where foo is called, the compiler generates code to pass some external value as <code>someParam</code> - and also generates code to pass a descriptor of the type of <code>someParam</code> as a second parameter. Within method foo, parameter <code>mf</code> can then be used to obtain information about what type <code>someParam</code> actually has - reflection will not provide that information because someParam may have undergone type-erasure (eg when someParam has type <code>List[String]</code>).</p>

<h1 id="other-minor-features">Other Minor Features</h1>

<p>Operator <code>&amp;&amp;</code> is a short-circuit boolean operator, as usual in other languages. operator “&amp;” is a non-short-circuit boolean operator, ie same as “&amp;&amp;” but always evaluates both left and right sides. It is NOT a bit-and operator!</p>

<p>Scala does not have any direct equivalent to Java enums; there are <a href="https://underscore.io/blog/posts/2014/09/03/enumerations.html">various options</a> with different tradeoffs.</p>

<p>Scala supports “atoms” using form ‘someatom. An atom is a unique identifier and so can sometimes be used where an Enum would be used in Java (ie instead of using unique integer constants).</p>

<p>Package <code>scala.Predef</code> is imported into scope by default (like <code>java.lang</code> in Java).</p>

<p>Due to the lack of semi-colons, line-wrapping in Scala is slightly more complicated than Java. When a single expression is split over multiple lines, each line must either have an unclosed parenthetical or end with an infix method in which the right parameter is not given (eg <code>+</code>).</p>

<p>The recommended code-style for Scala <a href="http://docs.scala-lang.org/style/overview.html">can be found here</a>.</p>

<h1 id="ecosystem">Ecosystem</h1>

<p>Here is a short list of some frameworks which are commonly used with Scala applications:</p>

<ul>
  <li>play, lift, scalatra, akka</li>
  <li>scalaz (hard-core functional programming)</li>
  <li>SBT - scala’s build tool. But scala can also be built with maven etc.</li>
</ul>

<h1 id="ides">IDEs</h1>

<p>Some notes on using the IntelliJ IDE for Scala development:</p>

<ul>
  <li>Intellj Scala plugin available from standard JetBrains repo - just open “settings” and search for / install the plugin.</li>
  <li>When creating first Scala project, you will be prompted for “scala SDK” - select “create” then “download”. Or install Scala manually locally, then select that install location.</li>
  <li>for intellij+mac, the “scala console” evaluates expressions only after cmd-enter has been pressed.</li>
</ul>

<h1 id="references">References</h1>

<ul>
  <li><a href="http://docs.scala-lang.org/tutorials/tour/tour-of-scala.html">Scala-lang: Tour of Scala</a></li>
  <li><a href="https://twitter.github.io/scala_school/">Twitter: Scala School</a></li>
  <li>
<a href="http://twitter.github.io/effectivescala">Effective Scala</a> – tips from Twitter on what to do and what not to do in Scala</li>
  <li><a href="http://docs.scala-lang.org/style">The Scala Style Guide</a></li>
  <li><a href="http://rea.tech/java-to-scala-cheatsheet/">Java to Scala Cheatsheet</a></li>
  <li>
<a href="http://www.scala-lang.org/docu/files/collections-api/collections.html">Overview of the Scala Collections API</a> - useful for the “big picture’.</li>
  <li><a href="http://joelabrahamsson.com/learning-scala/">Abrahamsson: Learning Scala</a></li>
  <li><a href="http://daily-scala.blogspot.co.at">Daily Scala</a></li>
  <li>
<a href="http://danielwestheide.com/scala/neophytes.html">Westheide: Neophytes Guide to Scala</a> - covers only specific topics, but covers them very well.</li>
  <li>
<a href="https://alvinalexander.com/scala?page=1">Alvin Alexander: Scala</a> - a collection of Scala tips</li>
  <li>
<a href="http://underscore.io/books/advanced-scala/">Advanced Scala with Cats</a> - more advanced functional Scala usage</li>
  <li>Programming Scala Second Edition</li>
  <li>Scala for Java Developers by Toby Weston – Pluralsight Video</li>
</ul>

    </article>
  </div>
    
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'mineofinformation'; // mineofinformation (disqus site id)
      var disqus_pageid = '/java/scala/'; // /relative/path/to/article/dir

      var disqus_config = function () {
        this.page.identifier = disqus_pageid;
        this.page.url = 'https://moi.vonos.net' + disqus_pageid;
      };
      (function() {
        var d = document, s = d.createElement('script');
        s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  



      </section>
    </div>
    <section id="footer">
      <p>Copyright &copy; 2025 - Simon Kitching</p>
    </section>
  </body>
</html>

